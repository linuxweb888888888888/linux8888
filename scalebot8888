/******************************************************************************************
 * ⚡ GENIUS BOT — FULL DASHBOARD (RELIABLE PARTIAL CLOSE)
 * - Partial close 1 unit if ROI >= 0.04%
 * - Scale 1 unit at support/resistance once per touch
 * - Close 100 units if margin < 0.000005
 * - Material Design white responsive dashboard
 * - ROI % displayed in red/green
 * - Dashboard logs partial close events
 ******************************************************************************************/

require('dotenv').config();
const express = require('express');
const http = require('http');
const { Server } = require('socket.io');
const ccxt = require('ccxt');
const minimist = require('minimist');

const args = minimist(process.argv.slice(2));
const COIN = args.coin?.toUpperCase() || 'ADA';
const PORT = parseInt(args.port) || 3000;

const CONFIG = {
    PRICE_SYMBOL: `${COIN}/USDT`,
    ORDER_SYMBOL: `${COIN}/USDT:USDT`,
    LOOKBACK_PERIOD: 50,
    PRICE_RATE: 2000,
    SCALE_QTY: 1,
    PARTIAL_CLOSE_ROI: 0.04, // 0.04%
    PARTIAL_CLOSE_QTY: 1,
    MARGIN_MIN: 0.000005,
    MARGIN_CLOSE_QTY: 100
};

const state = {
    positions: { qty: 0, entry: 0, side: null },
    history: [],
    price: 0,
    bid: 0,
    ask: 0,
    support: 0,
    resistance: 0,
    status: 'INIT',
    scaledSupport: false,
    scaledResistance: false,
    availableMargin: 0,
    roiPercent: 0
};

const exchange = new ccxt.phemex({
    apiKey: process.env.PHEMEX_KEY,
    secret: process.env.PHEMEX_SECRET,
    enableRateLimit: true,
    options: { defaultType: 'swap' }
});

// ================= PRICE =================
async function fetchPrice() {
    const t = await exchange.fetchTicker(CONFIG.PRICE_SYMBOL);
    state.bid = t.bid;
    state.ask = t.ask;
    state.price = (t.bid + t.ask) / 2;
}

// ================= MARGIN =================
async function fetchMargin() {
    const bal = await exchange.fetchBalance();
    state.availableMargin = bal.free?.USDT ?? 0;
}

// ================= POSITION SYNC =================
async function syncPositions(io) {
    let posData = [];
    try { posData = await exchange.fetchPositions([CONFIG.ORDER_SYMBOL]); }
    catch { posData = await exchange.fetchPositions(); }

    const p = posData.find(x => x.symbol === CONFIG.ORDER_SYMBOL) || {};
    const qty = Number(p.contracts || 0);
    const entry = Number(p.entryPrice || 0);

    let side = null;
    if (p.side) {
        if (p.side.toLowerCase() === 'long') side = 'LONG';
        if (p.side.toLowerCase() === 'short') side = 'SHORT';
    }

    state.positions = qty > 0 ? { qty, entry, side } : { qty: 0, entry: 0, side: null };
    io.emit('log', `[SYNC] pos=${state.positions.side || 'NONE'} qty=${state.positions.qty}`);
}

// ================= ORDERS =================
async function placeOrder(side, qty, io) {
    io.emit('log', `[ORDER] ${side.toUpperCase()} ${qty}`);
    await exchange.createOrder(CONFIG.ORDER_SYMBOL, 'market', side, qty);
    await new Promise(r => setTimeout(r, 300));
    await syncPositions(io);
}

// ================= PARTIAL CLOSE =================
async function closePartial(qty, io) {
    const pos = state.positions;
    if (!pos.side || pos.qty < qty) return;
    const side = pos.side === 'LONG' ? 'sell' : 'buy';
    await exchange.createOrder(CONFIG.ORDER_SYMBOL, 'market', side, qty);
    io.emit('log', `⚠️ PARTIAL CLOSE | ${qty} units at ROI=${state.roiPercent.toFixed(6)}%`);
    await syncPositions(io);
}

// ================= STRATEGY =================
async function strategy(io) {
    await fetchPrice();
    await fetchMargin();
    await syncPositions(io);

    const price = state.price;
    const pos = state.positions;

    // -------- MARGIN PROTECTION --------
    if (state.availableMargin < CONFIG.MARGIN_MIN && pos.qty >= CONFIG.MARGIN_CLOSE_QTY) {
        await closePartial(CONFIG.MARGIN_CLOSE_QTY, io);
        state.status = 'MARGIN PROTECT';
    }

    // -------- PRICE HISTORY --------
    state.history.push(price);
    if (state.history.length > 300) state.history.shift();

    const window = state.history.slice(-CONFIG.LOOKBACK_PERIOD);
    state.support = Math.min(...window);
    state.resistance = Math.max(...window);

    // -------- CALCULATE ROI --------
    let roiPercent = 0;
    if (pos.side === 'LONG' && pos.entry) roiPercent = ((price - pos.entry) / pos.entry) * 100;
    if (pos.side === 'SHORT' && pos.entry) roiPercent = ((pos.entry - price) / pos.entry) * 100;
    state.roiPercent = roiPercent;

    io.emit('log', `DEBUG | price=${price.toFixed(6)} ROI=${roiPercent.toFixed(6)}%`);

    // -------- PARTIAL CLOSE LOGIC --------
    if (pos.side && roiPercent >= CONFIG.PARTIAL_CLOSE_ROI && pos.qty >= CONFIG.PARTIAL_CLOSE_QTY) {
        await closePartial(CONFIG.PARTIAL_CLOSE_QTY, io);
        state.status = `PARTIAL CLOSE | ROI ${roiPercent.toFixed(2)}%`;
    }

    // -------- SCALE LOGIC --------
    if (pos.side) {
        if (price <= state.support && !state.scaledSupport) {
            await placeOrder(pos.side === 'LONG' ? 'buy' : 'sell', CONFIG.SCALE_QTY, io);
            io.emit('log', `[SCALE] ${pos.side} @ SUPPORT`);
            state.status = 'SCALE';
            state.scaledSupport = true;
        }
        if (price >= state.resistance && !state.scaledResistance) {
            await placeOrder(pos.side === 'LONG' ? 'buy' : 'sell', CONFIG.SCALE_QTY, io);
            io.emit('log', `[SCALE] ${pos.side} @ RESISTANCE`);
            state.status = 'SCALE';
            state.scaledResistance = true;
        }
    }

    // Reset scaling when price moves inside range
    if (price > state.support && price < state.resistance) {
        state.scaledSupport = false;
        state.scaledResistance = false;
    }

    if (!pos.side) state.status = 'WAIT';

    io.emit('stats', {
        price: state.price,
        bid: state.bid,
        ask: state.ask,
        support: state.support,
        resistance: state.resistance,
        posType: pos.side || 'NONE',
        qty: pos.qty,
        entry: pos.entry,
        status: state.status,
        availableMargin: state.availableMargin,
        roiPercent
    });
}

// ================= RUN LOOP =================
async function run(io) {
    while (true) {
        try { await strategy(io); } 
        catch (e) { io.emit('log', e.message); }
        await new Promise(r => setTimeout(r, CONFIG.PRICE_RATE));
    }
}

// ================= SERVER =================
const app = express();
const server = http.createServer(app);
const io = new Server(server);

app.get('/', (_, res) => res.send(DASHBOARD_HTML));

server.listen(PORT, () => {
    console.log(`Dashboard running http://localhost:${PORT}`);
    run(io);
});

// ================= DASHBOARD =================
const DASHBOARD_HTML = `
<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>GENIUS BOT — ${COIN}/USDT</title>
<script src="https://cdn.jsdelivr.net/npm/socket.io-client@4/dist/socket.io.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
:root{
 --bg:#f5f6fa;
 --card:#ffffff;
 --text:#1f2937;
 --muted:#6b7280;
 --green:#16a34a;
 --red:#dc2626;
 --shadow:0 8px 24px rgba(0,0,0,.08);
}
body{margin:0; background:var(--bg); font-family:Inter,system-ui,sans-serif; color:var(--text);}
.container{max-width:1200px; margin:auto; padding:16px;}
h1{font-size:20px; margin-bottom:16px;}
.grid{display:grid; grid-template-columns:repeat(auto-fit,minmax(140px,1fr)); gap:12px;}
.card{background:var(--card); border-radius:14px; padding:12px; box-shadow:var(--shadow); text-align:center;}
.label{font-size:11px; color:var(--muted);}
.value{font-family:monospace; font-size:14px; font-weight:600;}
.pos-LONG{color:var(--green);}
.pos-SHORT{color:var(--red);}
#chartWrap{background:var(--card); border-radius:14px; padding:10px; margin-top:16px; box-shadow:var(--shadow);}
#log{background:#111827; color:#e5e7eb; font-family:monospace; font-size:12px; border-radius:14px; padding:10px; margin-top:16px; height:160px; overflow:auto;}
</style>
</head>
<body>
<div class="container">
<h1>GENIUS BOT — ${COIN}/USDT</h1>
<div class="grid">
 <div class="card"><div class="label">PRICE</div><div class="value" id="p">--</div></div>
 <div class="card"><div class="label">POSITION</div><div class="value" id="pos">NONE</div></div>
 <div class="card"><div class="label">QTY</div><div class="value" id="q">0</div></div>
 <div class="card"><div class="label">ENTRY</div><div class="value" id="e">0</div></div>
 <div class="card"><div class="label">SUPPORT</div><div class="value" id="s">--</div></div>
 <div class="card"><div class="label">RESISTANCE</div><div class="value" id="r">--</div></div>
 <div class="card"><div class="label">ROI %</div><div class="value" id="roi">0</div></div>
 <div class="card"><div class="label">STATUS</div><div class="value" id="st">--</div></div>
 <div class="card"><div class="label">AVAILABLE MARGIN</div><div class="value" id="m">0</div></div>
</div>
<div id="chartWrap"><canvas id="chart"></canvas></div>
<div id="log"></div>
</div>

<script>
const socket=io();
const log=document.getElementById('log');
const ctx=document.getElementById('chart');

const chart=new Chart(ctx,{
 type:'line',
 data:{labels:[],datasets:[
  {label:'Price',data:[],borderColor:'#2563eb',pointRadius:0},
  {label:'Resistance',data:[],borderColor:'#dc2626',pointRadius:0,stepped:true},
  {label:'Support',data:[],borderColor:'#16a34a',pointRadius:0,stepped:true}
 ]},
 options:{animation:false,responsive:true}
});

socket.on('stats',d=>{
 p.innerText=d.price?.toFixed(6);
 pos.innerText=d.posType;
 pos.className='value '+(d.posType==='LONG'?'pos-LONG':d.posType==='SHORT'?'pos-SHORT':'');
 q.innerText=d.qty;
 e.innerText=d.entry?.toFixed(6);
 s.innerText=d.support?.toFixed(6);
 r.innerText=d.resistance?.toFixed(6);
 st.innerText=d.status;
 m.innerText=d.availableMargin?.toFixed(6);
 roi.innerText=d.roiPercent?.toFixed(2)+'%';
 roi.className='value '+(d.roiPercent>=0?'pos-LONG':'pos-SHORT');

 chart.data.labels.push(new Date().toLocaleTimeString());
 chart.data.datasets[0].data.push(d.price);
 chart.data.datasets[1].data.push(d.resistance);
 chart.data.datasets[2].data.push(d.support);

 if(chart.data.labels.length>200){
  chart.data.labels.shift();
  chart.data.datasets.forEach(x=>x.data.shift());
 }
 chart.update('none');
});

socket.on('log',m=>{
 const d=document.createElement('div');
 d.textContent=new Date().toLocaleTimeString()+' '+m;
 log.prepend(d);
 if(log.children.length>200) log.removeChild(log.lastChild);
});
</script>
</body>
</html>
`;
