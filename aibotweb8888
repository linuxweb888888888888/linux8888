#!/usr/bin/env python3
import ccxt
import time
import numpy as np
import pandas as pd
from rich.console import Console
from rich.table import Table
from rich.panel import Panel
from rich.live import Live
from sklearn.linear_model import SGDRegressor
import subprocess
import traceback
import os
import random

console = Console()

# ============================
# CONFIG
# ============================
SYMBOL = "ATOM/USDT"
BASE = "ATOM"
QUOTE = "USDT"
MIN_QTY = 0.001
MAX_POSITIONS = 10
FEE_RATE = 0.001
WALLET_RISK = 0.35
UPDATE_INTERVAL = 5
MODEL_WINDOW = 50
CONF_THRESHOLD = 0.3
MAX_CONFIDENCE = 1
SMOOTH_WINDOW = 3
HTML_DASHBOARD_FILE = "/var/www/html/dashboard.html"

# ============================
# EXCHANGE INIT
# ============================
exchange = ccxt.hitbtc({"enableRateLimit": True})

# ============================
# STATE
# ============================
open_positions = []
background_sim_positions = []
profit_history = []
model = SGDRegressor(max_iter=1, tol=None, learning_rate="invscaling", eta0=0.01, warm_start=True)
model_initialized = False
starting_wallet = None
pred_history = []
signal_accuracy = []

# ============================
# DATA FETCHING
# ============================
def get_ohlcv():
    try:
        data = exchange.fetch_ohlcv(SYMBOL, timeframe="1m", limit=MODEL_WINDOW)
        df = pd.DataFrame(data, columns=["time","open","high","low","close","volume"])
        df['mid'] = (df['high'] + df['low'])/2
        df['returns'] = df['mid'].pct_change().fillna(0)
        df['volatility'] = df['mid'].rolling(SMOOTH_WINDOW).std().fillna(0.0001)
        return df
    except Exception as e:
        console.print(f"[red]OHLCV Error: {e}[/red]")
        return None

def get_wallet_balance():
    try:
        if not os.path.exists("/wallet.sh"):
            console.print("[red]ERROR: wallet.sh not found[/red]")
            return 0
        result = subprocess.run(["bash", "/wallet.sh"], capture_output=True, text=True)
        return float(result.stdout.strip())
    except Exception as e:
        console.print(f"[red]Wallet fetch error: {e}[/red]")
        return 0

def get_coin_real_info():
    try:
        if not os.path.exists("/coinrealinfo.sh"):
            return None
        result = subprocess.run(["bash", "/coinrealinfo.sh", BASE+QUOTE+"_PERP"], capture_output=True, text=True)
        output = result.stdout.strip().splitlines()
        data = {}
        for line in output:
            if ':' not in line: continue
            key, value = line.split(":", 1)
            data[key.strip().lower()] = value.strip().lower()

        def safe_float(val):
            try:
                return float(val)
            except:
                return 0.0

        qty   = safe_float(data.get("quantity", 0))
        entry = safe_float(data.get("entry price", 0))
        pnl   = safe_float(data.get("pnl", 0))

        bid, ask, mid = get_bid_ask_mid()
        if pnl == 0 and qty != 0 and entry != 0:
            pnl = ((bid - entry)*abs(qty) - bid*abs(qty)*FEE_RATE) if qty > 0 else ((entry - ask)*abs(qty) - ask*abs(qty)*FEE_RATE)

        return {"entry": entry, "qty": qty, "pnl": pnl}
    except Exception as e:
        console.print(f"[red]Coin info fetch error: {e}[/red]")
        return None

def get_bid_ask_mid():
    try:
        ticker = exchange.fetch_ticker(SYMBOL)
        bid = ticker.get('bid',0) or 0
        ask = ticker.get('ask',0) or 0
        if bid == ask: ask += 0.0001
        return bid, ask, (bid + ask)/2
    except Exception as e:
        console.print(f"[red]Bid/Ask fetch error: {e}[/red]")
        return 0,0,0

# ============================
# MODEL
# ============================
def train_model_incremental(df):
    global model_initialized
    try:
        X = np.arange(len(df)).reshape(-1,1)
        y = df['mid'].values
        recent_changes = np.diff(df['mid'].values[-SMOOTH_WINDOW:]) if len(df['mid'].values) >= SMOOTH_WINDOW else np.array([1e-6])
        volatility = max(np.mean(np.abs(recent_changes)), 1e-4)
        model.eta0 = min(0.05, 0.01 + volatility*0.5)
        if not model_initialized:
            model.partial_fit(X, y)
            model_initialized = True
        else:
            recent_X = X[-5:]
            recent_y = y[-5:]
            for i in range(len(recent_X)):
                weight = 1 + i*0.2
                model.partial_fit([recent_X[i]], [recent_y[i]], sample_weight=[weight])
    except Exception as e:
        console.print(f"[red]Model training error: {e}[/red]")

def predict_pnl_direction(df):
    if not model_initialized: return 0,0
    try:
        bid, ask, mid = get_bid_ask_mid()
        X_future = np.array([[len(df)]])
        pred = model.predict(X_future)[0]
        change = pred - mid

        sim_effect = 0
        for pos in background_sim_positions:
            weight = 1.0
            sim_effect += weight*((mid - pos['entry']) if pos['side']=='buy' else (pos['entry'] - mid))
        sim_effect /= max(1, len(background_sim_positions))
        change += sim_effect

        recent_changes = np.diff(df['mid'].values[-SMOOTH_WINDOW:]) if len(df['mid'].values) >= SMOOTH_WINDOW else np.array([1e-6])
        volatility = max(np.mean(np.abs(recent_changes)), 1e-4)

        pred_history.append(change)
        if len(pred_history) > 5:
            pred_history.pop(0)
        smoothed_change = np.mean(pred_history)

        confidence = min(MAX_CONFIDENCE, max(0.0, abs(smoothed_change)/volatility))
        return smoothed_change, confidence
    except Exception as e:
        console.print(f"[red]Prediction error: {e}[/red]")
        return 0,0

# ============================
# SIGNAL
# ============================
def get_signal(df):
    try:
        typical = (df['high'] + df['low'] + df['close'])/3
        sma = typical.rolling(20).mean()
        mad = typical.rolling(20).apply(lambda x: np.mean(np.abs(x - np.mean(x))), raw=True)
        cci = (typical - sma)/(0.015 * mad.replace(0,1e-6))
        last_cci = cci.iloc[-1] if not np.isnan(cci.iloc[-1]) else 0
        if last_cci > 100: return "buy"
        elif last_cci < -100: return "sell"
        return "hold"
    except Exception as e:
        console.print(f"[red]Signal calculation error: {e}[/red]")
        return "hold"

# ============================
# ORDERS
# ============================
def execute_real_order(side, qty):
    qty_str = f"{qty:.6f}"
    try:
        if not os.path.exists("/placeorder.sh"):
            console.print("[red]ERROR: placeorder.sh not found[/red]")
            return False
        result = subprocess.run(["bash", "/placeorder.sh", BASE, qty_str, side], capture_output=True, text=True)
        out = result.stdout.strip()
        if "SUCCESS" in out.upper():
            with open("/var/log/bot_orders.log", "a") as f:
                f.write(f"{time.ctime()} {side} {qty:.6f}\n")
            return True
        console.print(f"[red]Order ERROR: {out}[/red]")
        return False
    except Exception as e:
        console.print(f"[red]Execution error: {e}[/red]")
        return False

def calc_order_qty(wallet, price, predicted_profit=0, confidence=1.0):
    try:
        use_usdt = wallet * WALLET_RISK * confidence
        qty = use_usdt / price * (1 + predicted_profit*2)
        qty = max(MIN_QTY, np.floor(qty*1000)/1000)
        qty = min(qty, wallet*WALLET_RISK*0.9)
        return qty
    except Exception as e:
        console.print(f"[red]Qty calc error: {e}[/red]")
        return MIN_QTY

def add_position(side, qty, entry_price, predicted_pnl=0.0):
    if len(open_positions) < MAX_POSITIONS:
        open_positions.append({
            "side": side,
            "qty": qty,
            "entry": entry_price,
            "time": time.time(),
            "realized_pnl": 0,
            "predicted_pnl": predicted_pnl
        })

def update_real_pnl():
    coin_info = get_coin_real_info()
    if coin_info:
        if open_positions:
            pos = open_positions[0]
            pos['qty'] = coin_info['qty']
            pos['entry'] = coin_info['entry']
            pos['realized_pnl'] = coin_info['pnl']
        else:
            if coin_info['qty'] >= MIN_QTY:
                side = 'buy' if coin_info['qty'] > 0 else 'sell'
                add_position(side, abs(coin_info['qty']), coin_info['entry'])
                open_positions[0]['realized_pnl'] = coin_info['pnl']
    else:
        for pos in open_positions:
            pos['realized_pnl'] = 0.0

# ============================
# SIMULATION & LEARNING
# ============================
def simulate_background(signal, mid, n_trades=3):
    global background_sim_positions
    try:
        for _ in range(n_trades):
            sim_side = signal if signal in ['buy','sell'] else random.choice(['buy','sell'])
            background_sim_positions.append({
                "side": sim_side,
                "entry": mid,
                "sim_pnl": 0.0,
                "qty": MIN_QTY
            })
        background_sim_positions = [
            p for p in background_sim_positions
            if abs((mid - p['entry']) if p['side']=='buy' else (p['entry'] - mid)) <= 1000
        ]
    except Exception as e:
        console.print(f"[red]Simulation error: {e}[/red]")

def learn_from_simulations(mid):
    try:
        expected_buy, expected_sell = [], []
        for pos in background_sim_positions:
            pnl = (mid - pos['entry'])*pos['qty'] - mid*pos['qty']*FEE_RATE if pos['side']=='buy' else (pos['entry'] - mid)*pos['qty'] - mid*pos['qty']*FEE_RATE
            if pos['side']=='buy':
                expected_buy.append(pnl)
            else:
                expected_sell.append(pnl)
        avg_buy = np.mean(expected_buy) if expected_buy else 0
        avg_sell = np.mean(expected_sell) if expected_sell else 0
        if avg_buy >= avg_sell:
            best_side = 'buy'
            best_entry = np.mean([p['entry'] for p in background_sim_positions if p['side']=='buy']) if expected_buy else mid
            predicted_profit = avg_buy
        else:
            best_side = 'sell'
            best_entry = np.mean([p['entry'] for p in background_sim_positions if p['side']=='sell']) if expected_sell else mid
            predicted_profit = avg_sell
        return best_side, best_entry, predicted_profit
    except Exception as e:
        console.print(f"[red]Learning error: {e}[/red]")
        return "hold", mid, 0.0

# ============================
# ADAPTIVE POSITION MANAGEMENT
# ============================
def manage_positions(mid, wallet, confidence):
    global open_positions
    try:
        for pos in open_positions[:]:
            unrealized_pnl = (mid - pos['entry'])*pos['qty'] - mid*pos['qty']*FEE_RATE if pos['side']=='buy' else (pos['entry'] - mid)*pos['qty'] - mid*pos['qty']*FEE_RATE
            pos['realized_pnl'] = unrealized_pnl

            profit_target = 0.005 * wallet
            stop_loss = -0.01 * wallet
            if unrealized_pnl >= profit_target or unrealized_pnl <= stop_loss:
                execute_real_order('sell' if pos['side']=='buy' else 'buy', pos['qty'])
                open_positions.remove(pos)

        wallet_used = sum([p['qty']*mid for p in open_positions])
        wallet_free = wallet * WALLET_RISK - wallet_used
        if wallet_free >= MIN_QTY*mid:
            best_side, best_entry, predicted_profit = learn_from_simulations(mid)
            if best_side in ['buy','sell'] and confidence > CONF_THRESHOLD:
                qty = calc_order_qty(wallet, mid, predicted_profit, confidence)
                if qty >= MIN_QTY:
                    price = best_entry
                    success = execute_real_order(best_side, qty)
                    if success:
                        add_position(best_side, qty, price, predicted_profit)

# ============================
# DASHBOARD
# ============================
def calculate_position_stats(mid):
    if not open_positions:
        return "NO INFO", 0, 0, 0
    total_qty = 0
    total_cost = 0
    wins = 0
    losses = 0
    for pos in open_positions:
        qty = pos["qty"]
        entry = pos["entry"]
        total_qty += qty
        total_cost += qty * entry
        pnl = pos.get('realized_pnl',0)
        if pnl > 0: wins += 1
        elif pnl < 0: losses += 1
    avg_entry = total_cost / total_qty if total_qty > 0 else 0
    total_pnl = sum([p.get('realized_pnl',0) for p in open_positions])
    return avg_entry, total_pnl, wins, losses

def render_dashboard(signal, pred, conf, bid, ask, mid, wallet, wallet_delta, wallet_delta_percent):
    try:
        avg_entry, total_pnl, wins, losses = calculate_position_stats(mid)
        wallet_color = "green" if wallet_delta > 0 else "red" if wallet_delta < 0 else "grey"
        wallet_sign = "+" if wallet_delta > 0 else "-" if wallet_delta < 0 else ""
        pred_text = f"Price expected ↑ {pred:.6f}" if pred>0 else f"Price expected ↓ {abs(pred):.6f}" if pred<0 else "No significant change → 0.0"
        accuracy = np.mean(signal_accuracy[-20:])*100 if signal_accuracy else 0.0
        sim_count = len(background_sim_positions)

        if avg_entry == "NO INFO":
            positions_html = "<div class='card'><h3>Open Positions</h3><p>NO INFO</p></div>"
        else:
            positions_html = "<div class='card'><h3>Open Positions</h3><ul style='list-style:none; padding-left:0;'>"
            for i, pos in enumerate(open_positions):
                color = 'green' if pos['realized_pnl'] >= 0 else 'red'
                symbol = '●'
                positions_html += (
                    f"<li style='color:{color}; font-size:14px; margin-bottom:6px;'>"
                    f"{symbol} Pos {i+1} ({pos['side'].upper()}): "
                    f"Qty={pos['qty']:.6f}, Entry={pos['entry']:.6f}, "
                    f"PnL={pos['realized_pnl']:.8f}</li>"
                )
            positions_html += "</ul></div>"

        if avg_entry == "NO INFO":
            profit_html = "<div class='card'><h3>Profit History</h3><p>NO INFO</p></div>"
        else:
            profit_html = "<div class='card'><h3>Profit History</h3><ul style='list-style:none; padding-left:0;'>"
            recent_profits = profit_history[-10:]
            for i, p in enumerate(recent_profits):
                color = 'green' if p >= 0 else 'red'
                symbol = '●'
                profit_html += f"<li style='color:{color}; font-size:16px; margin-bottom:4px;'>{symbol} Cycle {len(profit_history)-len(recent_profits)+i+1}: {p:.8f}</li>"
            cum_profit = sum(recent_profits) if recent_profits else 0
            cum_color = 'green' if cum_profit >= 0 else 'red'
            profit_html += f"<li style='color:{cum_color}; font-weight:bold; font-size:16px;'>{symbol} Cumulative Profit (last 10): {cum_profit:.8f}</li>"
            profit_html += "</ul></div>"

        pred_vs_actual_html = "<div class='card'><h3>Predicted vs Actual PnL</h3><ul style='list-style:none; padding-left:0;'>"
        if open_positions:
            for i, pos in enumerate(open_positions):
                predicted = pos.get('predicted_pnl', 0.0)
                actual = pos.get('realized_pnl', 0.0)
                color = 'green' if actual >= 0 else 'red'
                symbol = '●'
                pred_vs_actual_html += (
                    f"<li style='color:{color}; font-size:14px; margin-bottom:6px;'>"
                    f"{symbol} Pos {i+1} ({pos['side'].upper()}): Predicted={predicted:.8f}, Actual={actual:.8f}</li>"
                )
        else:
            pred_vs_actual_html += "<li>No open positions</li>"
        pred_vs_actual_html += "</ul></div>"

        html_content = f"""
        <html>
        <head>
            <meta charset="utf-8">
            <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
            <style>
                body {{
                    font-family: 'Roboto', sans-serif;
                    background-color: #f5f5f5;
                    color: #333;
                    margin: 0; padding: 0;
                }}
                .container {{
                    display: grid;
                    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
                    gap: 16px;
                    padding: 16px;
                }}
                .card {{
                    background: white;
                    border-radius: 12px;
                    padding: 16px;
                    box-shadow: 0 2px 10px rgba(0,0,0,0.1);
                }}
                h3 {{
                    margin-top: 0;
                    font-size: 18px;
                    color: #1976d2;
                }}
            </style>
        </head>
        <body>
            <div class="container">
                <div class="card">
                    <h3>Market Info</h3>
                    <p>Signal: {signal.upper()}</p>
                    <p>Bid: {bid:.6f}</p>
                    <p>Ask: {ask:.6f}</p>
                    <p>Mid: {mid:.6f}</p>
                    <p>{pred_text}</p>
                    <p>Confidence: {conf:.2f}</p>
                    <p>Wallet: {wallet:.6f} USDT ({wallet_sign}{wallet_delta:.6f}, {wallet_delta_percent:.2f}%)</p>
                </div>
                {positions_html}
                {profit_html}
                {pred_vs_actual_html}
            </div>
        </body>
        </html>
        """
        with open(HTML_DASHBOARD_FILE, "w") as f:
            f.write(html_content)
    except Exception as e:
        console.print(f"[red]Dashboard render error: {e}[/red]")

# ============================
# MAIN LOOP
# ============================
def main():
    global starting_wallet
    while True:
        try:
            df = get_ohlcv()
            if df is None:
                time.sleep(UPDATE_INTERVAL)
                continue

            # Train and predict
            train_model_incremental(df)
            pred_change, confidence = predict_pnl_direction(df)
            signal = get_signal(df)
            bid, ask, mid = get_bid_ask_mid()

            # Simulate background trades for learning
            simulate_background(signal, mid)

            # Wallet info
            wallet = get_wallet_balance()
            if starting_wallet is None:
                starting_wallet = wallet
            wallet_delta = wallet - starting_wallet
            wallet_delta_percent = ((wallet - starting_wallet)/starting_wallet*100) if starting_wallet else 0

            # Manage adaptive positions
            manage_positions(mid, wallet, confidence)

            # Update real PnL from exchange
            update_real_pnl()

            # Track profit and signal accuracy
            total_pnl = sum([p.get('realized_pnl',0) for p in open_positions])
            profit_history.append(total_pnl)
            signal_accuracy.append(1 if pred_change*(1 if signal=="buy" else -1) >0 else 0)

            # Render HTML dashboard
            render_dashboard(signal, pred_change, confidence, bid, ask, mid, wallet, wallet_delta, wallet_delta_percent)

            time.sleep(UPDATE_INTERVAL)

        except Exception as e:
            console.print(f"[red]Main loop error: {e}[/red]")
            traceback.print_exc()
            time.sleep(UPDATE_INTERVAL)

if __name__ == "__main__":
    try:
        # Close all positions on startup
        if os.path.exists("/closepositions.sh"):
            subprocess.run(["bash","/closepositions.sh"])
    except:
        pass
    main()












































####UPGRADE BOT WITH ALL FEATURES####

# Use coin minimum quantity for scaling and when increasing/decreasing positions
# Do not open real positions smaller than the minimum coin quantity of 0.001 for ATOM
# Continuously learn and adapt
# Generate trading signals faster
# Scale order positions for maximum profit
# Increase wallet gains according to predicted profit
# Achieve fast USDT wallet growth
# Place order quantity based on wallet usage; justify amounts and adapt dynamically
# Improve wallet learning for maximum profit
# Get wallet balance from wallet.sh in USDT
# Learn for stacked positions in one direction
# Improve open trade (opentrade) learning
# Use only a terminal rich dashboard
# Output order results via placeorder.sh – show SUCCESS if orders successful, ERROR if not
# Learn wallet amount according to profit and adapt
# Simulate background positions to improve learning and adapt to real PnL and profit
# Place orders faster with signal updates
# Write output to HTML dashboard at /var/www/html/dashboard.html using a static Material Design clean layout (no charts)
# Open trades based on wallet amount and calculate for maximum profit
# Add confidence and accuracy to predictions
# Check calculations to ensure order placement within 1 minute
# Calculate wallet threshold before placing orders; use only enough quantity to increase profit
# Calculate and learn profitable trades; adapt using background simulated trades
# Use wallet amount to calculate open trades and quantity with PnL prediction for maximum profit
# Never use Plotly
# Place real orders via placeorder.sh
# Improve PnL learning and open trade performance
# Take profit when PnL covers fees or predicted profit can be made; close positions accordingly
# Material Design dashboard must be static, updated with information only
# Focus on ATOM only (no multi-symbol trading)
# Direction mapping: buy = long = uptrend, sell = short = downtrend
# Learn and adapt minimum open position (0.001 ATOM)
# Use bid and ask for mid and real prices; adapt and learn
# Fix issues:
  # Module 'sklearn' has no attribute 'SGDRegressor'
  # KeyErrors
  # Background simulations
  # Dashboard not writing HTML data
  # Blank dashboard.html in browser
  # Buy/sell loop not starting
  # Library errors/exceptions/warnings for numpy, pandas, sklearn
  # wallet change feature show increased or decreased profit or loss in percentage not cumulating or decumalating
  # Coin info fetch error: could not convert string to float: coinrealinfo.sh
  # bot not writing to html file
  # also fix warning and errors and exceptions if found
  # background simulation count not showing html dashboard
# Make script ready to run
# Always place real trades when profitable; never dry run
# Enable multi-sizing and multi-positions
# Increase learning to grow USDT wallet
# When wallet usage is full, check where positions can be closed and opened for maximum profit; adapt accordingly
# Continuously learn PnL
# add real pnl for each entryprice trade
# trade in smaller quantity but with more profitable predictions and profit
# fix profit hitory trend make readable
# make prediction human readable in dashboard
# show signal accuracy in dashboard for prediction
# close all trades with bash script closepositions.sh when start bot
# calculate real accurate pnl for calculations
# upgrade html dashboard make more advanced
# upgrade bot make more advanced
# quantity can only be in steps of 0.001 or minimum quantity of coin learn and adapt for increasing or decreasing positions
# entryprice when order place is current bid or ask price calculate learn and adapt calculate according to direction
# bid and ask should not be the same price ord mid price learn and adapt
# when opening trade use current bid or ask for entryprice according to direction learn and adapt
# display pnl in html dashboard in decimal stil use real prices and pnl and other real factors
# while opening orders make the prices stil update while opening trades or orders
#calculate learning and adaptiveness on the updated decimals and try to improve accuraccy and profit and wallet growth and pnl prediction stil use real prices and pnl and other real factors
# if direction sell calculate pnl with bid price if direction buy calculate pnl with ask price learning accordingly and adapt
# if open position direction sell entryprice should be ask price and if open position direction buy entryprice should be bid price calculate pnl according learn and adapt
# use coinrealinfo.sh for accurate learning and accurate adapting real open trade can be calculated with quantity can also get real pnl and learn from that also the entryprice is in coinrealinfo.sh can run the bash script with bash /coinrealinfo.sh ATOMUSDT_PERP only need coin name to get info like ATOMUSDT_PERP use the info to adapt and learn to calculate accurate calculations fot profit and other metrics and factors learn and adapt acording all this is for all open position and almost like a summary
# if coinrealinfo.sh pnl not available calculate with entryprice in coinrealinfo.sh should get accurate pnl then
# use only coinrealinfo.sh entryprice for total pnl and profit calculate all other learning and adapt and all other profit methods and all other calculations according to making profit including everything else
# display wins and losses in html dashboard and calculate pnl profit according to being in the positive total pnl must be average entryprice of positions entryprice calculated with prices adapt
# get avg entryprice from and entryprice for positions from coinrealinfo.sh to show real pnl and accurrate reading for profit pnl calculate according adapt and learn
# when bot opens real position positions then use coinrealinfo script do not change other logic adapt and learn
# if real open position or positions coinrealinfo.sh output of real values if not output will show NO INFO to make more simpler do not change dashboard html only use in calculations and to learn and adapt
# coinrealinfo.sh It only handles one position increment of quantity is the multiple positions adapt and learn accordingly
# learn when to open and close new position or positions at wright price for improved and for gaining profit can open multiple quantity one quantity at a time if profit can be gained with higher pnl
# improve pnl learning for more prove pnl indicates profit to be made
# learn to increase real pnl by adapting and learning
# calculate position or positions pnl according to coinrealinfo try to place order to increase pnl at the right price learn and adapt to positions pnl according to real total pnl
