/******************************************************************************************
 * âš¡ Phemex Ultra-Low Value Multi-Coin Bot â€” DRY-RUN / LIVE with precise PnL/ROI
 ******************************************************************************************/

require('dotenv').config();
const ccxt = require('ccxt');
const express = require('express');
const http = require('http');
const { Server } = require('socket.io');

const CONFIG = {
    PORT: 3000,
    PRICE_RATE: 2000,
    LOOKBACK: 50,
    ROI_THRESHOLD: 0.2,
    TARGET_USDT_VALUE: 0.05,  // increased slightly for ultra-low coins
    LEVERAGE: 20,
    TOUCH_TOL: 1, // 1% tolerance
    DRY_RUN: process.env.DRY_RUN === 'true'
};

const exchange = new ccxt.phemex({
    apiKey: process.env.PHEMEX_KEY,
    secret: process.env.PHEMEX_SECRET,
    enableRateLimit: true,
    options: { defaultType: 'swap' }
});

const sleep = ms => new Promise(r => setTimeout(r, ms));
const states = [];
let activeCoins = new Set();

// -------------------- Helpers --------------------
function resolvePrice(ticker){ 
    return ticker.bid && ticker.ask ? (ticker.bid + ticker.ask)/2 : ticker.mark || ticker.last || 0; 
}

function isTouch(price, level){ 
    return Math.abs(price - level)/level * 100 <= CONFIG.TOUCH_TOL; 
}

function calcROI(upnl_usdt, pos){ 
    if(!pos.side || pos.qty === 0) return 0;
    return (upnl_usdt / (pos.entry * pos.qty) * 100); 
}

function initState(market){
    return { 
        market, 
        history: [], 
        support: 0, 
        resistance: 0, 
        position: {side: null, qty: 0, entry: 0}, 
        realizedPnL: 0, 
        status: 'INIT',
        scaledTouch: false
    };
}

// -------------------- Load Eligible Markets --------------------
async function loadEligibleMarkets(){
    await exchange.loadMarkets();
    const all = Object.values(exchange.markets).filter(m => m.swap && m.quote === 'USDT' && m.active);
    const eligible = [];

    for(const m of all){
        try{
            const ticker = await exchange.fetchTicker(m.symbol);
            const price = resolvePrice(ticker);
            if(price <= 0) continue;
            const minQty = m.limits?.amount?.min || 1;
            const valuePerCoin = price * CONFIG.LEVERAGE;

            if(valuePerCoin <= CONFIG.TARGET_USDT_VALUE){
                eligible.push({symbol: m.symbol, minQty, price, valuePerCoin});
            }
        } catch(e){ console.error(`Skip ${m.symbol}: ${e.message}`);}
        await sleep(50);
    }
    return eligible;
}

// -------------------- Place Order --------------------
async function placeOrder(symbol, side, qty){
    if(CONFIG.DRY_RUN){ 
        console.log(`[DRY-RUN] ${symbol} ${side} ${qty.toFixed(12)}`); 
        return {simulated:true, symbol, side, qty}; 
    }
    try{ 
        const order = await exchange.createOrder(symbol,'market',side,qty); 
        console.log(`Order placed: ${symbol} ${side} ${qty} â†’ ${order.id || 'ok'}`);
        return order;
    } catch(e){ 
        console.error(`Order error ${symbol} ${side} ${qty}: ${e.message}`); 
        return null; 
    }
}

// -------------------- Strategy --------------------
async function strategy(state, io){
    try{
        const ticker = await exchange.fetchTicker(state.market.symbol);
        const price = resolvePrice(ticker);
        const markPrice = ticker.mark || price;

        state.history.push(price);
        if(state.history.length > 300) state.history.shift();
        const w = state.history.slice(-CONFIG.LOOKBACK);
        state.support = Math.min(...w);
        state.resistance = Math.max(...w);

        const pos = state.position;
        const atSupport = isTouch(price, state.support);
        const atResistance = isTouch(price, state.resistance);
        const atLevel = atSupport || atResistance;

        // ---------------- Calculate quantity ----------------
        let qty = CONFIG.TARGET_USDT_VALUE / (price * CONFIG.LEVERAGE);
        if(qty < state.market.minQty) {
            qty = state.market.minQty;
        }

        // ---------------- OPEN ----------------
        if(!pos.side && atLevel){
            if(atResistance){ 
                const o = await placeOrder(state.market.symbol, 'buy', qty); 
                if(o){ pos.side='LONG'; pos.qty=qty; pos.entry=price; state.status='OPEN LONG'; state.scaledTouch=false; } 
            } else if(atSupport){ 
                const o = await placeOrder(state.market.symbol, 'sell', qty); 
                if(o){ pos.side='SHORT'; pos.qty=qty; pos.entry=price; state.status='OPEN SHORT'; state.scaledTouch=false; } 
            }
        }

        // ---------------- SCALE ONCE ----------------
        if(pos.side && atLevel && !state.scaledTouch){
            const o = await placeOrder(state.market.symbol, pos.side==='LONG'?'buy':'sell', qty);
            if(o){ 
                pos.qty += qty; 
                state.status='SCALING'; 
                state.scaledTouch = true; 
            }
        }

        // ---------------- CLOSE ----------------
        const upnl_usdt = pos.side==='LONG' ? (markPrice - pos.entry) * pos.qty : pos.side==='SHORT' ? (pos.entry - markPrice) * pos.qty : 0;
        if(pos.side && atLevel && calcROI(upnl_usdt,pos) >= CONFIG.ROI_THRESHOLD){
            const o = await placeOrder(state.market.symbol, pos.side==='LONG'?'sell':'buy', pos.qty);
            if(o){
                state.realizedPnL += upnl_usdt;
                state.position = {side: null, qty: 0, entry: 0};
                state.status='CLOSED';
                state.scaledTouch = false;
            }
        }

        io.emit('stats',{
            symbol: state.market.symbol,
            price,
            side: pos.side||'NONE',
            qty: pos.qty,
            entry: pos.entry,
            roi: calcROI(upnl_usdt,pos).toFixed(4),
            valuePerCoin: price,
            unrealizedPnL: upnl_usdt.toExponential(6),
            realizedPnL: state.realizedPnL.toExponential(6),
            status: state.status,
            history: state.history.slice(-CONFIG.LOOKBACK)
        });

    } catch(e){ console.error(`Strategy error ${state.market.symbol}: ${e.message}`);}
}

// -------------------- Run Bot --------------------
async function run(io){
    while(true){
        const eligibleMarkets = await loadEligibleMarkets();

        for(const m of eligibleMarkets){
            let state = states.find(s => s.market.symbol === m.symbol);

            if(!state){
                state = initState(m);
                states.push(state);
                activeCoins.add(m.symbol);

                io.emit('coins', Array.from(activeCoins));

                io.emit('stats',{
                    symbol: m.symbol, price:0, side:'NONE', qty:0, entry:0,
                    roi:0, valuePerCoin:0, unrealizedPnL:0, realizedPnL:0, status:'INIT', history:[]
                });

                console.log(`ðŸš€ New eligible coin detected: ${m.symbol} | price=${m.price.toFixed(12)}`);
            } else {
                state.market.price = m.price;
                state.market.minQty = m.minQty;
            }
        }

        for(const s of states) await strategy(s, io);

        await sleep(CONFIG.PRICE_RATE);
    }
}

// -------------------- Server --------------------
const app = express();
const server = http.createServer(app);
const io = new Server(server);

io.on('connection', socket => {
    socket.emit('coins', Array.from(activeCoins));
});

app.get('/',(_,res)=>res.send(DASHBOARD_HTML));

server.listen(CONFIG.PORT,()=>{
    console.log(`Dashboard â†’ http://localhost:${CONFIG.PORT} | DRY-RUN=${CONFIG.DRY_RUN}`);
    run(io);
});

// -------------------- Dashboard --------------------
const DASHBOARD_HTML = `
<!DOCTYPE html>
<html>
<head>
<title>Phemex Ultra-Low Value Bot</title>
<script src="https://cdn.jsdelivr.net/npm/socket.io-client@4/dist/socket.io.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
body{background:#0b0e11;color:#eaeaea;font-family:sans-serif;padding:20px}
#grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(260px,1fr));gap:14px}
.card{background:#181a20;border-radius:8px;padding:12px;margin-bottom:6px;border:2px solid transparent;transition:border 0.3s;}
.symbol{font-weight:bold;margin-bottom:4px}
.row{display:flex;justify-content:space-between;font-size:13px;margin:2px 0}
.long{color:#0ecb81}.short{color:#f6465d}.none{color:#888}
.status{text-align:center;margin-top:6px;background:#2b3139;padding:4px;border-radius:4px}
canvas{width:100%;height:60px;margin-top:4px;background:#0b0e11;border-radius:4px}
</style>
</head>
<body>
<h2>âš¡ Phemex Ultra-Low Value Futures Bot â€” ${CONFIG.DRY_RUN?'DRY-RUN':'LIVE'}</h2>
<div id="grid"></div>
<script>
const socket = io();
const grid = document.getElementById('grid');
const cards = {};

function card(symbol){
  const d = document.createElement('div');
  d.className='card';
  d.innerHTML=\`
    <div class="symbol">\${symbol}</div>
    <div class="row"><span>Price</span><span class="p">0</span></div>
    <div class="row"><span>Value/1 Coin</span><span class="v">0</span></div>
    <div class="row"><span>Pos</span><span class="pos">NONE</span></div>
    <div class="row"><span>Qty</span><span class="q">0</span></div>
    <div class="row"><span>ROI%</span><span class="r">0</span></div>
    <div class="row"><span>UPnL</span><span class="u">0</span></div>
    <div class="row"><span>RPnL</span><span class="rp">0</span></div>
    <canvas id="chart-\${symbol.replace('/','')}"></canvas>
    <div class="status s">INIT</div>\`;
  grid.appendChild(d);
  return {element:d, chart:null, data:[]};
}

socket.on('coins', coinList=>{
  coinList.forEach(symbol=>{
    if(!cards[symbol]) cards[symbol]=card(symbol);
  });
});

socket.on('stats', d=>{
  if(!cards[d.symbol]) cards[d.symbol]=card(d.symbol);
  const c = cards[d.symbol];

  c.element.querySelector('.p').innerText = d.price?.toFixed(12);
  c.element.querySelector('.v').innerText = d.valuePerCoin?.toFixed(12);
  const pe = c.element.querySelector('.pos');
  pe.innerText = d.side;
  pe.className = d.side==='LONG'?'long':d.side==='SHORT'?'short':'none';
  c.element.querySelector('.q').innerText = d.qty?.toFixed(12);
  c.element.querySelector('.r').innerText = d.roi;
  c.element.querySelector('.u').innerText = d.unrealizedPnL;
  c.element.querySelector('.rp').innerText = d.realizedPnL;
  c.element.querySelector('.s').innerText = d.status;

  let highlightColor = '';
  if(d.status.includes('OPEN LONG')) highlightColor = '#0ecb81';
  else if(d.status.includes('OPEN SHORT')) highlightColor = '#f6465d';
  else if(d.status.includes('SCALING')) highlightColor = '#fcd535';
  else if(d.status.includes('CLOSED')) highlightColor = '#3399ff';

  if(highlightColor){
    c.element.style.border = \`2px solid \${highlightColor}\`;
    setTimeout(()=>{ c.element.style.border='2px solid transparent'; }, 1000);
  }

  if(!c.chart){
    const ctx = document.getElementById('chart-'+d.symbol.replace('/','')).getContext('2d');
    c.chart = new Chart(ctx,{
      type:'line',
      data:{labels:[], datasets:[{label:'Price', data:[], borderColor:'#fcd535', pointRadius:0}]},
      options:{animation:false,responsive:true,scales:{y:{position:'right',grid:{color:'#2b3139'}}}}
    });
  }
  const hist = d.history||[];
  c.chart.data.labels = hist.map((_,i)=>i);
  c.chart.data.datasets[0].data = hist;
  c.chart.update('none');
});
</script>
</body>
</html>
`;
