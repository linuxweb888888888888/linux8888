/******************************************************************************************
 * ⚡ Phemex Ultra-Low Value Multi-Coin Bot — FINAL FIXED VERSION
 ******************************************************************************************/

require('dotenv').config();
const ccxt = require('ccxt');
const express = require('express');
const http = require('http');
const { Server } = require('socket.io');

/* ===================== CONFIG ===================== */
const CONFIG = {
    PORT: 3000,
    PRICE_RATE: 2000,
    LOOKBACK: 50,
    ROI_THRESHOLD: 0.2,          // close anytime >= 0.2%
    TARGET_USDT_VALUE: 0.05,     // margin target
    LEVERAGE: 20,
    TOUCH_TOL: 1,                // % distance from S/R
    DRY_RUN: process.env.DRY_RUN === 'true'
};

/* ===================== EXCHANGE ===================== */
const exchange = new ccxt.phemex({
    apiKey: process.env.PHEMEX_KEY,
    secret: process.env.PHEMEX_SECRET,
    enableRateLimit: true,
    options: { defaultType: 'swap' }
});

/* ===================== STATE ===================== */
const sleep = ms => new Promise(r => setTimeout(r, ms));
const states = [];
const activeCoins = new Set();

/* ===================== HELPERS ===================== */
function resolvePrice(t){
    return t.bid && t.ask ? (t.bid + t.ask) / 2 : t.mark || t.last || 0;
}

function isTouch(price, level){
    if (!level) return false;
    return Math.abs(price - level) / level * 100 <= CONFIG.TOUCH_TOL;
}

function calcROI(upnl, pos){
    if (!pos.side || pos.qty === 0) return 0;
    const margin = (pos.entry * pos.qty) / CONFIG.LEVERAGE;
    return (upnl / margin) * 100;
}

function initState(m){
    return {
        market: m,
        history: [],
        support: 0,
        resistance: 0,
        position: { side:null, qty:0, entry:0 },
        realizedPnL: 0,
        status: 'INIT',
        scaled: false
    };
}

/* ===================== MARKETS ===================== */
async function loadEligibleMarkets(){
    await exchange.loadMarkets();
    const all = Object.values(exchange.markets)
        .filter(m => m.swap && m.quote === 'USDT' && m.active);

    const list = [];
    for (const m of all){
        try{
            const t = await exchange.fetchTicker(m.symbol);
            const price = resolvePrice(t);
            if (price <= 0) continue;

            const minQty = m.limits?.amount?.min || 1;
            list.push({ symbol:m.symbol, price, minQty });
        } catch {}
        await sleep(40);
    }
    return list;
}

/* ===================== ORDERS ===================== */
async function placeOrder(symbol, side, qty){
    if (CONFIG.DRY_RUN){
        console.log(`[DRY] ${symbol} ${side} ${qty}`);
        return true;
    }
    try{
        await exchange.createOrder(symbol, 'market', side, qty);
        return true;
    } catch(e){
        console.error(`Order error ${symbol}`, e.message);
        return false;
    }
}

/* ===================== STRATEGY ===================== */
async function strategy(state, io){
    try{
        const t = await exchange.fetchTicker(state.market.symbol);
        const price = resolvePrice(t);
        const mark = t.mark || price;

        state.history.push(price);
        if (state.history.length > 300) state.history.shift();

        const win = state.history.slice(-CONFIG.LOOKBACK);
        state.support = Math.min(...win);
        state.resistance = Math.max(...win);

        const pos = state.position;
        const atSupport = isTouch(price, state.support);
        const atResistance = isTouch(price, state.resistance);
        const atLevel = atSupport || atResistance;

        /* ---- CORRECT PHEMEX CONTRACT SIZE ---- */
        const notional = CONFIG.TARGET_USDT_VALUE * CONFIG.LEVERAGE;
        let qty = notional / price;
        if (qty < state.market.minQty) qty = state.market.minQty;

        /* -------- OPEN (CORRECT DIRECTION) -------- */
        if (!pos.side && atLevel){
            // LONG at support
            if (atSupport && await placeOrder(state.market.symbol,'buy',qty)){
                pos.side = 'LONG';
                pos.qty = qty;
                pos.entry = price;
                state.scaled = false;
                state.status = 'OPEN LONG';
            }
            // SHORT at resistance
            if (atResistance && await placeOrder(state.market.symbol,'sell',qty)){
                pos.side = 'SHORT';
                pos.qty = qty;
                pos.entry = price;
                state.scaled = false;
                state.status = 'OPEN SHORT';
            }
        }

        /* -------- SCALE ONCE -------- */
        if (pos.side && atLevel && !state.scaled){
            const side = pos.side === 'LONG' ? 'buy' : 'sell';
            if (await placeOrder(state.market.symbol, side, qty)){
                const newQty = pos.qty + qty;
                pos.entry = ((pos.entry * pos.qty) + (price * qty)) / newQty;
                pos.qty = newQty;
                state.scaled = true;
                state.status = 'SCALING';
            }
        }

        /* -------- PNL + ROI -------- */
        const upnl =
            pos.side === 'LONG'  ? (mark - pos.entry) * pos.qty :
            pos.side === 'SHORT' ? (pos.entry - mark) * pos.qty : 0;

        const roi = calcROI(upnl, pos);

        /* -------- CLOSE ANYTIME ROI >= 0.2% -------- */
        if (pos.side && roi >= CONFIG.ROI_THRESHOLD){
            const closeSide = pos.side === 'LONG' ? 'sell' : 'buy';
            if (await placeOrder(state.market.symbol, closeSide, pos.qty)){
                state.realizedPnL += upnl;
                state.position = { side:null, qty:0, entry:0 };
                state.scaled = false;
                state.status = 'CLOSED';
            }
        }

        io.emit('stats',{
            symbol: state.market.symbol,
            price,
            side: pos.side || 'NONE',
            qty: pos.qty,
            roi: roi.toFixed(6),
            unrealizedPnL: upnl.toFixed(6),
            realizedPnL: state.realizedPnL.toFixed(6),
            status: state.status,
            history: state.history.slice(-CONFIG.LOOKBACK)
        });

    } catch(e){
        console.error('Strategy error', e.message);
    }
}

/* ===================== RUN ===================== */
async function run(io){
    while (true){
        const mkts = await loadEligibleMarkets();
        for (const m of mkts){
            if (!states.find(s => s.market.symbol === m.symbol)){
                states.push(initState(m));
                activeCoins.add(m.symbol);
                io.emit('coins', Array.from(activeCoins));
                console.log('NEW COIN', m.symbol);
            }
        }
        for (const s of states) await strategy(s, io);
        await sleep(CONFIG.PRICE_RATE);
    }
}

/* ===================== SERVER ===================== */
const app = express();
const server = http.createServer(app);
const io = new Server(server);

app.get('/', (_,res)=>res.send(DASHBOARD_HTML));

server.listen(CONFIG.PORT, ()=>{
    console.log(`Dashboard → http://localhost:${CONFIG.PORT}`);
    run(io);
});

/* ===================== DASHBOARD ===================== */
const DASHBOARD_HTML = `
<!DOCTYPE html>
<html>
<head>
<title>Phemex Ultra-Low Bot</title>
<script src="https://cdn.jsdelivr.net/npm/socket.io-client@4/dist/socket.io.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
body{background:#0b0e11;color:#eaeaea;font-family:sans-serif;padding:20px}
#grid{display:grid;grid-template-columns:repeat(auto-fill,minmax(260px,1fr));gap:14px}
.card{background:#181a20;border-radius:8px;padding:12px;border:2px solid transparent}
.symbol{font-weight:bold}
.row{display:flex;justify-content:space-between;font-size:13px}
.long{color:#0ecb81}.short{color:#f6465d}.none{color:#888}
.status{text-align:center;background:#2b3139;margin-top:6px;padding:4px;border-radius:4px}
canvas{width:100%;height:60px;margin-top:6px}
</style>
</head>
<body>
<h2>⚡ Phemex Ultra-Low Futures Bot</h2>
<div id="grid"></div>
<script>
const socket = io();
const grid = document.getElementById('grid');
const cards = {};

function card(symbol){
  const d=document.createElement('div');
  d.className='card';
  d.innerHTML=\`
    <div class="symbol">\${symbol}</div>
    <div class="row"><span>Price</span><span class="p"></span></div>
    <div class="row"><span>Pos</span><span class="pos"></span></div>
    <div class="row"><span>Qty</span><span class="q"></span></div>
    <div class="row"><span>ROI%</span><span class="r"></span></div>
    <div class="row"><span>UPnL</span><span class="u"></span></div>
    <div class="row"><span>RPnL</span><span class="rp"></span></div>
    <canvas></canvas>
    <div class="status s"></div>\`;
  grid.appendChild(d);

  const ctx=d.querySelector('canvas').getContext('2d');
  const chart=new Chart(ctx,{
    type:'line',
    data:{labels:[],datasets:[{data:[],borderColor:'#fcd535',pointRadius:0}]},
    options:{animation:false,plugins:{legend:{display:false}}}
  });

  return {el:d,chart};
}

socket.on('coins',list=>{
  list.forEach(s=>{
    if(!cards[s]) cards[s]=card(s);
  });
});

socket.on('stats',d=>{
  if(!cards[d.symbol]) cards[d.symbol]=card(d.symbol);
  const c=cards[d.symbol];

  c.el.querySelector('.p').innerText=d.price?.toFixed(8);
  const pe=c.el.querySelector('.pos');
  pe.innerText=d.side;
  pe.className=d.side==='LONG'?'long':d.side==='SHORT'?'short':'none';
  c.el.querySelector('.q').innerText=d.qty?.toFixed(6);
  c.el.querySelector('.r').innerText=d.roi+'%';
  c.el.querySelector('.u').innerText=d.unrealizedPnL;
  c.el.querySelector('.rp').innerText=d.realizedPnL;
  c.el.querySelector('.s').innerText=d.status;

  c.chart.data.labels=d.history.map((_,i)=>i);
  c.chart.data.datasets[0].data=d.history;
  c.chart.update('none');
});
</script>
</body>
</html>
`;
