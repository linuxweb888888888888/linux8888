Ultra-High-Win-Rate Scalping / Martingale-Like Mean Reversion / Grid Trading

ccxt live real trading

complete production ready ai bot for hitbtc futures cross margin trading ready to run sklearn sdgressor

5 minute heikin ashi strategy trading bot long when green short when red simulation

real prices from ccxt bid and ask "https://api.hitbtc.com/api/3/public/ticker"

use real wallet usdt with "https://api.hitbtc.com/api/3/futures/balance" usdt and check for cross_margin_reserved

close all positions on start with "https://api.hitbtc.com/api/3/futures/position"

get real info entryprice and so on from "https://api.hitbtc.com/api/3/futures/account" check under positions value

only close order if pnl larger than fee for profit

use real wallet usdt with "https://api.hitbtc.com/api/3/futures/balance" usdt and check for cross_margin_reserved

show daily profit prediction

show system logs

Ultra-High-Win-Rate Scalping / Martingale-Like Mean Reversion / Grid Trading

ccxt

complete production ready ai bot for hitbtc futures cross margin trading ready to run sklearn sdgressor

only close order if pnl larger than fee for profit
python ccxt ai driven bot futures cros margin

use cross_margin_reserved
Ultra-High-Win-Rate Scalping / Martingale-Like Mean Reversion / Grid Trading

ccxt

complete production ready ai bot for hitbtc futures cross margin trading ready to run sklearn sdgressor

create also file apikey with theses lines first line api key -3Mn7DL8P20iTj7QPoOSgyATuDcF-87h

second line

api secret WzxCckLuICMXcjdRL-CbgcsbpGXHePcs

only close order if pnl larger than fee for profit
hitbtc python3 ccxt bot ATOM

get coin prices bid ask "https://api.hitbtc.com/api/3/public/ticker"

use cors proxy or proxy if not connecting to api

use futures cross margin rules for trading

get signal within 1 minute

calculate calculations in decimal places where neccasary

upgrade this bot to a fully AI-driven adaptive strategy

update to AI-Based Strategy according to adaptive position mangement

write data or info to html dashboard /var/www/html/dashboard.html check permsions and check that html wrote corectly

hitbtc ccxt python bot, make profit and with 0.001 atom  do not use api keys implement take profit and stop loss algo with steps do not use talib and show icons with signal and orders and make bot profitable and include long and short signal algo for order and Add logic to close position or reduce size here, update price fast, short long implement algo again and logic and Add logic to close fast buy for order and again fast price update while in position check oversold overbought all code fast and if trading indicates profit use close step with long and short algo and then close order and fast price code update do not use api key one direction buy or sell until all sell for profit then open other for balance and learn from wallet to maximize profit increase positions if can make profit gain learn from open positions create simulated open positions in background for faster profit gains while opening positions in usdt only one direction at a time orders can be place use bid ask and mid prices for prices increase positions with learning and adapt use pnl learning simulation background trades for gaining profit use sklearn for learning library also add multi sizing and multi positions take profit if profit or pnl covers fee close positions if profit gain can be made or predicted further add rich dashboard and show all metrics and most factors use coin minimum quantity for scaling and when increasing and decreasing positions do not open real positions in smaller than minimum coin quantity of 0.001 for atom learn and adapt make bot fully adaptive, multi-position, profit-maximizing learning bot and Error: sequence index must be integer, not 'slice' fix update dashboard with all metrics and info and show and fully multi-position, fully adaptive, and with simulated trades that improve ML learning in real time, including multi-step PnL evaluation and profit prediction fix Error: 'DataFrame' object has no attribute 'append' add full bot, profit-maximizing, adaptive HitBTC automatic multi-step position increase UserWarning: X does not have valid feature names, but RandomForestRegressor and fix eceptions errors and warnings simulate in background while real trading in foreground to predict and maximize profit use place for real trades i have my own api keys always give real bot code The behavior of DataFrame concatenation with empty or all-NA entries is deprecated local variable 'DIRECTION' referenced before assignment

####UPGRADE BOT WITH ALL FEATURES####

# Use coin minimum quantity for scaling and when increasing/decreasing positions
# Do not open real positions smaller than the minimum coin quantity of 0.001 for ATOM
# Continuously learn and adapt
# Generate trading signals faster
# Scale order positions for maximum profit
# Increase wallet gains according to predicted profit
# Achieve fast USDT wallet growth
# Place order quantity based on wallet usage; justify amounts and adapt dynamically
# Improve wallet learning for maximum profit

# Learn for stacked positions in one direction
# Improve open trade (opentrade) learning
# Use only a terminal rich dashboard

# Learn wallet amount according to profit and adapt
# Simulate background positions to improve learning and adapt to real PnL and profit
# Place orders faster with signal updates
# Write output to HTML dashboard at /var/www/html/dashboard.html using a static Material Design clean layout (no charts)
# Open trades based on wallet amount and calculate for maximum profit
# Add confidence and accuracy to predictions
# Check calculations to ensure order placement within 1 minute
# Calculate wallet threshold before placing orders; use only enough quantity to increase profit
# Calculate and learn profitable trades; adapt using background simulated trades
# Use wallet amount to calculate open trades and quantity with PnL prediction for maximum profit
# Never use Plotly

# Improve PnL learning and open trade performance
# Take profit when PnL covers fees or predicted profit can be made; close positions accordingly
# Material Design dashboard must be static, updated with information only
# Focus on ATOM only (no multi-symbol trading)
# Direction mapping: buy = long = uptrend, sell = short = downtrend
# Learn and adapt minimum open position (0.001 ATOM)
# Use bid and ask for mid and real prices; adapt and learn
# Fix issues:
  # Module 'sklearn' has no attribute 'SGDRegressor'
  # KeyErrors
  # Background simulations
  # Dashboard not writing HTML data
  # Blank dashboard.html in browser
  # Buy/sell loop not starting
  # Library errors/exceptions/warnings for numpy, pandas, sklearn
  # wallet change feature show increased or decreased profit or loss in percentage not cumulating or decumalating

  # bot not writing to html file
  # also fix warning and errors and exceptions if found
  # background simulation count not showing html dashboard
# Make script ready to run
# Always place real trades when profitable; never dry run
# Enable multi-sizing and multi-positions
# Increase learning to grow USDT wallet
# When wallet usage is full, check where positions can be closed and opened for maximum profit; adapt accordingly
# Continuously learn PnL
# add real pnl for each entryprice trade
# trade in smaller quantity but with more profitable predictions and profit
# fix profit hitory trend make readable
# make prediction human readable in dashboard
# show signal accuracy in dashboard for prediction
# close all real trades on start
# calculate real accurate pnl for calculations
# upgrade html dashboard make more advanced
# upgrade bot make more advanced
# quantity can only be in steps of 0.001 or minimum quantity of coin learn and adapt for increasing or decreasing positions
# entryprice when order place is current bid or ask price calculate learn and adapt calculate according to direction
# bid and ask should not be the same price ord mid price learn and adapt
# when opening trade use current bid or ask for entryprice according to direction learn and adapt
# display pnl in html dashboard in decimal stil use real prices and pnl and other real factors
# while opening orders make the prices stil update while opening trades or orders
#calculate learning and adaptiveness on the updated decimals and try to improve accuraccy and profit and wallet growth and pnl prediction stil use real prices and pnl and other real factors
# if direction sell calculate pnl with bid price if direction buy calculate pnl with ask price learning accordingly and adapt
# if open position direction sell entryprice should be ask price and if open position direction buy entryprice should be bid price calculate pnl according learn and adapt
# use only one entryprice for total pnl and profit calculate all other learning and adapt and all other profit methods and all other calculations according to making profit including everything else
# display wins and losses in html dashboard and calculate pnl profit according to being in the positive total pnl must be average entryprice of positions entryprice calculated with prices adapt
# get avg entryprice from and entryprice for positions to show real pnl and accurrate reading for profit pnl calculate according adapt and learn
# when bot opens real position positions then use coinrealinfo script do not change other logic adapt and learn
# if real open position or positions output of real values if not output will show NO INFO to make more simpler do not change dashboard html only use in calculations and to learn and adapt
# It only handles one position increment of quantity is the multiple positions adapt and learn accordingly
# learn when to open and close new position or positions at wright price for improved and for gaining profit can open multiple quantity one quantity at a time if profit can be gained with higher pnl
# improve pnl learning for more prove pnl indicates profit to be made
# learn to increase real pnl by adapting and learning
# calculate position or positions pnl according to coinrealinfo try to place order to increase pnl at the right price learn and adapt to positions pnl according to real total pnl

fix all calculations errors exceptions warning learning check check that bot places real order or orders within 1 minute

no simulation mimic or mock trading only live real trading

get real balance from "https://api.hitbtc.com/api/3/futures/balance" usdt and check for cross_margin_reserved

place real orders with "https://api.hitbtc.com/api/3/futures/order" parameters "symbol=ATOMBTC_PERP&type=market&side=$(buy or sell)&quantity=(quantity bot inserts)&margin_mode=cross"

close all positions on start with "https://api.hitbtc.com/api/3/futures/position"

get real info entryprice and so on from "https://api.hitbtc.com/api/3/futures/account" check under positions value

Profitable Futures Trading Bot â€” Detailed Bullet Points
1. Advanced Futures Market Intelligence

Real-time monitoring of perpetual futures order books, funding rates, open interest, and long/short ratio shifts.

Leverage-aware signal engine that adjusts entry strength based on volatility and market momentum.

Liquidation cluster detection to identify zones where sharp moves are likely.

Funding-fee optimization, entering positions when fee direction favors profit.

Trend tracking across multiple timeframes, using EMA clouds, VWAP deviation, RSI momentum, and volatility compression patterns.

2. High-Precision Execution & Leverage Management

Instant automated order execution using market, limit, or post-only orders depending on liquidity.

Dynamic leverage scaling that lowers leverage in high-volatility zones and increases it during stable trends.

Smart entry confirmation using volume spikes, order-book imbalance, and candle-close validation.

Multi-tier take-profit system to secure profit in phases without fully closing the position.

Auto-reduce or auto-hedge when the market flips direction or a reversal becomes statistically likely.

3. Risk Protection & Liquidation Prevention

Adaptive stop-loss engine that widens in trending markets and tightens in choppy conditions.

Liquidation price buffer monitoring to prevent trades from approaching unsafe levels.

Automatic partial close to reduce position size when risk becomes too high.

Daily loss limits, max drawdown protection, and exposure caps to maintain account safety.

Slippage and spread detection to avoid entering positions in unstable order books.

4. Strategy Adaptation & Market Response

Ranging/trending mode switching based on real-time volatility and breakout detection.

Scalping mode for fast, low-risk entries during sideways markets.

Momentum mode when strong directional force appears.

Reversal mode using exhaustion patterns, divergences, and volume drops.

Sensitivity tuning for ultra-responsive entries in fast-moving futures markets.

5. Performance Tracking & Automation

Live PnL tracking for both realized and unrealized profit on open futures positions.

Automatic trade logging including entry price, exit price, funding fees, and liquidation buffer.

HTML dashboard & metrics panel for real-time system monitoring.

Error detection and auto-recovery during API issues or exchange delays.

24/7 uptime with self-restart logic to ensure non-stop operation.

6. Security & API Safety

API key encryption with no withdrawal permissions enabled.

Secure server deployment with recommended IP whitelisting.

Rate-limit handling to avoid bans and ensure stable communication with exchanges

import requests
import time
from requests.auth import HTTPBasicAuth

# ------------------------
# API credentials
# ------------------------
API_KEY = "YOUR_API_KEY"
API_SECRET = "YOUR_API_SECRET"
AUTH = HTTPBasicAuth(API_KEY, API_SECRET)

BASE_URL = "https://api.hitbtc.com/api/3"
SYMBOL = "ATOMUSDT_PERP"
MARGIN_MODE = "cross"
TIMEFRAME = 300  # 5 minutes

# ------------------------
# Helpers
# ------------------------
def safe_json(resp):
    try:
        return resp.json()
    except ValueError:
        return resp.text

def safe_float(value, default=0.0):
    try:
        return float(value) if value not in (None, "", "null") else default
    except:
        return default

# ------------------------
# API Calls
# ------------------------
def get_ticker(symbol):
    url = f"{BASE_URL}/public/ticker/{symbol}"
    resp = requests.get(url)
    return safe_json(resp)

def get_balance():
    url = f"{BASE_URL}/futures/balance"
    resp = requests.get(url, auth=AUTH)
    return safe_json(resp)

def close_all_positions():
    url = f"{BASE_URL}/futures/position"
    resp = requests.delete(url, auth=AUTH)
    return safe_json(resp)

def place_order(side, quantity):
    url = f"{BASE_URL}/futures/order"
    data = {
        "symbol": SYMBOL,
        "type": "market",
        "side": side,
        "quantity": quantity,
        "margin_mode": MARGIN_MODE
    }
    resp = requests.post(url, auth=AUTH, json=data)
    return safe_json(resp)

# ------------------------
# Open positions
# ------------------------
def get_open_position():
    url = f"{BASE_URL}/futures/account"
    resp = requests.get(url, auth=AUTH)
    account_info = safe_json(resp)

    if not account_info or not isinstance(account_info, list):
        print("Warning: account_info invalid:", account_info)
        return None

    try:
        positions = account_info[0].get("positions") or []
        for pos in positions:
            quantity = safe_float(pos.get("quantity"))
            if pos.get("symbol") == SYMBOL and quantity > 0:
                pos["quantity"] = quantity
                pos["price_entry"] = safe_float(pos.get("price_entry"))
                pos["price_margin_call"] = safe_float(pos.get("price_margin_call"))
                pos["price_liquidation"] = safe_float(pos.get("price_liquidation"))
                pos["pnl"] = safe_float(pos.get("pnl"))
                return pos
        return None
    except Exception as e:
        print("Error parsing positions:", e)
        return None

# ------------------------
# Usable balance from cross_margin_reserved only
# ------------------------
def get_usable_balance():
    """
    Returns usable USDT for cross-margin trading using ONLY cross_margin_reserved
    """
    balance_info = get_balance()
    if not balance_info or not isinstance(balance_info, list):
        print("Balance info invalid:", balance_info)
        return 0

    for entry in balance_info:
        currency = entry.get("currency")
        if currency == "USDT":
            cross_reserved = safe_float(entry.get("cross_margin_reserved"))
            print(f"Currency: {currency}, Usable cross-margin: {cross_reserved}")
            return cross_reserved

    print("No USDT entry found in balance")
    return 0

# ------------------------
# Heikin-Ashi
# ------------------------
def heikin_ashi(prev_candle, current_candle):
    ha_close = (current_candle['open'] + current_candle['high'] +
                current_candle['low'] + current_candle['close']) / 4
    ha_open = (prev_candle['open'] + prev_candle['close']) / 2
    ha_high = max(current_candle['high'], ha_open, ha_close)
    ha_low = min(current_candle['low'], ha_open, ha_close)
    return {"open": ha_open, "high": ha_high, "low": ha_low, "close": ha_close}

# ------------------------
# Main bot loop with debug
# ------------------------
def run_bot():
    print("Closing all positions on start...")
    close_result = close_all_positions()
    print("Close all positions result:", close_result)

    prev_candle = {"open": 0, "high": 0, "low": 0, "close": 0}
    print("Starting 5-minute Heikin-Ashi futures bot...")

    while True:
        ticker = get_ticker(SYMBOL)
        if isinstance(ticker, dict):
            bid = safe_float(ticker.get("bid"))
            ask = safe_float(ticker.get("ask"))
            current_price = (bid + ask) / 2
        else:
            print("Invalid ticker:", ticker)
            time.sleep(TIMEFRAME)
            continue

        current_candle = {
            "open": current_price,
            "high": current_price,
            "low": current_price,
            "close": current_price
        }

        ha_candle = heikin_ashi(prev_candle, current_candle)

        # Debug Heikin-Ashi candle
        print(f"\nHA Candle: Open={ha_candle['open']:.4f}, Close={ha_candle['close']:.4f}, High={ha_candle['high']:.4f}, Low={ha_candle['low']:.4f}")

        # Check open positions
        open_position = get_open_position()
        if open_position:
            print(f"Existing position: {open_position['quantity']} @ {open_position['price_entry']}, PnL: {open_position['pnl']}")
            print("Skipping new order: already have an open position.")
        else:
            # Determine action
            action = None
            if ha_candle["close"] > ha_candle["open"]:
                action = "buy"
            elif ha_candle["close"] < ha_candle["open"]:
                action = "sell"

            if action:
                usable_usdt = get_usable_balance()
                print(f"Usable cross-margin USDT: {usable_usdt}")

                if usable_usdt > 0:
                    quantity = usable_usdt / current_price
                    print(f"Placing {action} order with quantity: {quantity:.6f} at price ~{current_price:.4f}")
                    order = place_order(action, quantity)
                    print(f"Order response: {order}")
                else:
                    print("Skipping order: No usable cross-margin USDT available.")
            else:
                print("Skipping order: No clear HA signal (close == open).")

        prev_candle = ha_candle
        time.sleep(TIMEFRAME)

if __name__ == "__main__":
    run_bot()
