/******************************************************************************************
 * ‚ö° LIVE ADAUSDT BOT ‚Äî PHEMEX PERPETUAL SWAP (CCXT)
 * - Breakout entries over dynamic support/resistance
 * - Close trades based on frozen S/R at entry
 * - Dashboard + Chart.js with persistent S/R lines
 * - Fix: support/resistance zero bug, trades open/close correctly
 ******************************************************************************************/

require('dotenv').config();
const express = require('express');
const http = require('http');
const { Server } = require('socket.io');
const ccxt = require('ccxt');

// ============================ CONFIG ============================
const CONFIG = {
    PRICE_SYMBOL: 'ADA/USDT',
    ORDER_SYMBOL: 'ADA/USDT:USDT',
    TRADE_QTY: 0.01,
    PRICE_RATE: 2000,
    LOOKBACK_PERIOD: 50,
    MIN_OFFSET: 0.00002,
};

// ============================ STATE ============================
const state = {
    positions: { qty: 0, entry: 0, side: null, openSupport: 0, openResistance: 0 },
    history: [],
    resistance: 0,
    support: 0,
    status: 'INIT',
    orderLock: false,
    realizedPnL: 0,
    tradeCount: 0,
    price: 0,
    bid: 0,
    ask: 0,
    recentOrders: [],
};

// ============================ CCXT ============================
const exchange = new ccxt.phemex({
    apiKey: process.env.PHEMEX_KEY,
    secret: process.env.PHEMEX_SECRET,
    enableRateLimit: true,
    options: { defaultType: 'swap' }
});

// ============================ FETCH PRICE ============================
async function fetchPrice() {
    try {
        const t = await exchange.fetchTicker(CONFIG.PRICE_SYMBOL);
        if (!t || t.bid == null || t.ask == null) return false;
        state.bid = t.bid;
        state.ask = t.ask;
        state.price = (t.bid + t.ask) / 2;
        return true;
    } catch (e) {
        console.error('PRICE ERROR:', e.message);
        return false;
    }
}

// ============================ SYNC POSITIONS ============================
async function syncPositions(io) {
    try {
        let positions = [];
        try { positions = await exchange.fetchPositions([CONFIG.ORDER_SYMBOL]); }
        catch { positions = await exchange.fetchPositions(); }

        io.emit('log', `RAW POSITIONS: ${JSON.stringify(positions, null, 2)}`);
        const pos = positions.find(p => p.symbol === CONFIG.ORDER_SYMBOL) || {};

        let side = null;
        let qty = Number(pos.contracts || 0);
        let entry = Number(pos.entryPrice || 0);

        if (pos.side) {
            const s = pos.side.toLowerCase();
            if (s === 'buy' || s === 'long') side = 'LONG';
            else if (s === 'sell' || s === 'short') side = 'SHORT';
        }

        if (!side || qty <= 0) {
            side = null;
            qty = 0;
            entry = 0;
            state.positions.openSupport = 0;
            state.positions.openResistance = 0;
        }

        state.positions.side = side;
        state.positions.qty = qty;
        state.positions.entry = entry;

        let orders = [];
        try { orders = await exchange.fetchOpenOrders(CONFIG.ORDER_SYMBOL); } 
        catch(e){ io.emit('log', `OPEN ORDERS ERROR: ${e.message}`); orders = []; }

        state.recentOrders = orders.map(o => ({
            id: o.id,
            side: o.side,
            qty: o.amount,
            price: o.price
        }));

        io.emit('log', `[SYNC] pos=${state.positions.side || 'NONE'} qty=${state.positions.qty}`);
    } catch (e) {
        io.emit('log', `SYNC ERROR: ${e.message}`);
    }
}

// ============================ PLACE ORDER ============================
async function placeOrder(side, qty, io) {
    if (state.orderLock) {
        io.emit('log', '‚õî ORDER BLOCKED (orderLock=true)');
        return null;
    }
    state.orderLock = true;
    try {
        io.emit('log', `[ORDER] ${side.toUpperCase()} ${qty}`);
        const o = await exchange.createOrder(CONFIG.ORDER_SYMBOL, 'market', side, qty);
        io.emit('log', `[ORDER SENT] id=${o.id}`);
        await new Promise(r => setTimeout(r, 500));
        await syncPositions(io);
        return o;
    } catch (e) {
        io.emit('log', `‚ùå ORDER ERROR: ${e.message}`);
        return null;
    } finally {
        state.orderLock = false;
    }
}

// ============================ CLOSE POSITION ============================
async function closePosition(io) {
    const pos = state.positions;
    if (!pos.side || pos.qty <= 0) return;
    const side = pos.side === 'LONG' ? 'sell' : 'buy';
    const qty = pos.qty;

    if (pos.side === 'LONG') state.realizedPnL += (state.price - pos.entry) * qty;
    else if (pos.side === 'SHORT') state.realizedPnL += (pos.entry - state.price) * qty;

    io.emit('log', `[EXIT] Closing ${pos.side} qty=${qty}`);
    await placeOrder(side, qty, io);
    state.positions = { qty: 0, entry: 0, side: null, openSupport: 0, openResistance: 0 };
}

// ============================ STRATEGY ============================
async function strategy(io) {
    const ok = await fetchPrice();
    if (!ok) { io.emit('log', '‚ö†Ô∏è PRICE FETCH FAILED'); return; }

    await syncPositions(io);
    const price = state.price;

    // Maintain history
    state.history.push(price);
    if (state.history.length > 300) state.history.shift();

    // Dynamic S/R (entry only)
    const window = state.history.slice(-CONFIG.LOOKBACK_PERIOD);
    const dynamicResistance = window.length ? Math.max(...window) : state.price;
    const dynamicSupport = window.length ? Math.min(...window) : state.price;

    const pos = state.positions;

    // ================== EXIT LOGIC (frozen S/R) ==================
    if (pos.side === 'LONG' && price < pos.openSupport) {
        io.emit('log', `üõë LONG EXIT | ${price.toFixed(4)} < ${pos.openSupport.toFixed(4)}`);
        await closePosition(io);
        state.status = 'CLOSED LONG';
    } else if (pos.side === 'SHORT' && price > pos.openResistance) {
        io.emit('log', `üõë SHORT EXIT | ${price.toFixed(4)} > ${pos.openResistance.toFixed(4)}`);
        await closePosition(io);
        state.status = 'CLOSED SHORT';
    }
    // ================== ENTRY LOGIC ==================
    else if (!pos.side) {
        if (price > dynamicResistance) {
            io.emit('log', `üìà BREAKOUT | ${price.toFixed(4)} > ${dynamicResistance.toFixed(4)}`);
            await placeOrder('buy', CONFIG.TRADE_QTY, io);
            state.positions.openSupport = dynamicSupport || price;
            state.positions.openResistance = dynamicResistance || price;
            if (state.positions.openResistance - state.positions.openSupport < CONFIG.MIN_OFFSET) {
                state.positions.openResistance += CONFIG.MIN_OFFSET/2;
                state.positions.openSupport -= CONFIG.MIN_OFFSET/2;
            }
            state.status = 'OPEN LONG';
        } else if (price < dynamicSupport) {
            io.emit('log', `üìâ BREAKDOWN | ${price.toFixed(4)} < ${dynamicSupport.toFixed(4)}`);
            await placeOrder('sell', CONFIG.TRADE_QTY, io);
            state.positions.openSupport = dynamicSupport || price;
            state.positions.openResistance = dynamicResistance || price;
            if (state.positions.openResistance - state.positions.openSupport < CONFIG.MIN_OFFSET) {
                state.positions.openResistance += CONFIG.MIN_OFFSET/2;
                state.positions.openSupport -= CONFIG.MIN_OFFSET/2;
            }
            state.status = 'OPEN SHORT';
        } else {
            io.emit('log', `‚è∏ NO ENTRY | range ${dynamicSupport.toFixed(4)}‚Äì${dynamicResistance.toFixed(4)}`);
            state.status = 'RANGING';
        }
    }

    // Update dynamic S/R for dashboard
    state.support = dynamicSupport;
    state.resistance = dynamicResistance;

    // Ensure frozen S/R is never zero
    if (!state.positions.openSupport) state.positions.openSupport = dynamicSupport || price;
    if (!state.positions.openResistance) state.positions.openResistance = dynamicResistance || price;

    emitStats(io);
}

// ============================ EMIT STATS ============================
function emitStats(io) {
    const pos = state.positions;
    let unrealizedPnL = 0;
    if (pos.side === 'LONG') unrealizedPnL = (state.price - pos.entry) * pos.qty;
    else if (pos.side === 'SHORT') unrealizedPnL = (pos.entry - state.price) * pos.qty;

    io.emit('stats', {
        price: state.price,
        bid: state.bid,
        ask: state.ask,
        resistance: state.resistance || state.price,
        support: state.support || state.price,
        posType: pos.side || 'NONE',
        qty: pos.qty,
        status: state.status,
        realizedPnL: state.realizedPnL,
        unrealizedPnL,
        recentOrders: state.recentOrders,
        entryResistance: state.positions.openResistance || state.resistance || state.price,
        entrySupport: state.positions.openSupport || state.support || state.price
    });
}

// ============================ BOT LOOP ============================
async function runBot(io) {
    while (true) {
        try { await strategy(io); }
        catch (e) { io.emit('log', `BOT LOOP ERROR: ${e.message}`); }
        await new Promise(r => setTimeout(r, CONFIG.PRICE_RATE));
    }
}

// ============================ SERVER ============================
const app = express();
const server = http.createServer(app);
const io = new Server(server);

app.get('/', (_, res) => res.send(DASHBOARD_HTML));

server.listen(3000, () => {
    console.log('üö® BOT STARTED ‚Äî ADA/USDT PHEMEX PERP üö®');
    runBot(io);
});

// ============================ DASHBOARD ============================
const DASHBOARD_HTML = `
<html>
<head>
<title>ADAUSDT Phemex Swap Bot</title>
<script src="https://cdn.jsdelivr.net/npm/socket.io-client@4/dist/socket.io.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
body{background:#0b0e11;color:#eaeaea;font-family:sans-serif;padding:20px}
.header{display:grid;grid-template-columns:repeat(8,1fr);gap:10px;background:#181a20;padding:15px;border-radius:8px;}
.stat{text-align:center;background:#2b3139;padding:10px;border-radius:5px}
.label{font-size:11px;color:#848e9c}
.val{font-size:15px;font-weight:bold;font-family:monospace}
.pos-LONG{color:#0ecb81} .pos-SHORT{color:#f6465d}
#chart-box{height:400px;background:#181a20;margin-top:15px}
#log-box{height:150px;overflow:auto;background:#000;margin-top:15px;font-family:monospace;font-size:12px}
</style>
</head>
<body>
<h2>‚ö° ADAUSDT PHEMEX PERPETUAL BOT</h2>
<div class="header">
<div class="stat"><div class="label">PRICE</div><div class="val" id="p">--</div></div>
<div class="stat"><div class="label">BID</div><div class="val" id="b">--</div></div>
<div class="stat"><div class="label">ASK</div><div class="val" id="a">--</div></div>
<div class="stat"><div class="label">POSITION</div><div class="val" id="pos">NONE</div></div>
<div class="stat"><div class="label">QTY</div><div class="val" id="q">0</div></div>
<div class="stat"><div class="label">STATUS</div><div class="val" id="s">--</div></div>
<div class="stat"><div class="label">UPNL</div><div class="val" id="u">0</div></div>
<div class="stat"><div class="label">RPNL</div><div class="val" id="r">0</div></div>
</div>
<div id="chart-box"><canvas id="c"></canvas></div>
<div id="log-box"></div>
<script>
const socket = io();
const logBox = document.getElementById('log-box');
const ctx = document.getElementById('c');
const MAX_POINTS = 300;
const chart = new Chart(ctx,{
    type:'line',
    data:{labels:[],datasets:[
        {label:'Price',data:[],borderColor:'#fcd535',pointRadius:0},
        {label:'Resistance',data:[],borderColor:'#f6465d',pointRadius:0,stepped:true},
        {label:'Support',data:[],borderColor:'#0ecb81',pointRadius:0,stepped:true},
        {label:'Entry Resistance',data:[],borderColor:'rgba(246,70,93,0.5)',borderDash:[2,2],borderWidth:1.5,pointRadius:0,stepped:true},
        {label:'Entry Support',data:[],borderColor:'rgba(14,203,129,0.5)',borderDash:[2,2],borderWidth:1.5,pointRadius:0,stepped:true}
    ]},
    options:{responsive:true,animation:false,scales:{y:{position:'right',grid:{color:'#2b3139'}}}}
});

socket.on('stats', d=>{
    p.innerText = d.price?.toFixed(4) ?? '--';
    b.innerText = d.bid?.toFixed(4) ?? '--';
    a.innerText = d.ask?.toFixed(4) ?? '--';
    pos.innerText = d.posType || 'NONE';
    pos.className = d.posType==='LONG'?'val pos-LONG':d.posType==='SHORT'?'val pos-SHORT':'val';
    q.innerText = d.qty ?? 0;
    s.innerText = d.status || '--';
    u.innerText = (d.unrealizedPnL ?? 0).toFixed(6);
    r.innerText = (d.realizedPnL ?? 0).toFixed(6);

    if(chart.data.labels.length >= MAX_POINTS){
        chart.data.labels.shift();
        chart.data.datasets.forEach(ds=>ds.data.shift());
    }

    chart.data.labels.push(new Date().toLocaleTimeString());
    chart.data.datasets[0].data.push(d.price ?? d.price);
    chart.data.datasets[1].data.push(d.resistance ?? d.price);
    chart.data.datasets[2].data.push(d.support ?? d.price);
    chart.data.datasets[3].data.push(d.entryResistance ?? d.price);
    chart.data.datasets[4].data.push(d.entrySupport ?? d.price);
    chart.update('none');
});

socket.on('log', m=>{
    const d = document.createElement('div');
    d.innerText = new Date().toLocaleTimeString()+' '+m;
    logBox.prepend(d);
    if(logBox.children.length>200) logBox.removeChild(logBox.lastChild);
});
</script>
</body>
</html>
`;
