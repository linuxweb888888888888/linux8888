/******************************************************************************************
 * ‚ö° LUNC PHEMEX BOT ‚Äî FULL DASHBOARD + SMART ROI ADAPTIVE SCALING
 * ‚úÖ Frontend independent
 * ‚úÖ 30s ticker interval
 * ‚úÖ Adaptive scale 1‚Äì10
 * ‚úÖ ROI-based far-away sensitivity
 * ‚úÖ Original dashboard preserved
 ******************************************************************************************/

require('dotenv').config();
const express = require('express');
const http = require('http');
const { Server } = require('socket.io');
const ccxt = require('ccxt');
const minimist = require('minimist');

// ==================== PARSE ARGS ====================
const args = minimist(process.argv.slice(2));
const COIN = (args.coin || 'LUNC').toUpperCase();
const PORT = args.port || 3000;
const LEVERAGE = args.leverage || 20;

// ==================== CONFIG ====================
const CONFIG = {
    PRICE_SYMBOL: `${COIN}/USDT`,
    ORDER_SYMBOL: `${COIN}/USDT:USDT`,
    LOOKBACK: 50,
    PRICE_RATE: 30000,          // 30 seconds
    ROI_MIN_TO_SCALE: 0.15,     // % minimum ROI before scaling
    ROI_CLOSE: 6.0,             // % close position
    MIN_SCALE: 1,
    MAX_SCALE: 10
};

// ==================== STATE ====================
const state = {
    price: 0,
    bid: 0,
    ask: 0,
    history: [],
    support: 0,
    resistance: 0,
    realizedPnL: 0,
    positions: { side: null, qty: 0, entry: 0 },
    status: 'INIT',
    recentOrders: [],
    lastScale: 0
};

// ==================== EXCHANGE ====================
const exchange = new ccxt.phemex({
    apiKey: process.env.PHEMEX_KEY,
    secret: process.env.PHEMEX_SECRET,
    enableRateLimit: true,
    options: { defaultType: 'swap' }
});

// ==================== HELPERS ====================
const sleep = ms => new Promise(r => setTimeout(r, ms));

function calcROI(pos, price) {
    if (!pos.side || pos.qty <= 0) return 0;
    const pnl = pos.side === 'LONG'
        ? (price - pos.entry) * pos.qty
        : (pos.entry - price) * pos.qty;
    const margin = (pos.entry * pos.qty) / LEVERAGE;
    return margin > 0 ? (pnl / margin) * 100 : 0;
}

// ROI-sensitive adaptive scaling (1‚Äì10)
function adaptiveScale(pos, price, roi) {
    const distance = Math.abs(price - pos.entry) / pos.entry;
    const roiBoost = Math.min(3, Math.max(1, Math.abs(roi) * 4));
    let scale = Math.round(distance * roiBoost * 10);
    scale = Math.min(CONFIG.MAX_SCALE, Math.max(CONFIG.MIN_SCALE, scale));
    return scale;
}

// ==================== PRICE ====================
async function fetchPrice() {
    const t = await exchange.fetchTicker(CONFIG.PRICE_SYMBOL);
    state.bid = t.bid;
    state.ask = t.ask;
    state.price = (t.bid + t.ask) / 2;
}

// ==================== POSITION SYNC ====================
async function syncPosition() {
    const positions = await exchange.fetchPositions([CONFIG.ORDER_SYMBOL]);
    const p = positions.find(x => x.symbol === CONFIG.ORDER_SYMBOL);

    if (!p || !p.contracts) {
        state.positions = { side: null, qty: 0, entry: 0 };
        return;
    }

    state.positions.qty = Math.abs(Number(p.contracts));
    state.positions.entry = Number(p.entryPrice);
    state.positions.side =
        p.side.toLowerCase().includes('long') ? 'LONG' : 'SHORT';
}

// ==================== ORDERS ====================
async function market(side, qty) {
    qty = Number(qty.toFixed(8));
    await exchange.createOrder(CONFIG.ORDER_SYMBOL, 'market', side, qty);

    state.recentOrders.unshift({
        side, qty, time: new Date().toLocaleTimeString()
    });
    if (state.recentOrders.length > 20) state.recentOrders.pop();

    await sleep(500);
    await syncPosition();
}

// ==================== STRATEGY ====================
async function strategy(io) {
    await fetchPrice();
    await syncPosition();

    state.history.push(state.price);
    if (state.history.length > 300) state.history.shift();

    const window = state.history.slice(-CONFIG.LOOKBACK);
    state.support = Math.min(...window);
    state.resistance = Math.max(...window);

    const pos = state.positions;
    const priceUsed = pos.side === 'LONG' ? state.bid : state.ask;
    const roi = calcROI(pos, priceUsed);

    // ===== CLOSE ON HIGH ROI =====
    if (pos.side && roi >= CONFIG.ROI_CLOSE) {
        io.emit('log', `üõë CLOSE ${pos.side} ROI=${roi.toFixed(4)}%`);
        await market(pos.side === 'LONG' ? 'sell' : 'buy', pos.qty);
        state.status = 'CLOSED';
        return;
    }

    // ===== SCALE =====
    if (pos.side && Math.abs(roi) >= CONFIG.ROI_MIN_TO_SCALE) {
        const scaleQty = adaptiveScale(pos, state.price, roi);
        state.lastScale = scaleQty;

        io.emit('log', `‚ûï SCALE ${pos.side} ${scaleQty} | ROI=${roi.toFixed(4)}%`);
        await market(pos.side === 'LONG' ? 'buy' : 'sell', scaleQty);
        state.status = 'SCALING';
    }

    // ===== OPEN =====
    if (!pos.side) {
        if (state.price >= state.resistance) {
            await market('buy', CONFIG.MIN_SCALE);
            state.status = 'OPEN LONG';
        } else if (state.price <= state.support) {
            await market('sell', CONFIG.MIN_SCALE);
            state.status = 'OPEN SHORT';
        } else {
            state.status = 'RANGING';
        }
    }

    io.emit('stats', {
        price: state.price,
        bid: state.bid,
        ask: state.ask,
        support: state.support,
        resistance: state.resistance,
        posType: pos.side || 'NONE',
        qty: pos.qty,
        entry: pos.entry,
        roi,
        unrealizedPnL: roi,
        realizedPnL: state.realizedPnL,
        status: state.status,
        recentOrders: state.recentOrders
    });
}

// ==================== BOT LOOP ====================
async function runBot(io) {
    console.log('ü§ñ Bot running (frontend independent)');
    while (true) {
        try { await strategy(io); }
        catch (e) {
            console.error(e.message);
            io.emit('log', e.message);
        }
        await sleep(CONFIG.PRICE_RATE);
    }
}

// ==================== SERVER ====================
const app = express();
const server = http.createServer(app);
const io = new Server(server);

app.get('/', (_, res) => res.send(DASHBOARD_HTML));
io.on('connection', () => console.log('üìä Frontend connected'));

server.listen(PORT, () => {
    console.log(`üåê Dashboard http://localhost:${PORT}`);
    runBot(io);
});

// ==================== ORIGINAL DASHBOARD ====================
const DASHBOARD_HTML = `
<!DOCTYPE html>
<html>
<head>
<title>${COIN} Phemex Bot</title>
<script src="https://cdn.jsdelivr.net/npm/socket.io-client@4/dist/socket.io.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
body{background:#0b0e11;color:#eaeaea;font-family:sans-serif;padding:20px}
.header{display:grid;grid-template-columns:repeat(10,1fr);gap:10px;background:#181a20;padding:15px;border-radius:8px;}
.stat{text-align:center;background:#2b3139;padding:10px;border-radius:5px}
.label{font-size:11px;color:#848e9c}
.val{font-size:15px;font-weight:bold;font-family:monospace}
.pos-LONG{color:#0ecb81} .pos-SHORT{color:#f6465d}
#chart-box{height:400px;background:#181a20;margin-top:15px}
#log-box{height:150px;overflow:auto;background:#000;margin-top:15px;font-family:monospace;font-size:12px}
</style>
</head>
<body>
<h2>‚ö° GENIUS BOT</h2>
<div class="header">
<div class="stat"><div class="label">PRICE</div><div class="val" id="p">--</div></div>
<div class="stat"><div class="label">BID</div><div class="val" id="b">--</div></div>
<div class="stat"><div class="label">ASK</div><div class="val" id="a">--</div></div>
<div class="stat"><div class="label">POSITION</div><div class="val" id="pos">NONE</div></div>
<div class="stat"><div class="label">QTY</div><div class="val" id="q">0</div></div>
<div class="stat"><div class="label">ENTRY</div><div class="val" id="e">0</div></div>
<div class="stat"><div class="label">ROI%</div><div class="val" id="roi">0</div></div>
<div class="stat"><div class="label">UPNL</div><div class="val" id="u">0</div></div>
<div class="stat"><div class="label">RPNL</div><div class="val" id="r">0</div></div>
<div class="stat"><div class="label">STATUS</div><div class="val" id="s">--</div></div>
</div>
<div id="chart-box"><canvas id="c"></canvas></div>
<div id="log-box"></div>
<script>
const socket = io();
const ctx = document.getElementById('c');
const logBox = document.getElementById('log-box');
const MAX_POINTS = 300;

const chart = new Chart(ctx,{
type:'line',
data:{labels:[],datasets:[
{label:'Price',data:[],borderColor:'#fcd535',pointRadius:0},
{label:'Resistance',data:[],borderColor:'#f6465d',pointRadius:0,stepped:true},
{label:'Support',data:[],borderColor:'#0ecb81',pointRadius:0,stepped:true}
]},
options:{responsive:true,animation:false,scales:{y:{position:'right'}}}
});

socket.on('stats',d=>{
p.innerText=d.price?.toFixed(8);
b.innerText=d.bid?.toFixed(8);
a.innerText=d.ask?.toFixed(8);
pos.innerText=d.posType;
pos.className=d.posType==='LONG'?'val pos-LONG':d.posType==='SHORT'?'val pos-SHORT':'val';
q.innerText=d.qty;
e.innerText=d.entry?.toFixed(8);
roi.innerText=d.roi?.toFixed(6);
u.innerText=d.unrealizedPnL?.toFixed(6);
r.innerText=d.realizedPnL?.toFixed(6);
s.innerText=d.status;

if(chart.data.labels.length>MAX_POINTS){
chart.data.labels.shift();
chart.data.datasets.forEach(ds=>ds.data.shift());
}
chart.data.labels.push(new Date().toLocaleTimeString());
chart.data.datasets[0].data.push(d.price);
chart.data.datasets[1].data.push(d.resistance);
chart.data.datasets[2].data.push(d.support);
chart.update('none');
});

socket.on('log',m=>{
const d=document.createElement('div');
d.innerText=new Date().toLocaleTimeString()+" "+m;
logBox.prepend(d);
});
</script>
</body>
</html>
`;
