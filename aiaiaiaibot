/******************************************************************************************
 * âš¡ MULTI-COIN PHEMEX BOT + DASHBOARD (PROFIT-ONLY ROI CLOSE)
 * âœ… Closes trades immediately when ROI >= ROI_CLOSE
 * âœ… Scaling near liquidation preserved
 * âœ… Robust order placement (min contract + error logging)
 * âœ… Live dashboard
 ******************************************************************************************/

require('dotenv').config();
const ccxt = require('ccxt');
const express = require('express');
const http = require('http');
const { Server } = require('socket.io');

/* ================= CONFIG ================= */

const LEVERAGE = 20;
const PRICE_RATE = 30_000;
const COIN_DELAY = 2_000;
const LIQ_DISTANCE = 0.015;
const ROI_CLOSE = 4.0; // only closes profitable trades
const SCALE_COOLDOWN = 120_000;
const PORT = 3000;

/* ================= COINS ================= */

const COINS = [
  'LUNC','ACH','JASMY','ONE','RSR','GALA','1000SHIB','DENT','RVN','ZIL',
  'SPELL','IOTX','ANKR','IOST','CKB','TLM','1000PEPE','XVG','WAXP','MEME',
  'BEAM','1000BONK','USTC','1000SATS','PIXEL','VANRY','BOME','DEGEN','MEW',
  'ZBCN','REZ','NOT','TURBO','1000000BABYDOGE','NEIRO','HMSTR','1000CAT',
  'HIPPO','1000CHEEMS','1000WHY','B3','GPS','EPT','HOUSE','DOOD','BANANAS31',
  'SAROS','BROCCOLIF3B','GIGA','VELO','PUMP','TAC','A2Z','TOWNS','XNY','BAS',
  'CAMP','PTB','U','LINEA','XPIN','TOSHI','AKE','NOM','RVV','BLUAI','COMMON','JCT'
];

/* ================= EXCHANGES ================= */

const phemex = new ccxt.phemex({
  apiKey: process.env.PHEMEX_KEY,
  secret: process.env.PHEMEX_SECRET,
  enableRateLimit: true,
  options: { defaultType: 'swap' }
});

const binance = new ccxt.binance({ enableRateLimit: true, options:{ defaultType:'future' } });
const bybit   = new ccxt.bybit({ enableRateLimit: true });
const okx     = new ccxt.okx({ enableRateLimit: true });

const EXCHANGES = [phemex, binance, bybit, okx];

/* ================= STATE ================= */

const state = {};
const sleep = ms => new Promise(r => setTimeout(r, ms));
const sideFromIndex = i => i % 2 === 0 ? 'short' : 'long';

/* ================= CORE MATH ================= */

function calcROI(pos, price) {
  if (!pos.side || !price) return 0;
  const pnl = pos.side === 'LONG'
    ? (price - pos.entry) * pos.qty
    : (pos.entry - price) * pos.qty;
  const margin = (pos.entry * pos.qty) / LEVERAGE;
  return margin ? (pnl / margin) * 100 : 0;
}

function calcLiqPrice(pos) {
  const mmr = 0.005;
  return pos.side === 'LONG'
    ? pos.entry * (1 - (1 / LEVERAGE) + mmr)
    : pos.entry * (1 + (1 / LEVERAGE) - mmr);
}

/* ================= PRICE ================= */

async function fetchPrices(symbol) {
  for (const ex of EXCHANGES) {
    try {
      if (!ex.markets) await ex.loadMarkets();
      if (!ex.symbols.includes(symbol)) continue;
      const t = await ex.fetchTicker(symbol);
      if (t.bid && t.ask) return { bid: t.bid, ask: t.ask };
    } catch {}
  }
  return { bid: 0, ask: 0 };
}

/* ================= POSITION ================= */

async function syncPosition(symbol) {
  try {
    const res = await phemex.fetchPositions([symbol]);
    const p = res.find(x => x.symbol === symbol);
    if (!p || !Number(p.contracts)) return { side:null, qty:0, entry:0 };
    return {
      side: p.side.includes('long') ? 'LONG' : 'SHORT',
      qty: Math.abs(Number(p.contracts)),
      entry: Number(p.entryPrice)
    };
  } catch {
    return { side:null, qty:0, entry:0 };
  }
}

/* ================= ORDER ================= */

async function market(symbol, side, qty, reduceOnly=false) {
  try {
    await phemex.loadMarkets();
    const minQty = phemex.markets[symbol]?.limits?.amount?.min || 1;
    const orderQty = Math.max(qty, minQty);

    await phemex.createOrder(
      symbol,
      'market',
      side,
      orderQty,
      undefined,
      reduceOnly ? { reduceOnly: true } : {}
    );

    console.log(`âœ… ORDER SENT: ${side} ${orderQty} ${symbol}`);
    await sleep(500);
  } catch (e) {
    console.error(`âš ï¸ ORDER FAILED: ${side} ${qty} ${symbol} â†’ ${e.message}`);
  }
}

/* ================= STRATEGY ================= */

async function tradeCoin(coin, index, io) {
  const PRICE_SYMBOL = `${coin}/USDT`;
  const ORDER_SYMBOL = `${coin}/USDT:USDT`;
  const MODE = sideFromIndex(index);

  if (!state[coin]) state[coin] = { lastScale:0 };

  const { bid, ask } = await fetchPrices(PRICE_SYMBOL);
  if (!bid || !ask) return;

  const pos = await syncPosition(ORDER_SYMBOL);
  const execPrice = pos.side === 'LONG' ? bid : ask;
  const roi = calcROI(pos, execPrice);
  const liq = pos.side ? calcLiqPrice(pos) : 0;

  /* ===== ROI CLOSE (PROFIT ONLY) ===== */
  if (pos.side && pos.qty > 0 && roi >= ROI_CLOSE) {
    console.log(`ðŸ’° PROFIT ROI ${roi.toFixed(2)}% reached, closing ${ORDER_SYMBOL}`);
    await market(
      ORDER_SYMBOL,
      pos.side === 'LONG' ? 'sell' : 'buy',
      pos.qty,
      true
    );
    return; // exit after closing
  }

  /* ===== LIQ DEFENSE (scaling only) ===== */
  if (pos.side && liq) {
    const d = Math.abs(execPrice - liq) / liq;
    if (d <= LIQ_DISTANCE && Date.now() - state[coin].lastScale > SCALE_COOLDOWN) {
      await market(ORDER_SYMBOL, pos.side === 'LONG' ? 'buy' : 'sell', 1);
      state[coin].lastScale = Date.now();
    }
  }

  /* ===== ENTRY ===== */
  if (!pos.side) {
    await market(ORDER_SYMBOL, MODE === 'long' ? 'buy' : 'sell', 1);
  }

  /* ===== DASHBOARD ===== */
  io.emit('update', {
    coin,
    mode: MODE.toUpperCase(),
    price: execPrice,
    side: pos.side || 'NONE',
    qty: pos.qty || 0,
    entry: pos.entry || 0,
    roi,
    liq,
    updated: new Date().toLocaleTimeString()
  });
}

/* ================= SERVER ================= */

const app = express();
const server = http.createServer(app);
const io = new Server(server);
app.get('/', (_, res) => res.send(DASHBOARD_HTML));
server.listen(PORT, () => console.log(`ðŸŒ Dashboard http://localhost:${PORT}`));

/* ================= LOOP ================= */

(async () => {
  console.log('ðŸ¤– BOT STARTED (PROFIT-ONLY ROI CLOSE)');
  while (true) {
    for (let i = 0; i < COINS.length; i++) {
      try {
        await tradeCoin(COINS[i], i, io);
        await sleep(COIN_DELAY);
      } catch (e) {
        console.error(`âš ï¸ ${COINS[i]} error â†’ ${e.message}`);
      }
    }
    await sleep(PRICE_RATE);
  }
})();

/* ================= DASHBOARD ================= */

const DASHBOARD_HTML = `
<!DOCTYPE html>
<html>
<head>
<title>Phemex Multi-Coin Bot</title>
<script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
<style>
body{background:#0b0e11;color:#eaeaea;font-family:monospace;padding:20px}
table{border-collapse:collapse;width:100%}
th,td{border:1px solid #2b3139;padding:6px;text-align:center}
th{background:#181a20}
.LONG{color:#0ecb81}
.SHORT{color:#f6465d}
</style>
</head>
<body>
<h2>âš¡ PROFIT-ONLY ROI Multi-Coin Phemex Bot</h2>
<table>
<tr>
<th>COIN</th><th>MODE</th><th>PRICE</th><th>SIDE</th>
<th>QTY</th><th>ENTRY</th><th>ROI%</th><th>LIQ</th><th>UPDATED</th>
</tr>
<tbody id="t"></tbody>
</table>

<script>
const socket = io();
const t = document.getElementById('t');
const rows = {};

socket.on('update', d => {
  if(!rows[d.coin]){
    rows[d.coin] = t.insertRow();
    for(let i=0;i<9;i++) rows[d.coin].insertCell();
  }
  const c = rows[d.coin].cells;
  c[0].innerText=d.coin;
  c[1].innerText=d.mode;
  c[2].innerText=d.price?.toFixed(8);
  c[3].innerHTML='<span class="'+d.side+'">'+d.side+'</span>';
  c[4].innerText=d.qty;
  c[5].innerText=d.entry?.toFixed(8);
  c[6].innerText=d.roi?.toFixed(4);
  c[7].innerText=d.liq?.toFixed(8);
  c[8].innerText=d.updated;
});
</script>
</body>
</html>
`;
