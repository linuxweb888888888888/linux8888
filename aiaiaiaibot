/******************************************************************************************
 * âš¡ MULTI-COIN PHEMEX BOT + DASHBOARD
 * âœ… Embedded COINS
 * âœ… Alternating LONG / SHORT
 * âœ… Single entry
 * âœ… Liquidation defense scaling
 * âœ… Multi-exchange mark price fallback
 * âœ… ONE dashboard (low CPU/RAM)
 ******************************************************************************************/

require('dotenv').config();
const ccxt = require('ccxt');
const express = require('express');
const http = require('http');
const { Server } = require('socket.io');

/* ======================= CONFIG ======================= */

const LEVERAGE     = 20;
const PRICE_RATE   = 30_000;
const COIN_DELAY   = 2_000;
const LIQ_DISTANCE = 0.015;
const ROI_CLOSE    = 4.0;
const PORT         = 3000;

/* ======================= COINS ======================= */

const COINS = [
  'LUNC','ACH','JASMY','ONE','RSR','GALA','1000SHIB','DENT','RVN','ZIL',
  'SPELL','IOTX','ANKR','IOST','CKB','TLM','1000PEPE','XVG','WAXP','MEME',
  'BEAM','1000BONK','USTC','1000SATS','PIXEL','VANRY','BOME','DEGEN','MEW',
  'ZBCN','REZ','NOT','TURBO','1000000BABYDOGE','NEIRO','HMSTR','1000CAT',
  'HIPPO','1000CHEEMS','1000WHY','B3','GPS','EPT','HOUSE','DOOD','BANANAS31',
  'SAROS','BROCCOLIF3B','GIGA','VELO','PUMP','TAC','A2Z','TOWNS','XNY','BAS',
  'CAMP','PTB','U','LINEA','XPIN','TOSHI','AKE','NOM','RVV','BLUAI','COMMON','JCT'
];

/* ======================= EXCHANGES ======================= */

const phemex = new ccxt.phemex({
  apiKey: process.env.PHEMEX_KEY,
  secret: process.env.PHEMEX_SECRET,
  enableRateLimit: true,
  options: { defaultType: 'swap' }
});

const binance = new ccxt.binance({ enableRateLimit: true, options:{ defaultType:'future' } });
const bybit   = new ccxt.bybit({ enableRateLimit: true });
const okx     = new ccxt.okx({ enableRateLimit: true });

const EXCHANGES = [phemex, binance, bybit, okx];

/* ======================= STATE ======================= */

const state = {};   // per-coin state sent to dashboard

/* ======================= UTILS ======================= */

const sleep = ms => new Promise(r => setTimeout(r, ms));
const sideFromIndex = i => i % 2 === 0 ? 'short' : 'long';

function calcROI(pos, price) {
  if (!pos.side || !price) return 0;
  const pnl = pos.side === 'LONG'
    ? (price - pos.entry) * pos.qty
    : (pos.entry - price) * pos.qty;
  const margin = (pos.entry * pos.qty) / LEVERAGE;
  return margin ? (pnl / margin) * 100 : 0;
}

function calcLiqPrice(pos) {
  if (!pos.side) return 0;
  const mmr = 0.005;
  return pos.side === 'LONG'
    ? pos.entry * (1 - (1 / LEVERAGE) + mmr)
    : pos.entry * (1 + (1 / LEVERAGE) - mmr);
}

/* ======================= PRICE ======================= */

async function fetchMarkPrice(symbol) {
  for (const ex of EXCHANGES) {
    try {
      if (!ex.markets) await ex.loadMarkets();
      if (!ex.symbols.includes(symbol)) continue;
      const t = await ex.fetchTicker(symbol);
      const p = t.info?.markPrice || t.last;
      if (p && p > 0) return p;
    } catch {}
  }
  return 0;
}

/* ======================= POSITION ======================= */

async function syncPosition(symbol) {
  try {
    const res = await phemex.fetchPositions([symbol]);
    const p = res.find(x => x.symbol === symbol);
    if (!p || !Number(p.contracts)) return { side:null, qty:0, entry:0 };
    return {
      side: p.side.includes('long') ? 'LONG' : 'SHORT',
      qty: Math.abs(Number(p.contracts)),
      entry: Number(p.entryPrice)
    };
  } catch {
    return { side:null, qty:0, entry:0 };
  }
}

/* ======================= ORDER ======================= */

async function market(symbol, side, qty, reduceOnly=false) {
  await phemex.createOrder(
    symbol,
    'market',
    side,
    qty,
    undefined,
    reduceOnly ? { reduceOnly:true } : {}
  );
  await sleep(500);
}

/* ======================= STRATEGY ======================= */

async function tradeCoin(coin, index, io) {
  const PRICE_SYMBOL = `${coin}/USDT`;
  const ORDER_SYMBOL = `${coin}/USDT:USDT`;
  const MODE = sideFromIndex(index);

  if (!state[coin]) state[coin] = { coin, mode: MODE };

  const price = await fetchMarkPrice(PRICE_SYMBOL);
  if (!price) return;

  const pos = await syncPosition(ORDER_SYMBOL);
  const roi = calcROI(pos, price);
  const liq = calcLiqPrice(pos);

  /* ===== CLOSE ===== */
  if (pos.side && roi >= ROI_CLOSE) {
    await market(ORDER_SYMBOL, pos.side === 'LONG' ? 'sell' : 'buy', pos.qty, true);
  }

  /* ===== SCALE ===== */
  if (pos.side && liq) {
    const d = Math.abs(price - liq) / liq;
    if (d <= LIQ_DISTANCE && (!state[coin].lastScale || Date.now() - state[coin].lastScale > 60_000)) {
      await market(ORDER_SYMBOL, pos.side === 'LONG' ? 'buy' : 'sell', 1);
      state[coin].lastScale = Date.now();
    }
  }

  /* ===== ENTRY ===== */
  if (!pos.side) {
    await market(ORDER_SYMBOL, MODE === 'long' ? 'buy' : 'sell', 1);
  }

  /* ===== DASHBOARD STATE ===== */
  state[coin] = {
    coin,
    mode: MODE.toUpperCase(),
    price,
    side: pos.side || 'NONE',
    qty: pos.qty || 0,
    entry: pos.entry || 0,
    roi,
    liq,
    updated: new Date().toLocaleTimeString()
  };

  io.emit('update', state[coin]);
}

/* ======================= SERVER ======================= */

const app = express();
const server = http.createServer(app);
const io = new Server(server);

app.get('/', (_, res) => res.send(DASHBOARD_HTML));

server.listen(PORT, () =>
  console.log(`ðŸŒ Dashboard http://localhost:${PORT}`)
);

/* ======================= LOOP ======================= */

(async () => {
  console.log('ðŸ¤– Multi-coin bot started');
  while (true) {
    for (let i = 0; i < COINS.length; i++) {
      try {
        await tradeCoin(COINS[i], i, io);
        await sleep(COIN_DELAY);
      } catch (e) {
        console.error(`âš ï¸ ${COINS[i]} ${e.message}`);
      }
    }
    await sleep(PRICE_RATE);
  }
})();

/* ======================= DASHBOARD HTML ======================= */

const DASHBOARD_HTML = `
<!DOCTYPE html>
<html>
<head>
<title>Multi-Coin Phemex Bot</title>
<script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
<style>
body{background:#0b0e11;color:#eaeaea;font-family:monospace;padding:20px}
table{border-collapse:collapse;width:100%}
th,td{border:1px solid #2b3139;padding:6px;text-align:center}
th{background:#181a20}
.LONG{color:#0ecb81}
.SHORT{color:#f6465d}
</style>
</head>
<body>
<h2>âš¡ Multi-Coin Phemex Bot</h2>
<table id="t">
<tr>
<th>COIN</th><th>MODE</th><th>PRICE</th><th>SIDE</th>
<th>QTY</th><th>ENTRY</th><th>ROI%</th><th>LIQ</th><th>UPDATED</th>
</tr>
</table>

<script>
const socket = io();
const table = document.getElementById('t');
const rows = {};

socket.on('update', d => {
  if(!rows[d.coin]){
    const r = table.insertRow();
    rows[d.coin] = r;
    for(let i=0;i<9;i++) r.insertCell();
  }
  const c = rows[d.coin].cells;
  c[0].innerText = d.coin;
  c[1].innerText = d.mode;
  c[2].innerText = d.price?.toFixed(8);
  c[3].innerHTML = '<span class="'+d.side+'">'+d.side+'</span>';
  c[4].innerText = d.qty;
  c[5].innerText = d.entry?.toFixed(8);
  c[6].innerText = d.roi?.toFixed(4);
  c[7].innerText = d.liq?.toFixed(8);
  c[8].innerText = d.updated;
});
</script>
</body>
</html>
`;
