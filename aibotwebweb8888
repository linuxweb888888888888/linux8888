/******************************************************************************************
 * âš¡ LIVE ADAUSDT BOT â€” PHEMEX PERPETUAL SWAP (CCXT)
 * - Instant breakout entries over resistance/support
 * - Close trades based on frozen support/resistance at entry
 * - No trailing stops
 * - Auto-detects open orders
 * - Shows full CCXT order output in log
 ******************************************************************************************/

require('dotenv').config();
const express = require('express');
const http = require('http');
const { Server } = require('socket.io');
const ccxt = require('ccxt');

// ============================ CONFIG ============================
const CONFIG = {
    PRICE_SYMBOL: 'ADA/USDT',
    ORDER_SYMBOL: 'ADA/USDT:USDT',
    TRADE_QTY: 0.01,
    LOT_PRECISION: 2,
    TAKER_FEE_PCT: 0.00075,
    PRICE_RATE: 2000,
    STRATEGY_RATE: 2000,
    LOOKBACK_PERIOD: 50
};

// ============================ STATE ============================
const state = {
    positions: { qty: 0, entry: 0, side: null, openSupport: 0, openResistance: 0 },
    history: [],
    resistance: 0,
    support: 0,
    lastExit: 0,
    status: 'INIT',
    orderLock: false,
    realizedPnL: 0,
    tradeCount: 0,
    winCount: 0,
    lastStrategyTs: 0,
    price: 0,
    bid: 0,
    ask: 0,
    recentOrders: []
};

// ============================ CCXT EXCHANGE ============================
const exchange = new ccxt.phemex({
    apiKey: process.env.PHEMEX_KEY,
    secret: process.env.PHEMEX_SECRET,
    enableRateLimit: true,
    options: { defaultType: 'swap' }
});

// ============================ FETCH PRICE ============================
async function fetchPrice() {
    try {
        const ticker = await exchange.fetchTicker(CONFIG.PRICE_SYMBOL);
        if (!ticker || ticker.bid === undefined || ticker.ask === undefined) return false;
        state.price = (ticker.bid + ticker.ask) / 2;
        state.bid = ticker.bid;
        state.ask = ticker.ask;
        return true;
    } catch (e) {
        console.error('PRICE ERROR:', e.message);
        return false;
    }
}

// ============================ SYNC POSITIONS & ACTIVE ORDERS ============================
async function syncPositions(io) {
    try {
        const positions = await exchange.fetchPositions([CONFIG.ORDER_SYMBOL]);
        const pos = positions.find(p => p.symbol === CONFIG.ORDER_SYMBOL);

        if (pos && Math.abs(Number(pos.contracts)) > 0) {
            state.positions = {
                qty: Math.abs(Number(pos.contracts)),
                entry: parseFloat(pos.entryPrice),
                side: pos.contracts > 0 ? 'LONG' : 'SHORT',
                openSupport: state.positions.openSupport || 0,
                openResistance: state.positions.openResistance || 0
            };
        } else {
            state.positions = { qty: 0, entry: 0, side: null, openSupport: 0, openResistance: 0 };
        }

        let orders = [];
        try {
            orders = await exchange.fetchOpenOrders(CONFIG.ORDER_SYMBOL);
        } catch (e) {
            console.log('fetchOpenOrders(symbol) failed, fetching all orders as fallback');
            orders = await exchange.fetchOpenOrders();
        }

        state.recentOrders = orders.map(o => ({
            id: o.id,
            side: o.side,
            qty: o.amount,
            price: o.price
        }));

        io.emit('log', `Active orders: ${orders.length}`);
        io.emit('log', `CCXT orders raw output: ${JSON.stringify(orders, null, 2)}`);

        return orders;
    } catch (e) {
        console.error('SYNC ERROR:', e);
        io.emit('log', `SYNC ERROR: ${JSON.stringify(e)}`);
        return [];
    }
}

// ============================ PLACE ORDER ============================
async function placeOrder(side, qty) {
    if (state.orderLock) return null;
    state.orderLock = true;
    try {
        console.log(`[ORDER] Placing ${side.toUpperCase()} ${qty} ${CONFIG.ORDER_SYMBOL}`);
        const order = await exchange.createOrder(CONFIG.ORDER_SYMBOL, 'market', side, qty);
        console.log(`[ORDER SUCCESS] ${side.toUpperCase()} ${qty} ${CONFIG.ORDER_SYMBOL} | id: ${order.id}`);
        state.recentOrders.unshift({
            id: order.id,
            side: side,
            qty: qty,
            price: state.price
        });
        return order;
    } catch (e) {
        console.error('ORDER ERROR:', e.message);
        return null;
    } finally {
        state.orderLock = false;
    }
}

// ============================ CLOSE POSITION ============================
async function closePosition(price = null, io) {
    if (!state.positions.side) return;
    price = price || state.price;
    const side = state.positions.side === 'LONG' ? 'sell' : 'buy';
    const qty = state.positions.qty;
    const pnl = state.positions.side === 'LONG'
        ? (price - state.positions.entry) * qty
        : (state.positions.entry - price) * qty;
    state.realizedPnL += pnl;

    const res = await placeOrder(side, qty);
    if (res) {
        state.lastExit = Date.now();
        io.emit('log', `ðŸ›‘ CLOSED ${side.toUpperCase()} at ${price.toFixed(4)} | PnL: ${pnl.toFixed(6)}`);
        state.positions = { qty: 0, entry: 0, side: null, openSupport: 0, openResistance: 0 };
    }
}

// ============================ STRATEGY ============================
async function strategy(io) {
    const ok = await fetchPrice();
    if (!ok) {
        io.emit('log', 'âš ï¸ FAILED TO FETCH PRICE');
        return;
    }

    const orders = await syncPositions(io);
    const price = state.price ?? 0;
    const now = Date.now();
    const pos = state.positions;

    io.emit('log', `PRICE FETCHED: ${price.toFixed(4)} | BID: ${state.bid.toFixed(4)} | ASK: ${state.ask.toFixed(4)}`);
    if (!price) return;

    if (now - state.lastStrategyTs >= CONFIG.STRATEGY_RATE) {
        state.history.push(price);
        if (state.history.length > CONFIG.LOOKBACK_PERIOD + 10) state.history.shift();
        state.lastStrategyTs = now;
    } else return;

    if (state.history.length < CONFIG.LOOKBACK_PERIOD) {
        state.status = 'COLLECTING DATA';
        io.emit('stats', state);
        return;
    }

    const window = state.history.slice(-CONFIG.LOOKBACK_PERIOD);
    const high = Math.max(...window);
    const low = Math.min(...window);
    state.resistance = high;
    state.support = low;

    if (state.orderLock) {
        state.status = 'WAITING FOR ORDER TO COMPLETE';
    } else {
        // LONG position
        if (pos.side === 'LONG') {
            if (price < pos.openSupport) {
                await closePosition(price, io);
                state.status = 'CLOSED LONG (Price < Open Support)';
            } else {
                state.status = 'RIDING LONG';
            }
        }
        // SHORT position
        else if (pos.side === 'SHORT') {
            if (price > pos.openResistance) {
                await closePosition(price, io);
                state.status = 'CLOSED SHORT (Price > Open Resistance)';
            } else {
                state.status = 'RIDING SHORT';
            }
        }
        // No position
        else {
            if (price > high) {
                await placeOrder('buy', CONFIG.TRADE_QTY);
                state.positions = { qty: CONFIG.TRADE_QTY, entry: price, side: 'LONG', openSupport: low, openResistance: high };
                state.status = 'BREAKOUT LONG';
                io.emit('log', `ðŸ“ˆ OPEN LONG at ${price.toFixed(4)}`);
                state.tradeCount++;
            } else if (price < low) {
                await placeOrder('sell', CONFIG.TRADE_QTY);
                state.positions = { qty: CONFIG.TRADE_QTY, entry: price, side: 'SHORT', openSupport: low, openResistance: high };
                state.status = 'BREAKDOWN SHORT';
                io.emit('log', `ðŸ“‰ OPEN SHORT at ${price.toFixed(4)}`);
                state.tradeCount++;
            } else {
                state.status = 'RANGING';
            }
        }
    }

    let unrealizedPnL = 0;
    if (pos.side === 'LONG') unrealizedPnL = (price - pos.entry) * pos.qty;
    else if (pos.side === 'SHORT') unrealizedPnL = (pos.entry - price) * pos.qty;

    io.emit('stats', {
        price: state.price,
        bid: state.bid,
        ask: state.ask,
        resistance: state.resistance || null,
        support: state.support || null,
        posType: state.positions.side || 'NONE',
        qty: state.positions.qty || 0,
        status: state.status,
        tradeCount: state.tradeCount,
        winCount: state.winCount,
        realizedPnL: state.realizedPnL || 0,
        unrealizedPnL: unrealizedPnL || 0,
        recentOrders: state.recentOrders
    });
}

// ============================ SERVER ============================
const app = express();
const server = http.createServer(app);
const io = new Server(server);

app.get('/', (_, res) => res.send(DASHBOARD_HTML));

server.listen(3000, async () => {
    console.log('ðŸš¨ LIVE BOT STARTED â€” ADA/USDT PHEMEX PERPETUAL ðŸš¨');
    await strategy(io);
});

setInterval(() => strategy(io), CONFIG.PRICE_RATE);

// ============================ DASHBOARD ============================
const DASHBOARD_HTML = `<html>
<head>
<title>ADAUSDT Phemex Swap Bot</title>
<script src="https://cdn.jsdelivr.net/npm/socket.io-client@4/dist/socket.io.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<style>
body{background:#0b0e11;color:#eaeaea;font-family:sans-serif;padding:20px;display:flex;flex-direction:column;gap:15px}
.header{display:grid;grid-template-columns:repeat(8,1fr);gap:10px;background:#181a20;padding:15px;border-radius:8px;}
.stat{text-align:center;background:#2b3139;padding:10px;border-radius:5px}
.label{font-size:11px;color:#848e9c;margin-bottom:5px}
.val{font-size:15px;font-weight:bold;font-family:monospace}
.pos-LONG{color:#0ecb81} .pos-SHORT{color:#f6465d}
#chart-box{height:400px;background:#181a20;padding:10px;border-radius:8px;}
#log-box{height:150px;overflow-y:auto;background:#0b0e11;border:1px solid #2b3139;padding:10px;font-family:monospace;font-size:12px;color:#848e9c}
#orders-box{height:100px;overflow-y:auto;background:#0b0e11;border:1px solid #2b3139;padding:10px;font-family:monospace;font-size:12px;color:#fcd535;margin-top:10px}
</style>
</head>
<body>
<div style="text-align:center;font-size:18px">âš¡ ADAUSDT PHEMEX PERPETUAL BOT</div>
<div class="header">
<div class="stat"><div class="label">PRICE</div><div class="val" id="uiPrice">--</div></div>
<div class="stat"><div class="label">BID</div><div class="val" id="uiBid">--</div></div>
<div class="stat"><div class="label">ASK</div><div class="val" id="uiAsk">--</div></div>
<div class="stat"><div class="label">POSITION</div><div class="val" id="uiPos">NONE</div></div>
<div class="stat"><div class="label">QTY</div><div class="val" id="uiQty">0</div></div>
<div class="stat"><div class="label">STATUS</div><div class="val" id="uiStatus">--</div></div>
<div class="stat"><div class="label">UNREALIZED PNL</div><div class="val" id="uiUnrealized">0</div></div>
<div class="stat"><div class="label">REALIZED PNL</div><div class="val" id="uiRealized">0</div></div>
</div>
<div id="chart-box"><canvas id="chart"></canvas></div>
<div id="log-box"></div>
<div id="orders-box"><b>Recent Orders</b><div id="uiOrders"></div></div>
<script>
const socket = io();
const ctx = document.getElementById('chart').getContext('2d');
const chart = new Chart(ctx,{
    type:'line',
    data:{labels:[],datasets:[
        {label:'Price',data:[],borderColor:'#fcd535',borderWidth:2,pointRadius:0},
        {label:'Resistance',data:[],borderColor:'#f6465d',borderWidth:1,pointRadius:0,borderDash:[5,5],stepped:true},
        {label:'Support',data:[],borderColor:'#0ecb81',borderWidth:1,pointRadius:0,borderDash:[5,5],stepped:true}
    ]},
    options:{responsive:true,maintainAspectRatio:false,animation:false,scales:{y:{position:'right',grid:{color:'#2b3139'}}}}
});
function log(msg,color){
    const logBox=document.getElementById('log-box');
    const d=document.createElement('div');
    d.innerHTML='<span style="color:#848e9c">'+new Date().toLocaleTimeString()+'</span> <span style="color:'+color+'">'+msg+'</span>';
    logBox.prepend(d);
}
socket.on('stats', d=>{
    document.getElementById('uiPrice').innerText=d.price.toFixed(4);
    document.getElementById('uiBid').innerText=d.bid.toFixed(4);
    document.getElementById('uiAsk').innerText=d.ask.toFixed(4);
    const posEl=document.getElementById('uiPos');
    posEl.innerText=d.posType || 'NONE';
    posEl.className="val pos-"+(d.posType || 'NONE');
    document.getElementById('uiQty').innerText=d.qty || 0;
    document.getElementById('uiStatus').innerText=d.status;
    document.getElementById('uiUnrealized').innerText=(d.unrealizedPnL>=0?'+':'')+(d.unrealizedPnL||0).toFixed(6);
    document.getElementById('uiUnrealized').style.color=(d.unrealizedPnL||0)>=0?'#0ecb81':'#f6465d';
    document.getElementById('uiRealized').innerText=(d.realizedPnL>=0?'+':'')+(d.realizedPnL||0).toFixed(6);
    document.getElementById('uiRealized').style.color=(d.realizedPnL||0)>=0?'#0ecb81':'#f6465d';

    if(chart.data.labels.length>300){
        chart.data.labels.shift();
        chart.data.datasets.forEach(ds=>ds.data.shift());
    }
    chart.data.labels.push('');
    chart.data.datasets[0].data.push(d.price);
    chart.data.datasets[1].data.push(d.resistance||null);
    chart.data.datasets[2].data.push(d.support||null);
    chart.update('none');

    const ordersEl=document.getElementById('uiOrders');
    ordersEl.innerHTML='';
    (d.recentOrders||[]).slice(0,10).forEach(o=>{
        const div=document.createElement('div');
        div.innerText='['+o.side.toUpperCase()+'] QTY:'+o.qty+' @ '+o.price.toFixed(4)+' ID:'+o.id;
        ordersEl.appendChild(div);
    });
});
socket.on('log', msg=>log(msg,'#fcd535'));
</script>
</body></html>`;
