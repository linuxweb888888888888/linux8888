/******************************************************************************************
 * ZERO-CROSSING Z-SCORE MEAN REVERSION BOT — HITBTC PERP MARKET ORDERS
 * DASHBOARD + REAL-TIME PNL + TRADE MARKERS
 * ONLY OPEN TRADES IF VOLATILITY (SD) > volThreshold AND RISING
 ******************************************************************************************/

const express = require("express");
const http = require("http");
const { Server } = require("socket.io");
const axios = require("axios");

// ============================ CONFIG ============================
const CONFIG = {
    tickRate: 1400,
    windowMinutes: 15,
    smoothing: 1,
    SYMBOLS: ["ADAUSDT"],
    TRADE_QTY: 1,
    FEE_RATE: 0.00075,
    API_KEY: "-3Mn7DL8P20iTj7QPoOSgyATuDcF-87h",
    API_SECRET: "WzxCckLuICMXcjdRL-CbgcsbpGXHePcs",
    volThreshold: 0.0004,
    openZ: 0.5,
    closeZ: 0.0
};

const BUFFER_SIZE = Math.ceil(CONFIG.windowMinutes * 60 * 1000 / CONFIG.tickRate);

// ============================ STATE ============================
let priceHistory = {};
let positions = {};
let realizedPnL = {};
let unrealizedPnL = {};
let tradeHistory = {};
let lastBid = {};
let lastAsk = {};
let lastVolatility = {};
let orderLock = {};

CONFIG.SYMBOLS.forEach(s=>{
    priceHistory[s]=[];
    positions[s]={quantity:0,entryPrice:null,positionType:null};
    realizedPnL[s]=0;
    unrealizedPnL[s]=0;
    tradeHistory[s]=[];
    lastBid[s]=null;
    lastAsk[s]=null;
    lastVolatility[s]=null;
    orderLock[s]=false;
});

// ============================ HELPERS ============================
const mean = a => a.reduce((x,y)=>x+y,0)/a.length;
const stddev = (a,m)=>Math.sqrt(mean(a.map(v=>(v-m)**2)));
const smooth = (a,n)=>n<=1?a[a.length-1]:mean(a.slice(-n));

// ============================ HITBTC ============================
const authHeaders = {
    Authorization:"Basic "+Buffer.from(CONFIG.API_KEY+":"+CONFIG.API_SECRET).toString("base64")
};

async function fetchPerpTicker(symbol){
    const r = await axios.get(`https://api.hitbtc.com/api/3/public/ticker/${symbol}_PERP`);
    lastBid[symbol]=+r.data.bid;
    lastAsk[symbol]=+r.data.ask;
    return (lastBid[symbol]+lastAsk[symbol])/2;
}

async function fetchPositions(){
    const r = await axios.get("https://api.hitbtc.com/api/3/futures/account",{headers:authHeaders});
    CONFIG.SYMBOLS.forEach(sym=>{
        let found=false;
        for(const a of r.data||[]){
            const p=a.positions?.find(x=>x.symbol===sym+"_PERP");
            if(p){
                const q=+p.quantity;
                positions[sym]={quantity:q,entryPrice:+p.price_entry,positionType:q>0?"LONG":q<0?"SHORT":null};
                found=true;
                break;
            }
        }
        if(!found) positions[sym]={quantity:0,entryPrice:null,positionType:null};
    });
}

async function placeOrder(symbol,side,qty){
    if(orderLock[symbol]) return;
    orderLock[symbol]=true;
    try{
        await axios.post("https://api.hitbtc.com/api/3/futures/order",{
            symbol:symbol+"_PERP",
            side,
            quantity:qty,
            type:"market",
            margin_mode:"cross"
        },{headers:authHeaders});
    }finally{ orderLock[symbol]=false; }
}

// ============================ PNL ============================
function calcUnrealized(symbol){
    const p=positions[symbol];
    if(!p.positionType) return 0;
    const q=Math.abs(p.quantity);
    let pnl=p.positionType==="LONG"
        ? (lastBid[symbol]-p.entryPrice)*q
        : (p.entryPrice-lastAsk[symbol])*q;
    return pnl - p.entryPrice*q*CONFIG.FEE_RATE;
}

// ============================ STRATEGY ============================
async function runStrategy(io,symbol){
    const prices=priceHistory[symbol];
    if(prices.length<50) return;

    const sm=smooth(prices,CONFIG.smoothing);
    const m=mean(prices);
    const sd=stddev(prices,m);
    const z=(sm-m)/sd;

    unrealizedPnL[symbol]=calcUnrealized(symbol);

    io.emit("stats",{
        symbol,
        price:sm,
        zScore:z,
        volatility:sd,
        position:positions[symbol].positionType||"NONE",
        entryPrice:positions[symbol].entryPrice||0,
        quantity:positions[symbol].quantity||0,
        realizedPnL:realizedPnL[symbol],
        unrealizedPnL:unrealizedPnL[symbol]
    });

    const prevSD=lastVolatility[symbol];
    lastVolatility[symbol]=sd;

    if(sd<CONFIG.volThreshold || prevSD===null || sd<=prevSD) return;

    const pos=positions[symbol].positionType;

    if(z>CONFIG.openZ){
        if(pos==="SHORT") await closePosition(io,symbol);
        if(!pos) await openPosition(io,symbol,"LONG");
    }

    if(z<-CONFIG.openZ){
        if(pos==="LONG") await closePosition(io,symbol);
        if(!pos) await openPosition(io,symbol,"SHORT");
    }

    if(pos==="LONG" && z<CONFIG.closeZ) await closePosition(io,symbol);
    if(pos==="SHORT" && z>-CONFIG.closeZ) await closePosition(io,symbol);
}

// ============================ ORDERS ============================
async function openPosition(io,symbol,type){
    await placeOrder(symbol,type==="LONG"?"buy":"sell",CONFIG.TRADE_QTY);
    await fetchPositions();
    tradeHistory[symbol].push({type:`OPEN ${type}`,idx:priceHistory[symbol].length-1});
    io.emit("trade",tradeHistory[symbol].at(-1));
}

async function closePosition(io,symbol){
    const p=positions[symbol];
    if(!p.positionType) return;
    const side=p.positionType==="LONG"?"sell":"buy";
    const qty=Math.abs(p.quantity);
    const exit=p.positionType==="LONG"?lastBid[symbol]:lastAsk[symbol];
    let pnl=p.positionType==="LONG"
        ? (exit-p.entryPrice)*qty
        : (p.entryPrice-exit)*qty;
    pnl-=p.entryPrice*qty*CONFIG.FEE_RATE;
    realizedPnL[symbol]+=pnl;
    await placeOrder(symbol,side,qty);
    tradeHistory[symbol].push({type:`CLOSE ${p.positionType}`,pnl,idx:priceHistory[symbol].length-1});
    io.emit("trade",tradeHistory[symbol].at(-1));
    positions[symbol]={quantity:0,entryPrice:null,positionType:null};
}

// ============================ SERVER ============================
const app=express();
const server=http.createServer(app);
const io=new Server(server);
let online=0;

io.on("connection",s=>{
    online++;
    io.emit("onlineUsers",online);
    s.on("disconnect",()=>io.emit("onlineUsers",--online));
});

app.get("/",(r,res)=>res.send(DASHBOARD_HTML));
(async()=>{await fetchPositions();})();

setInterval(async()=>{
    for(const s of CONFIG.SYMBOLS){
        const price=await fetchPerpTicker(s);
        priceHistory[s].push(price);
        if(priceHistory[s].length>BUFFER_SIZE) priceHistory[s].shift();
        await fetchPositions();
        io.emit("tick",{symbol:s,price});
        await runStrategy(io,s);
    }
},CONFIG.tickRate);

server.listen(3000,()=>console.log("Bot running → http://localhost:3000"));

// ============================ DASHBOARD ============================
const DASHBOARD_HTML = `<!DOCTYPE html>
<html>
<head>
<title>Z-Score Bot</title>
<meta name="viewport" content="width=device-width,initial-scale=1">
<style>
body{margin:0;background:#121212;color:#fff;font-family:sans-serif;overflow:hidden}
#topbar{display:flex;flex-wrap:wrap;gap:10px;padding:10px}
.card{background:#1f1f1f;padding:12px;border-radius:12px;flex:1;text-align:center}
.label{font-size:12px;opacity:.7}
.value{font-size:18px}
#layout{display:flex;flex-direction:column;height:calc(100vh - 120px)}
#left{flex:1;min-height:45vh}
#right{flex:1;overflow:auto;padding:10px;background:#151515}
canvas{width:100%!important;height:100%!important}
</style>
<script src="https://cdn.jsdelivr.net/npm/socket.io-client@4/dist/socket.io.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
</head>
<body>
<div id="topbar">
<div class="card"><div class="label">Price</div><div class="value" id="priceBox">--</div></div>
<div class="card"><div class="label">Z</div><div class="value" id="zBox">--</div></div>
<div class="card"><div class="label">Vol</div><div class="value" id="volBox">--</div></div>
<div class="card"><div class="label">Pos</div><div class="value" id="posBox">--</div></div>
<div class="card"><div class="label">Entry</div><div class="value" id="entryBox">--</div></div>
<div class="card"><div class="label">Qty</div><div class="value" id="qtyBox">--</div></div>
<div class="card"><div class="label">Real</div><div class="value" id="pnlBox">0</div></div>
<div class="card"><div class="label">Unreal</div><div class="value" id="unrealizedPnlBox">0</div></div>
<div class="card"><div class="label">Online</div><div class="value" id="onlineBox">0</div></div>
</div>
<div id="layout">
<div id="left"><canvas id="chart"></canvas></div>
<div id="right"><pre id="tradeLog"></pre></div>
</div>
<script>
const socket=io();
const ctx=document.getElementById("chart").getContext("2d");
const chart=new Chart(ctx,{
 type:"line",
 data:{labels:[],datasets:[
  {label:"Price",data:[],borderColor:"white",borderWidth:2,pointRadius:0},
  {label:"Trades",data:[],showLine:false,pointRadius:7,pointBackgroundColor:[]}
 ]},
 options:{responsive:true,maintainAspectRatio:false,animation:false,scales:{x:{display:false}}}
});
socket.on("tick",m=>{
 chart.data.labels.push("");
 chart.data.datasets[0].data.push(m.price);
 chart.data.datasets[1].data.push(null);
 chart.data.datasets[1].pointBackgroundColor.push(null);
 if(chart.data.labels.length>${BUFFER_SIZE}){
  chart.data.labels.shift();
  chart.data.datasets[0].data.shift();
  chart.data.datasets[1].data.shift();
  chart.data.datasets[1].pointBackgroundColor.shift();
 }
 chart.update("none");
});
socket.on("stats",m=>{
 priceBox.innerText=m.price.toFixed(5);
 zBox.innerText=m.zScore.toFixed(2);
 volBox.innerText=m.volatility.toFixed(5);
 posBox.innerText=m.position;
 entryBox.innerText=m.entryPrice?m.entryPrice.toFixed(5):"--";
 qtyBox.innerText=m.quantity;
 pnlBox.innerText=m.realizedPnL.toFixed(5);
 unrealizedPnlBox.innerText=m.unrealizedPnL.toFixed(5);
});
socket.on("trade",t=>{
 tradeLog.innerText=JSON.stringify(t,null,2)+"\\n"+tradeLog.innerText;
 const idx=t.idx;
 const color=t.type.includes("LONG")?"lime":t.type.includes("SHORT")?"red":"yellow";
 chart.data.datasets[1].data[idx]=chart.data.datasets[0].data[idx];
 chart.data.datasets[1].pointBackgroundColor[idx]=color;
 chart.update();
});
socket.on("onlineUsers",n=>onlineBox.innerText=n);
</script>
</body>
</html>`;
