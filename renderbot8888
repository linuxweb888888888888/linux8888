import ccxt
import time
import subprocess
import pandas as pd
import numpy as np
import os
import re
import logging
import sys
from datetime import datetime
from sklearn.ensemble import RandomForestRegressor
from sklearn.preprocessing import StandardScaler
from collections import deque

# ------------------------------------------------------------------------------
# CONFIGURATION
# ------------------------------------------------------------------------------
SYMBOL_CCXT = 'ATOM/USDT'      
SYMBOL_BASH = 'ATOMUSDT_PERP'  
BASE_COIN = 'ATOM'             
MIN_QTY = 0.001                

# EXECUTION SETTINGS
MIN_TRADE_QTY_FACTOR = 1       
DECIMAL_PRECISION = len(str(MIN_QTY).split('.')[-1]) 
DASHBOARD_PATH = '/var/www/html/dashboard.html'

# AI / DATA SETTINGS
MAX_HISTORY = 300              # Increased for better stability
TRAINING_INTERVAL = 5          # Train every 5 ticks to save CPU
FEE_RATE = 0.0006              

# STRATEGY SETTINGS
TARGET_PROFIT_PCT = 0.0001     
GRID_STEP_PCT = 0.001          

# *** AGGRESSIVE CAPITAL UTILIZATION ***
INITIAL_ENTRY_SIZE_MULTIPLIER = 3.0 # INCREASED from 2.0 for faster compounding/recovery
UHF_SLEEP_SECONDS = 0.05       

# *** MAX ACTIVITY & SIZING ***
# Uses 10% of your Total Usable USDT for every new entry (INCREASED from 5%)
AGGRESSIVE_ENTRY_WALLET_PCT = 0.10 

# DISPLAY SETTINGS
SPREAD_TIGHT_THRESHOLD = 0.0005 

# SAFETY SETTINGS
MAX_DAILY_LOSS_PCT = 5.0       # Stop bot if equity drops 5% in a session

# ------------------------------------------------------------------------------
# LOGGING SETUP
# ------------------------------------------------------------------------------
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger()

# ------------------------------------------------------------------------------
# SYSTEM INTERFACE (Bash Scripts) with FASTER CACHING
# ------------------------------------------------------------------------------
class SystemInterface:
    def __init__(self):
        self.last_wallet_check = 0
        self.last_pos_check = 0
        self.cached_wallet = 0.0
        self.cached_pos = {'symbol': SYMBOL_BASH, 'qty': 0.0, 'entry_price': 0.0, 'has_position': False}
        # CACHE DURATION REDUCED FROM 2.0s TO 0.5s for faster updates
        self.cache_duration = 0.5 

    @staticmethod
    def run_command(command_list):
        try:
            result = subprocess.run(command_list, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, timeout=2)
            return result.stdout.strip()
        except Exception as e:
            logger.error(f"Cmd Fail: {command_list} | {e}")
            return None

    def get_wallet_balance(self, force=False):
        """Faster Cached wallet check (0.5s refresh)"""
        now = time.time()
        if not force and (now - self.last_wallet_check < self.cache_duration):
            return self.cached_wallet

        output = self.run_command(['bash', '/wallet.sh'])
        if output:
            try:
                lines = output.split('\n')
                self.cached_wallet = float(lines[0].strip())
                self.last_wallet_check = now
            except ValueError:
                pass
        return self.cached_wallet

    def get_real_position(self, symbol_bash, force=False):
        """Faster Cached position check (0.5s refresh)"""
        now = time.time()
        if not force and (now - self.last_pos_check < self.cache_duration):
            return self.cached_pos

        output = self.run_command(['bash', '/coinrealinfo.sh', symbol_bash])
        
        data = {
            'symbol': symbol_bash,
            'qty': 0.0,
            'entry_price': 0.0,
            'has_position': False
        }

        if output and "NO INFO" not in output and output != "":
            try:
                qty_match = re.search(r'Quantity:\s*([\d\.-]+)', output)
                entry_match = re.search(r'Entry Price:\s*([\d\.-]+)', output)

                if qty_match: data['qty'] = float(qty_match.group(1))
                if entry_match: data['entry_price'] = float(entry_match.group(1))
                
                if abs(data['qty']) > 0:
                    data['has_position'] = True
            except Exception:
                pass

        self.cached_pos = data
        self.last_pos_check = now
        return data

    def place_order(self, coin_base, qty, side):
        cmd = ['bash', '/placeorder.sh', coin_base, str(qty), side]
        output = self.run_command(cmd)
        
        # Invalidate cache instantly after trade
        self.last_pos_check = 0 
        self.last_wallet_check = 0
        
        if output and "SUCCESS" in output:
            logger.info(f"Order SUCCESS: {side} {qty} {coin_base}")
            return True
        else:
            logger.error(f"Order ERROR: {output}")
            return False

    def close_all_positions(self):
        output = self.run_command(['bash', '/closepositions.sh'])
        self.last_pos_check = 0
        return output

# ------------------------------------------------------------------------------
# WALLET LEARNER
# ------------------------------------------------------------------------------
class WalletLearner:
    def __init__(self):
        self.initial_balance = 0.0
        self.current_balance = 0.0
        self.start_balance_session = 0.0
        self.trade_history = deque(maxlen=50)
        self.dynamic_threshold = 30.0 
        self.risk_multiplier = 0.99

    def update_balance(self, new_balance):
        if self.initial_balance == 0:
            self.initial_balance = new_balance
            self.start_balance_session = new_balance
            self.current_balance = new_balance
            return True

        drawdown = (self.start_balance_session - new_balance) / self.start_balance_session * 100
        if drawdown > MAX_DAILY_LOSS_PCT:
            logger.critical(f"MAX DAILY LOSS HIT (-{drawdown:.2f}%). STOPPING BOT.")
            return False

        delta = new_balance - self.current_balance
        self.current_balance = new_balance
        
        if abs(delta) > 0.0001:
            self.trade_history.append(delta)
            self.adapt_strategy(delta)
        
        return True

    def adapt_strategy(self, delta):
        if delta > 0:
            self.dynamic_threshold = max(15.0, self.dynamic_threshold - 0.5)
        else:
            self.dynamic_threshold = min(45.0, self.dynamic_threshold + 1.0)

    def get_growth_pct(self):
        if self.initial_balance == 0: return 0.0
        return ((self.current_balance - self.initial_balance) / self.initial_balance) * 100

# ------------------------------------------------------------------------------
# AI ENGINE
# ------------------------------------------------------------------------------
class AIEngine:
    def __init__(self):
        self.exchange = ccxt.hitbtc({
            'enableRateLimit': True,
            'options': {'defaultType': 'future'} 
        })
        self.history = pd.DataFrame()
        self.model = RandomForestRegressor(n_estimators=30, max_depth=6, random_state=42, n_jobs=-1) 
        self.is_trained = False
        self.simulation_wins = 0
        self.simulation_total = 0
        self.last_prediction = 0.0
        self.confidence = 0.0
        self.avg_volatility = 0.0

    def fetch_price(self):
        try:
            ticker = self.exchange.fetch_ticker(SYMBOL_CCXT)
            return {
                'bid': ticker['bid'],
                'ask': ticker['ask'],
                'last': ticker['last'],
                'timestamp': datetime.now()
            }
        except ccxt.NetworkError as e:
            logger.warning(f"Network Error: {e}")
            return None
        except Exception as e:
            logger.error(f"CCXT Error: {e}")
            return None

    def update_data(self, price_data):
        new_row = pd.DataFrame([price_data])
        if self.history.empty:
            self.history = new_row
        else:
            self.history = pd.concat([self.history, new_row], ignore_index=True)
        
        if len(self.history) > MAX_HISTORY:
            self.history = self.history.iloc[-MAX_HISTORY:]

    def calculate_features(self, df):
        df = df.copy()
        df['mid_price'] = (df['bid'] + df['ask']) / 2
        df['returns'] = df['mid_price'].pct_change()
        
        delta = df['mid_price'].diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=5).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=5).mean()
        rs = gain / (loss + 1e-9)
        df['rsi'] = 100 - (100 / (1 + rs))
        
        df['volatility'] = df['returns'].rolling(window=5).std()
        df['momentum'] = df['mid_price'] - df['mid_price'].shift(3)
        df['spread'] = df['ask'] - df['bid']
        df['spread_change'] = df['spread'].diff()
        df['ma_5'] = df['mid_price'].rolling(window=5).mean()
        
        df['target'] = df['mid_price'].shift(-1) - df['mid_price']
        
        return df

    def train_and_predict(self):
        if len(self.history) < 50: return 0, 0 

        df_all = self.calculate_features(self.history)
        X_current = df_all.iloc[[-1]].drop(columns=['target', 'timestamp'], errors='ignore').dropna()
        df_train = df_all.iloc[:-1].dropna()

        if df_train.empty or X_current.empty: return 0, 0

        feature_cols = ['rsi', 'volatility', 'spread', 'momentum', 'ma_5', 'spread_change']
        
        available_cols = [c for c in feature_cols if c in df_train.columns and c in X_current.columns]
        if not available_cols: return 0, 0

        X = df_train[available_cols]
        y = df_train['target']
        X_curr = X_current[available_cols]

        if self.is_trained:
            actual_move = df_all.iloc[-2]['target'] if not pd.isna(df_all.iloc[-2]['target']) else 0
            if (self.last_prediction > 0 and actual_move > 0) or (self.last_prediction < 0 and actual_move < 0):
                self.simulation_wins += 1
            self.simulation_total += 1

        try:
            self.model.fit(X, y)
            self.is_trained = True
        except Exception:
            return 0, 0

        prediction = self.model.predict(X_curr)[0]
        avg_vol = df_train['volatility'].mean()
        confidence = min(abs(prediction) / (avg_vol + 1e-9), 1.0) * 100
        
        self.last_prediction = prediction
        self.confidence = confidence
        self.avg_volatility = avg_vol
        
        return prediction, confidence

# ------------------------------------------------------------------------------
# MAIN BOT LOGIC
# ------------------------------------------------------------------------------
class TradingBot:
    def __init__(self):
        self.sys = SystemInterface()
        self.ai = AIEngine()
        self.wallet_learner = WalletLearner()
        self.running = True
        self.iteration = 0
        self.action_history = deque(maxlen=5) 
        self.last_dashboard_update = 0

    def generate_dashboard(self, wallet, position, price_info, prediction, confidence, action_msg, action_type, avg_volatility, dynamic_threshold, required_pnl_usd, action_history):
        unrealized_pnl = 0.0
        target_price = 0.0
        pos_dir = "FLAT"
        pos_qty_display = "0.000"
        
        if position['has_position']:
            qty = position['qty']
            entry = position['entry_price']
            is_long = qty > 0
            curr_price = price_info['bid'] if is_long else price_info['ask']
            
            if is_long: 
                unrealized_pnl = (curr_price - entry) * abs(qty)
                pos_dir = "LONG"
            else: 
                unrealized_pnl = (entry - curr_price) * abs(qty)
                pos_dir = "SHORT"
            
            pos_qty_display = f"{abs(qty):.{DECIMAL_PRECISION}f}"
            
            if abs(qty) > 0:
                if is_long:
                    target_price = entry + (required_pnl_usd / abs(qty))
                else:
                    target_price = entry - (required_pnl_usd / abs(qty))
        
        # Styles
        pnl_class = "neutral-text"
        if unrealized_pnl > 0: pnl_class = "success-text"
        elif unrealized_pnl < 0: pnl_class = "danger-text"

        sim_acc = 0
        if self.ai.simulation_total > 0:
            sim_acc = (self.ai.simulation_wins / self.ai.simulation_total) * 100
            
        growth_pct = self.wallet_learner.get_growth_pct()
        growth_class = "success-text" if growth_pct >= 0 else "danger-text"
        
        ai_signal = 'LONG' if prediction > 0 else 'SHORT'
        signal_color = 'var(--success-green)' if prediction > 0 else ('var(--danger-red)' if prediction < 0 else 'var(--neutral-gray)')
        
        spread = price_info['ask'] - price_info['bid']
        spread_status = "Tight" if spread <= SPREAD_TIGHT_THRESHOLD else "Wide"
        spread_class = "success-text" if spread_status == "Tight" else "danger-text"

        confidence_width = min(confidence, 100) 
        threshold_pos = min(dynamic_threshold, 100) 
        
        pos_class = "neutral-pos"
        if pos_dir == "LONG": pos_class = "long-pos"
        elif pos_dir == "SHORT": pos_class = "short-pos"

        history_html = ""
        for item in action_history:
            history_html += f"<div class='log-entry {item['class']}'><span class='log-time'>{item['time']}</span><span class='log-message'>{item['message']}</span></div>"

        # HTML with AJAX RELOAD
        html = f"""
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>UHF SCALPER V2.0</title>
            <style>
                @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Roboto+Mono:wght@300;400;700&display=swap');
                :root {{ --bg-dark: #070D12; --card-bg: #101F2B; --success-green: #00FF99; --danger-red: #FF3366; --accent-blue: #00BFFF; --neutral-gray: #4A6D7C; --text-light: #E0FFEF; --long-color: #00BFFF; --short-color: #FF3366; }}
                body {{ font-family: 'Roboto Mono', monospace; background-color: var(--bg-dark); color: var(--text-light); margin: 0; padding: 15px; overflow-x: hidden; }}
                .header {{ font-family: 'Orbitron', sans-serif; text-align: center; margin-bottom: 20px; font-size: 1.8rem; font-weight: 900; color: var(--success-green); padding-bottom: 10px; border-bottom: 2px solid var(--neutral-gray); }}
                .container {{ max-width: 1200px; margin: auto; }}
                .grid-main {{ display: grid; grid-template-columns: 2fr 1fr; gap: 15px; }}
                .grid-bottom {{ display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-top: 15px; }}
                .card {{ background-color: var(--card-bg); border-radius: 8px; padding: 20px; border: 1px solid var(--neutral-gray); box-shadow: 0 4px 10px rgba(0, 0, 0, 0.6); }}
                h2 {{ font-family: 'Orbitron', sans-serif; margin-top: 0; font-size: 0.8rem; color: var(--text-light); text-transform: uppercase; border-bottom: 1px dashed var(--neutral-gray); padding-bottom: 5px; margin-bottom: 15px; }}
                .value {{ font-size: 2rem; font-weight: 700; margin-top: 5px; line-height: 1.1; }}
                .value.pnl {{ font-size: 3.5rem; }}
                .sub {{ font-size: 0.8rem; color: var(--neutral-gray); margin-top: 5px; }}
                .success-text {{ color: var(--success-green); }} .danger-text {{ color: var(--danger-red); }} .neutral-text {{ color: var(--accent-blue); }}
                .status-bar {{ display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px; padding: 10px 15px; border-radius: 6px; font-family: 'Orbitron', sans-serif; font-size: 1rem; font-weight: 700; border: 1px solid; }}
                .long-pos {{ background-color: rgba(0, 191, 255, 0.2); border-color: var(--long-color); color: var(--long-color); }}
                .short-pos {{ background-color: rgba(255, 51, 102, 0.2); border-color: var(--short-color); color: var(--short-color); }}
                .neutral-pos {{ background-color: rgba(74, 109, 124, 0.2); border-color: var(--neutral-gray); color: var(--neutral-gray); }}
                .confidence-gauge {{ height: 10px; background-color: var(--neutral-gray); border-radius: 5px; overflow: hidden; position: relative; margin-top: 10px; }}
                .confidence-fill {{ height: 100%; background-color: var(--success-green); transition: width 0.3s; }}
                .threshold-marker {{ position: absolute; height: 100%; width: 2px; background-color: var(--danger-red); top: 0; }}
                .log-entry {{ font-size: 0.8rem; padding: 5px 0; border-bottom: 1px dotted rgba(74, 109, 124, 0.3); display: flex; }}
                .log-time {{ color: var(--neutral-gray); min-width: 60px; margin-right: 10px; }}
                .log-entry.entry .log-message {{ color: var(--accent-blue); }} .log-entry.profit .log-message {{ color: var(--success-green); }} .log-entry.recovery .log-message {{ color: var(--danger-red); }}
            </style>
        </head>
        <body>
            <div id="dashboard-content">
                <div class="header">UHF SCALPER V2.0 / {SYMBOL_CCXT}</div>
                <div class="container">
                    <div class="status-bar {pos_class}">
                        <span>STATUS: {pos_dir}</span>
                        <span>QTY: {pos_qty_display} {BASE_COIN}</span>
                        <span>ENTRY: {position['entry_price']:.6f}</span>
                    </div>
                    <div class="grid-main">
                        <div>
                            <div class="card pnl-block" style="border-left: 4px solid {'var(--success-green)' if unrealized_pnl > 0 else 'var(--danger-red)' if unrealized_pnl < 0 else 'var(--neutral-gray)'};">
                                <h2>UNREALIZED PNL</h2>
                                <div class="value pnl {pnl_class}">{unrealized_pnl:.6f} USDT</div>
                                <div class="sub">Required: <span class="success-text">{required_pnl_usd:.6f} USDT</span></div>
                            </div>
                            <div class="card" style="margin-top: 15px;">
                                <h2>AI CONFIDENCE</h2>
                                <div class="confidence-gauge">
                                    <div class="threshold-marker" style="left: {threshold_pos}%;"></div>
                                    <div class="confidence-fill" style="width: {confidence_width}%;"></div>
                                </div>
                                <div class="sub" style="display:flex; justify-content:space-between;"><span>Thr: {dynamic_threshold:.1f}%</span><span>Conf: {confidence:.1f}%</span></div>
                            </div>
                        </div>
                        <div>
                            <div class="card">
                                <h2>PRICE</h2>
                                <div class="value neutral-text">{price_info['last']:.6f}</div>
                                <div class="sub">Signal: <span style="color: {signal_color}">{ai_signal} ({prediction:.8f})</span></div>
                                <div class="sub">Target: <span class="success-text">{target_price:.6f}</span></div>
                            </div>
                            <div class="card" style="margin-top: 15px;">
                                <h2>LOG</h2>
                                {history_html}
                            </div>
                        </div>
                    </div>
                    <div class="grid-bottom">
                        <div class="card"><h2>BALANCE</h2><div class="value success-text">${wallet:.4f}</div><div class="sub">Growth: <span class="{growth_class}">{growth_pct:.4f}%</span></div></div>
                        <div class="card"><h2>SPREAD</h2><div class="value {spread_class}">{spread:.6f}</div><div class="sub">{spread_status}</div></div>
                        <div class="card"><h2>ACCURACY</h2><div class="value neutral-text">{sim_acc:.1f}%</div><div class="sub">Simulated</div></div>
                        <div class="card"><h2>NOISE</h2><div class="value neutral-text">{(avg_volatility*100):.4f}%</div></div>
                    </div>
                </div>
            </div>
            <script>
                // AJAX RELOAD for smooth, non-blinking dashboard refresh
                setInterval(function() {{
                    var timestamp = new Date().getTime();
                    // Fetch the content of the dashboard file itself
                    fetch(window.location.href.split('?')[0] + '?t=' + timestamp)
                        .then(response => response.text())
                        .then(html => {{
                            var parser = new DOMParser();
                            var doc = parser.parseFromString(html, "text/html");
                            // Isolate the dynamic content only
                            var newContent = doc.getElementById("dashboard-content").innerHTML;
                            document.getElementById("dashboard-content").innerHTML = newContent;
                        }})
                        .catch(err => console.log("Refresh error: " + err));
                }}, 500); // Reload every 500ms
            </script>
        </body>
        </html>
        """
        try:
            with open(DASHBOARD_PATH, 'w') as f:
                f.write(html)
        except Exception as e:
            logger.error(f"Failed to write dashboard: {e}")

    def run(self):
        logger.info("Starting AGGRESSIVE UHF SCALPER...")
        self.sys.close_all_positions()
        
        initial_wallet = self.sys.get_wallet_balance(force=True)
        self.wallet_learner.update_balance(initial_wallet)
        
        while self.running:
            start_time = time.time()
            try:
                action_log = "Scanning..."
                action_type = "SCANNING"
                
                price_data = self.ai.fetch_price()
                if not price_data:
                    time.sleep(0.1)
                    continue

                self.ai.update_data(price_data)
                if self.iteration % TRAINING_INTERVAL == 0:
                    prediction, confidence = self.ai.train_and_predict()
                else:
                    prediction = self.ai.last_prediction
                    confidence = self.ai.confidence

                wallet = self.sys.get_wallet_balance()
                pos_data = self.sys.get_real_position(SYMBOL_BASH)
                
                is_safe = self.wallet_learner.update_balance(wallet)
                if not is_safe:
                    self.sys.close_all_positions()
                    self.running = False
                    break

                dynamic_threshold = self.wallet_learner.dynamic_threshold
                required_pnl_usd = 0.0
                
                # ---------------------------------------------------------
                # TRADING LOGIC
                # ---------------------------------------------------------
                if pos_data['has_position']:
                    qty = pos_data['qty']
                    entry = pos_data['entry_price']
                    is_long = qty > 0
                    
                    curr_price = price_data['bid'] if is_long else price_data['ask']
                    
                    if is_long:
                        current_pnl = (curr_price - entry) * abs(qty)
                        price_diff_pct = (curr_price - entry) / entry
                    else:
                        current_pnl = (entry - curr_price) * abs(qty)
                        price_diff_pct = (entry - curr_price) / entry

                    total_fee = (entry * abs(qty) * FEE_RATE) + (curr_price * abs(qty) * FEE_RATE)
                    net_pnl = current_pnl - total_fee
                    
                    entry_value = entry * abs(qty)
                    required_gross = entry_value * TARGET_PROFIT_PCT
                    required_pnl_usd = required_gross + total_fee
                    
                    action_log = f"PnL: {net_pnl:.6f} (Req: {required_pnl_usd:.4f})"
                    action_type = "PROFIT" if net_pnl >= 0 else "RECOVERY"

                    # 1. MAX SPEED SCALP PROFIT TAKER (Full Close)
                    if current_pnl > required_pnl_usd:
                        side = 'sell' if is_long else 'buy'
                        if self.sys.place_order(BASE_COIN, abs(qty), side):
                            action_log = f"PROFIT CLOSE: +{net_pnl:.4f}"
                            action_type = "CLOSE"

                    # 2. AGGRESSIVE PYRAMIDING
                    elif net_pnl > 0 and confidence > 60.0:
                         if (is_long and prediction > 0) or (not is_long and prediction < 0):
                             execution_price = price_data['ask'] if is_long else price_data['bid']
                             usable_wallet = wallet * self.wallet_learner.risk_multiplier
                             free_margin = usable_wallet - (abs(qty) * execution_price)
                             
                             if free_margin > (execution_price * MIN_QTY * 2):
                                 # Uses the INCREASED INITIAL_ENTRY_SIZE_MULTIPLIER = 3.0
                                 raw_qty = (free_margin * INITIAL_ENTRY_SIZE_MULTIPLIER) / execution_price
                                 add_qty = max(MIN_QTY, round(np.floor(raw_qty/MIN_QTY)*MIN_QTY, DECIMAL_PRECISION))
                                 side = 'buy' if is_long else 'sell'
                                 if self.sys.place_order(BASE_COIN, add_qty, side):
                                     action_log = f"COMPOUND: +{add_qty}"
                                     action_type = "COMPOUND"

                    # 3. GRID RECOVERY
                    elif price_diff_pct < -GRID_STEP_PCT:
                        if (is_long and prediction > -0.2) or (not is_long and prediction < 0.2):
                            execution_price = price_data['ask'] if is_long else price_data['bid']
                            usable_wallet = wallet * self.wallet_learner.risk_multiplier
                            free_margin = usable_wallet - (abs(qty) * execution_price)
                            
                            if free_margin > (execution_price * MIN_QTY * 2):
                                # Uses the INCREASED INITIAL_ENTRY_SIZE_MULTIPLIER = 3.0 (with 0.8 scaling)
                                raw_qty = (free_margin * 0.8 * INITIAL_ENTRY_SIZE_MULTIPLIER) / execution_price
                                rec_qty = max(MIN_QTY, round(np.floor(raw_qty/MIN_QTY)*MIN_QTY, DECIMAL_PRECISION))
                                side = 'buy' if is_long else 'sell'
                                if self.sys.place_order(BASE_COIN, rec_qty, side):
                                    action_log = f"RECOVERY: +{rec_qty}"
                                    action_type = "RECOVERY"

                else:
                    # -----------------------------------------------------
                    # AGGRESSIVE NEW ENTRY (10% of Usable Wallet)
                    # -----------------------------------------------------
                    if self.ai.is_trained and confidence > dynamic_threshold and len(self.ai.history) > 50: 
                        
                        if prediction > 0:
                            execution_price = price_data['ask']
                            side = 'buy'
                        elif prediction < 0:
                            execution_price = price_data['bid']
                            side = 'sell'
                        else:
                            side = None
                            
                        if side:
                            usable_wallet = wallet * self.wallet_learner.risk_multiplier
                            
                            # LOGIC: (Wallet * 0.10) / Price -> Maximized entry size
                            raw_qty = (usable_wallet * AGGRESSIVE_ENTRY_WALLET_PCT) / execution_price
                            trade_qty = np.floor(raw_qty / MIN_QTY) * MIN_QTY
                            trade_qty = max(MIN_QTY, round(trade_qty, DECIMAL_PRECISION))
                            
                            cost = trade_qty * execution_price
                            
                            if cost < usable_wallet:
                                if self.sys.place_order(BASE_COIN, trade_qty, side):
                                    action_log = f"ENTRY {side.upper()}: {trade_qty} (C:{confidence:.1f}%)"
                                    action_type = "ENTRY"

                if action_type != "SCANNING":
                    self.action_history.appendleft({
                        'time': datetime.now().strftime('%H:%M:%S'), 
                        'message': action_log, 
                        'class': action_type.lower()
                    })
                    
                self.generate_dashboard(wallet, pos_data, price_data, prediction, confidence, action_log, action_type, self.ai.avg_volatility, dynamic_threshold, required_pnl_usd, list(self.action_history))
                self.iteration += 1
                
                elapsed = time.time() - start_time
                # Subtract processing time from the target sleep duration
                sleep_time = max(0.01, UHF_SLEEP_SECONDS - elapsed)
                time.sleep(sleep_time)

            except KeyboardInterrupt:
                logger.info("Stopping...")
                self.running = False
            except Exception as e:
                logger.error(f"Loop Crash: {e}")
                time.sleep(1)

if __name__ == "__main__":
    bot = TradingBot()
    bot.run()
