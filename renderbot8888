import time
import subprocess
import json
import re
import pandas as pd
import numpy as np
import os
import sys 
from datetime import datetime, timedelta
from sklearn.ensemble import HistGradientBoostingClassifier
from sklearn.preprocessing import StandardScaler
from collections import deque

# --- CONFIGURATION & CONSTANTS ---
SYMBOL = "ATOMUSDT_PERP"
BASE_COIN = "ATOM"
MIN_QTY = 0.001
LEVERAGE = 100 
INTERVAL_SECONDS = 60 # Set to 1 minute (60 seconds) for signal generation
LOOKBACK_PERIOD = 300 
WINDOW_SIZE = 14 
VOLATILITY_WINDOW = 20 

# ML/Adaptive Parameters
MIN_TRAINING_SAMPLES = 50 
BASE_PROBABILITY_THRESHOLD = 0.55 

# Time-Based Stop Loss (T-SL)
MAX_HOLDING_PERIOD_MINUTES = 60 

# Paths
DASHBOARD_PATH = "/var/www/html/dashboard.html" 
WALLET_SCRIPT = "/wallet.sh"
COIN_INFO_SCRIPT = "/coinrealinfo.sh"
PLACE_ORDER_SCRIPT = "/placeorder.sh"
CLOSE_POSITIONS_SCRIPT = "/closepositions.sh"

# Global state variables (in-memory)
ml_model = None
scaler = None
initial_fit_done = False

# --- UTILITY & BASH FUNCTIONS (ADAPTED FOR YOUR SCRIPTS) ---

def run_bash_command(command, print_output=False):
    """Executes a bash command and returns the raw output string and success status."""
    try:
        # Check=True will raise CalledProcessError for non-zero exit codes
        result = subprocess.run(
            command, 
            shell=True,
            check=True, 
            capture_output=True, 
            text=True
        )
        output_str = result.stdout.strip()
        
        if print_output:
            print(f"Command Output ({command}):\n{output_str}\n---")
        
        return output_str, True 

    except subprocess.CalledProcessError as e:
        print(f"ERROR: Command execution failed. Command: '{command}'")
        print(f"Stdout: {e.stdout.strip()}")
        print(f"Stderr: {e.stderr.strip()}")
        return e.stdout.strip(), False
    except Exception as e:
        print(f"An unexpected error occurred in run_bash_command: {e}")
        return None, False

def get_current_state():
    """
    Fetches account balance, position details, and historical data.
    Uses custom shell scripts for real-time data.
    """
    
    # 1. Fetch wallet balance from /wallet.sh
    balance_output, success = run_bash_command(WALLET_SCRIPT, print_output=True) 
    wallet_balance = 0.0
    if success:
        try:
            # Assumes /wallet.sh outputs a single number (USDT balance)
            wallet_balance = float(balance_output.split()[0].replace(',', '').strip())
        except ValueError:
            print(f"FATAL: Could not parse wallet balance from '{balance_output}'. Using default 0.0.")

    # 2. Fetch position details and current prices from /coinrealinfo.sh
    coin_info_output, success = run_bash_command(f"{COIN_INFO_SCRIPT} {SYMBOL}", print_output=True)
    
    current_position = {'size': 0.0, 'side': 'NONE', 'entry_price': 0.0}
    bid_price = 0.0
    ask_price = 0.0
    
    if success and coin_info_output:
        # Define regex to extract key information
        # Note: Added parsing for Bid and Ask which were often missing in previous outputs
        size_match = re.search(r'Quantity:\s*([\d.]+)', coin_info_output)
        entry_match = re.search(r'Entry Price:\s*([\d.]+)', coin_info_output)
        bid_match = re.search(r'Bid:\s*([\d.]+)', coin_info_output)
        ask_match = re.search(r'Ask:\s*([\d.]+)', coin_info_output)
        
        if bid_match:
            bid_price = float(bid_match.group(1))
        if ask_match:
            ask_price = float(ask_match.group(1))

        if 'NO INFO' not in coin_info_output:
            # Position is open
            if size_match and entry_match:
                current_position['size'] = float(size_match.group(1))
                current_position['entry_price'] = float(entry_match.group(1))
                # The 'side' is tracked globally in 'main' after a successful trade execution.
                pass 

    # 3. Fetch historical data (assuming hitbtc get_history command still works for candles)
    history_output, hist_success = run_bash_command(f"hitbtc get_history {SYMBOL} 1m {LOOKBACK_PERIOD + 100}", print_output=True)
    historical_data = []
    if hist_success and isinstance(history_output, str):
        try:
             # Attempt to parse the string output as JSON
             history_json = json.loads(history_output)
             historical_data = history_json.get('result', []) if isinstance(history_json, dict) else []
        except json.JSONDecodeError:
            print("FATAL: Historical data command output was not valid JSON.")

    if not historical_data:
        # Fallback if historical data fetch failed
        if ask_price > 0:
            latest_price = ask_price # Use the real-time ask as a fallback
        else:
            # If no price is available, we can't continue the TA logic
            print("ERROR: Failed to fetch historical data and real-time prices are 0. Cannot generate DF.")
            df = pd.DataFrame()
            return wallet_balance, current_position, df, bid_price, ask_price
        
        # Create a single row DF based on the latest available price for prediction input
        df = pd.DataFrame([{
            'Close': latest_price, 'High': latest_price, 'Low': latest_price, 
            'Open': latest_price, 'Volume': 0.0
        }])
        
    else:
        # Process historical data
        df = pd.DataFrame(historical_data)
        df = df.rename(columns={'close': 'Close', 'high': 'High', 'low': 'Low', 'open': 'Open', 'volume': 'Volume'})
        for col in ['Close', 'High', 'Low', 'Open', 'Volume']:
            df[col] = pd.to_numeric(df[col], errors='coerce')
        
        df = df.dropna(subset=['Close', 'High', 'Low', 'Open', 'Volume'])
        df = df.iloc[::-1].reset_index(drop=True)
        df = df.iloc[-LOOKBACK_PERIOD:]

    return wallet_balance, current_position, df, bid_price, ask_price

def calculate_unrealized_pnl(position, bid_price, ask_price):
    """Calculates Unrealized PnL in decimal places."""
    pnl = 0.0
    size = position['size']
    entry = position['entry_price']
    side = position.get('side', 'NONE')

    if size > 0:
        if side == 'BUY':
            # Long position: PnL is (Bid Price - Entry Price) * Quantity. Use Bid price for exit valuation.
            pnl = (bid_price - entry) * size
        elif side == 'SELL':
            # Short position: PnL is (Entry Price - Ask Price) * Quantity. Use Ask price for exit valuation.
            pnl = (entry - ask_price) * size
            
    return pnl

def execute_trade(side, quantity, current_position):
    """Executes a trade using the custom shell script /placeorder.sh."""
    if quantity < MIN_QTY:
        print(f"Trade skipped: Quantity {quantity:.8f} is less than MIN_QTY {MIN_QTY}")
        return False, None

    # Determine if an opposing position exists and needs closing
    is_opposing_trade = (side == 'Buy' and current_position.get('side') == 'SELL') or \
                        (side == 'Sell' and current_position.get('side') == 'BUY')
    
    if current_position['size'] > 0 and current_position.get('side') != 'NONE' and is_opposing_trade:
        # Close existing position first
        print(f"Attempting to close existing {current_position.get('side')} position via {CLOSE_POSITIONS_SCRIPT}...")
        close_output, success = run_bash_command(CLOSE_POSITIONS_SCRIPT, print_output=True)
        if not success or 'SUCCESS' not in close_output.upper():
            print("Failed to close position. Aborting new trade.")
            return False, None
        time.sleep(1.0) # Give exchange time to process closure
        
    # Place new order
    quantity_str = f"{quantity:.8f}"
    order_command = f"{PLACE_ORDER_SCRIPT} {BASE_COIN} {quantity_str} {side}"
    print(f"Executing trade: {order_command}")
    
    order_output, success = run_bash_command(order_command, print_output=True)
    
    if success and 'SUCCESS' in order_output.upper():
        print("Order placement successful.")
        return True, side # Return success and the side placed
    else:
        print(f"Order placement failed. Output: {order_output}")
        return False, None

def close_all_positions_on_start():
    """Tries to close any open positions at bot start using /closepositions.sh."""
    print("Checking for and closing any residual open positions...")
    
    close_output, success = run_bash_command(CLOSE_POSITIONS_SCRIPT, print_output=True)
    
    if success and 'SUCCESS' in close_output.upper():
        print("Successfully sent close command for all positions.")
    else:
        print("Position closure script failed or returned error. Bot may start with an open position.")

# --- INDICATOR CALCULATION ---

def calculate_wilders_smoothing(series, period):
    return series.ewm(alpha=1/period, adjust=False).mean()

def calculate_advanced_indicators(historical_df):
    """Calculates technical indicators using vectorized operations."""
    df = historical_df.copy()
    window = WINDOW_SIZE
    vol_window = VOLATILITY_WINDOW

    # True Range (TR)
    df['High-Low'] = df['High'] - df['Low']
    df['High-PrevClose'] = abs(df['High'] - df['Close'].shift(1))
    df['Low-PrevClose'] = abs(df['Low'] - df['Close'].shift(1))
    df['TR'] = df[['High-Low', 'High-PrevClose', 'Low-PrevClose']].max(axis=1)

    # 1. Average True Range (ATR)
    df['ATR'] = calculate_wilders_smoothing(df['TR'], window)

    # 2. Relative Strength Index (RSI)
    df['Change'] = df['Close'].diff()
    df['Gain'] = np.where(df['Change'] > 0, df['Change'], 0)
    df['Loss'] = np.where(df['Change'] < 0, abs(df['Change']), 0)
    
    df['AvgGain'] = calculate_wilders_smoothing(df['Gain'], window)
    df['AvgLoss'] = calculate_wilders_smoothing(df['Loss'], window)
    
    df['RS'] = df['AvgGain'] / df['AvgLoss']
    df['RSI'] = 100 - (100 / (1 + df['RS']))

    # 3. Commodity Channel Index (CCI)
    TP = (df['High'] + df['Low'] + df['Close']) / 3
    df['SMA_TP'] = TP.rolling(window=window).mean()
    def mean_deviation(x):
        return np.mean(np.abs(x - np.mean(x)))
    df['MD'] = TP.rolling(window=window).apply(mean_deviation, raw=True)
    df['CCI'] = (TP - df['SMA_TP']) / (0.015 * df['MD'])

    # 4. Average Directional Index (ADX)
    df['+DM'] = np.where((df['High'] > df['High'].shift(1)) & (df['High'] - df['High'].shift(1) > df['Low'].shift(1) - df['Low']), df['High'] - df['High'].shift(1), 0)
    df['-DM'] = np.where((df['Low'].shift(1) > df['Low']) & (df['Low'].shift(1) - df['Low'] > df['High'] - df['High'].shift(1)), df['Low'].shift(1) - df['Low'], 0)
    
    df['+DI'] = calculate_wilders_smoothing(df['+DM'], window) / df['ATR'] * 100
    df['-DI'] = calculate_wilders_smoothing(df['+DI'], window) / df['ATR'] * 100 
    
    df['DX'] = abs(df['+DI'] - df['-DI']) / (df['+DI'] + df['-DI']) * 100
    df['ADX'] = calculate_wilders_smoothing(df['DX'], window)

    # 5. Rate of Change (ROC)
    df['ROC'] = df['Close'].pct_change(periods=window) * 100

    # 6. Negative Volume Index (NVI)
    nvi_series = np.full(len(df), 1000.0)
    
    for i in range(1, len(df)):
        if df['Volume'].iloc[i] < df['Volume'].iloc[i-1]:
            price_change_percent = (df['Close'].iloc[i] - df['Close'].iloc[i-1]) / df['Close'].iloc[i-1]
            nvi_series[i] = nvi_series[i-1] + (price_change_percent * nvi_series[i-1])
        else:
            nvi_series[i] = nvi_series[i-1]
            
    df['NVI'] = nvi_series
    
    # 7. Volatility (Log Returns Standard Deviation)
    df['Log_Returns'] = np.log(df['Close'] / df['Close'].shift(1))
    df['Volatility'] = df['Log_Returns'].rolling(window=vol_window).std() * np.sqrt(252)

    # Drop intermediate columns
    cols_to_drop = ['High-Low', 'High-PrevClose', 'Low-PrevClose', 'TR', 'Change', 'Gain', 'Loss', 
                    'AvgGain', 'AvgLoss', 'RS', 'SMA_TP', 'MD', '+DM', '-DM', '+DI', '-DI', 
                    'DX', 'Log_Returns']
    df = df.drop(columns=[col for col in cols_to_drop if col in df.columns], errors='ignore')
    
    df = df.dropna()
    
    return df

# --- MACHINE LEARNING & ADAPTIVE LOGIC ---

def create_target_variable(df):
    df['Target'] = np.where(df['Close'].shift(-1) > df['Close'], 1, 0)
    return df.dropna()

def get_feature_cols():
    return ['ATR', 'RSI', 'CCI', 'ADX', 'ROC', 'NVI', 'Volatility']

def setup_and_train_ml_model(historical_df):
    """
    Prepares data, trains the model, and updates the scaler if necessary.
    Uses global variables for ml_model, scaler, and initial_fit_done.
    """
    # FIX: Remove model, scaler, initial_fit_done from parameters to resolve SyntaxError.
    global ml_model, initial_fit_done, scaler 

    feature_cols = get_feature_cols()
    
    if len(historical_df) < MIN_TRAINING_SAMPLES:
        if len(historical_df) > 0 and not initial_fit_done:
             print("Warning: Insufficient historical data for full training. Skipping ML training.")
             return 0.5
        
        if len(historical_df) == 0:
            raise ValueError("Not enough data to train ML model.")

    train_df = historical_df.iloc[-MIN_TRAINING_SAMPLES:].copy()
    X_train = train_df[feature_cols]
    y_train = train_df['Target']

    if not initial_fit_done:
        scaler = StandardScaler()
        scaler.fit(X_train)
        initial_fit_done = True

    X_train_scaled = scaler.transform(X_train)
    ml_model = HistGradientBoostingClassifier(random_state=42, max_iter=100)
    ml_model.fit(X_train_scaled, y_train)
    accuracy = ml_model.score(X_train_scaled, y_train)
    
    return accuracy

def get_ml_prediction(historical_df):
    """
    Generates the probability prediction for the next bar.
    Uses global variables for ml_model and scaler.
    """
    # FIX: Remove model and scaler from parameters for consistency.
    global ml_model, scaler 
    
    if ml_model is None or scaler is None or len(historical_df) == 0:
        return 0.5, 0.5

    feature_cols = get_feature_cols()
    
    X_predict = historical_df.iloc[[-1]][feature_cols]
    
    # Ensure all required features are present
    if X_predict.shape[1] != len(feature_cols):
        print("Warning: Missing features for prediction. Using default 50/50 probability.")
        return 0.5, 0.5
        
    X_predict_scaled = scaler.transform(X_predict)

    proba = ml_model.predict_proba(X_predict_scaled)[0]
    prob_buy = proba[1]
    prob_sell = proba[0]
    
    return prob_buy, prob_sell

def calculate_adaptive_threshold(ml_accuracy, base_threshold):
    """Adjusts the probability threshold based on the model's performance."""
    accuracy_factor = (ml_accuracy - 0.5) * 0.5
    adaptive_threshold = max(0.51, base_threshold - accuracy_factor)
    return adaptive_threshold

def calculate_adaptive_risk(ml_accuracy, max_risk_percent=0.01):
    """Adjusts the risk percentage (trade size) based on model confidence."""
    min_risk = 0.0025
    if ml_accuracy < 0.5:
        return min_risk
        
    scale = (ml_accuracy - 0.5) * 2 
    adaptive_risk_percent = min_risk + (max_risk_percent - min_risk) * scale
    
    return adaptive_risk_percent

# --- DASHBOARD FUNCTIONS & HTML TEMPLATE ---

HTML_DASHBOARD_TEMPLATE = """
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="refresh" content="60"> <!-- Refresh every 60 seconds (1 minute) -->
    <title>AI-Driven Trading Bot Dashboard</title>
    <style>
        body {{
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #121212;
            color: #E0E0E0;
        }}
        .container {{
            max-width: 1000px;
            margin: auto;
            background-color: #1E1E1E;
            padding: 30px;
            border-radius: 16px;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.6);
        }}
        h1 {{
            color: #4CAF50;
            border-bottom: 3px solid #4CAF50;
            padding-bottom: 10px;
            margin-bottom: 25px;
            font-size: 2em;
        }}
        .metrics-grid {{
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 15px;
            margin-bottom: 30px;
        }}
        .metric-card {{
            background-color: #2A2A2A;
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.4);
        }}
        .label {{
            font-size: 0.8em;
            color: #9E9E9E;
            margin-bottom: 5px;
            text-transform: uppercase;
        }}
        .value {{
            font-size: 1.6em;
            font-weight: bold;
            color: #FFFFFF;
        }}
        .value.positive {{ color: #4CAF50; }}
        .value.negative {{ color: #F44336; }}
        .value.neutral {{ color: #FFEB3B; }}

        .price-grid {{
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-bottom: 25px;
        }}
        .price-card {{
            background-color: #333333;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
        }}
        
        .signal-grid {{
            display: flex;
            justify-content: space-around;
            text-align: center;
            margin-bottom: 30px;
        }}
        .signal {{
            flex: 1;
            padding: 20px;
            border-radius: 10px;
            margin: 0 8px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
        }}
        .buy {{ background-color: #1f3a2d; border: 1px solid #4CAF50; }}
        .sell {{ background-color: #3a1f1f; border: 1px solid #F44336; }}
        .signal .value {{ font-size: 2.2em; }}

        .position-status {{
            padding: 20px;
            border-radius: 12px;
            margin-top: 25px;
            font-size: 1.2em;
            font-weight: bold;
            text-align: center;
        }}
        .status-BUY {{ background-color: #2E7D32; color: #fff; }}
        .status-SELL {{ background-color: #D32F2F; color: #fff; }}
        .status-NONE {{ background-color: #546E7A; color: #fff; }}
    </style>
</head>
<body>
    <div class="container">
        <h1>Adaptive AI Trading Bot: {SYMBOL}</h1>
        
        <div class="price-grid">
            <div class="price-card">
                <div class="label">Bid Price (Liquidation/Sell Exit)</div>
                <div class="value">{BID_PRICE}</div>
            </div>
            <div class="price-card">
                <div class="label">Ask Price (Entry/Buy Exit)</div>
                <div class="value">{ASK_PRICE}</div>
            </div>
        </div>
        
        <div class="position-status status-{POSITION_SIDE_UPPER}">
            <div style="font-size: 0.7em; color: #E0E0E0;">Position Details:</div>
            CURRENT POSITION: {POSITION_SIDE} ({POSITION_SIZE} {BASE_COIN}) 
            <br>
            Entry Price: ${ENTRY_PRICE} | Unrealized PnL: <span class="value {PNL_CLASS}">{UNREALIZED_PNL_USD}</span>
            <br>
            {POSITION_ENTRY_TIME_MSG}
        </div>

        <h2>AI Strategy & Risk</h2>
        <div class="metrics-grid">
            <div class="metric-card">
                <div class="label">USDT Balance (Real)</div>
                <div class="value">${WALLET_BALANCE}</div>
            </div>
            <div class="metric-card">
                <div class="label">ML Accuracy (Train)</div>
                <div class="value">{ML_ACCURACY}</div>
            </div>
            <div class="metric-card">
                <div class="label">Adaptive Threshold</div>
                <div class="value">{ADAPTIVE_THRESHOLD}</div>
            </div>
            <div class="metric-card">
                <div class="label">Adaptive Risk %</div>
                <div class="value">{ADAPTIVE_RISK_PERCENT}</div>
            </div>
        </div>

        <div class="signal-grid">
            <div class="signal buy">
                <div class="label">LONG PROBABILITY</div>
                <div class="value">{PROB_BUY}</div>
            </div>
            <div class="signal sell">
                <div class="label">SHORT PROBABILITY</div>
                <div class="value">{PROB_SELL}</div>
            </div>
        </div>

        <h2>Execution & Performance</h2>
        <div class="metrics-grid">
            <div class="metric-card">
                <div class="label">Trade Interval</div>
                <div class="value">{INTERVAL_SECONDS}s</div>
            </div>
            <div class="metric-card">
                <div class="label">Last Cycle Time</div>
                <div class="value">{LAST_CYCLE_TIME}s</div>
            </div>
        </div>
        <p style="text-align: center; font-size: 0.7em; color: #666; margin-top: 30px;">
            Last Updated: {CURRENT_TIME} (Refreshes every {INTERVAL_SECONDS} seconds)
        </p>
    </div>
</body>
</html>
"""

def update_dashboard(
    wallet_balance, 
    current_position, 
    prob_buy, 
    prob_sell, 
    ml_accuracy, 
    adaptive_threshold, 
    adaptive_risk_percent,
    position_entry_time,
    bid_price,
    ask_price,
    unrealized_pnl,
    last_cycle_time
):
    """Generates the HTML dashboard and saves it to the specified path."""
    
    # Format metrics
    position_size = f"{current_position.get('size', 0.0):.8f}"
    position_side = current_position.get('side', 'NONE').upper()
    position_side_upper = position_side if position_side in ['BUY', 'SELL'] else 'NONE'
    entry_price = f"{current_position.get('entry_price', 0.0):.8f}"
    
    # PnL Formatting
    unrealized_pnl_usd = f"{unrealized_pnl:,.4f} USDT"
    pnl_class = 'neutral'
    if unrealized_pnl > 0.0001:
        pnl_class = 'positive'
    elif unrealized_pnl < -0.0001:
        pnl_class = 'negative'

    # Format entry time message
    position_entry_time_msg = "No Open Position Duration"
    if current_position.get('size', 0) > 0 and position_entry_time:
        duration = datetime.now() - position_entry_time
        total_seconds = int(duration.total_seconds())
        hours, remainder = divmod(total_seconds, 3600)
        minutes, seconds = divmod(remainder, 60)
        
        position_entry_time_msg = f"Duration: {hours:02d}h {minutes:02d}m {seconds:02d}s"

    
    # Fill template variables
    html_content = HTML_DASHBOARD_TEMPLATE.format(
        SYMBOL=SYMBOL,
        BASE_COIN=BASE_COIN,
        WALLET_BALANCE=f"{wallet_balance:,.2f}",
        BID_PRICE=f"{bid_price:,.8f}",
        ASK_PRICE=f"{ask_price:,.8f}",
        ENTRY_PRICE=entry_price,
        UNREALIZED_PNL_USD=unrealized_pnl_usd,
        PNL_CLASS=pnl_class,
        ML_ACCURACY=f"{ml_accuracy:.2%}",
        ADAPTIVE_THRESHOLD=f"{adaptive_threshold:.4f}",
        ADAPTIVE_RISK_PERCENT=f"{adaptive_risk_percent:.2%}",
        PROB_BUY=f"{prob_buy:.4f}",
        PROB_SELL=f"{prob_sell:.4f}",
        POSITION_SIDE=position_side,
        POSITION_SIDE_UPPER=position_side_upper,
        POSITION_SIZE=position_size,
        POSITION_ENTRY_TIME_MSG=position_entry_time_msg,
        INTERVAL_SECONDS=INTERVAL_SECONDS,
        LAST_CYCLE_TIME=f"{last_cycle_time:.2f}",
        CURRENT_TIME=datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    )

    # Robustly write to file (Check permissions)
    try:
        # Ensure the directory exists
        os.makedirs(os.path.dirname(DASHBOARD_PATH) or '.', exist_ok=True)
        with open(DASHBOARD_PATH, "w") as f:
            f.write(html_content)
        print(f"Dashboard successfully updated to {DASHBOARD_PATH}")
    except Exception as e:
        print(f"CRITICAL ERROR: Could not write dashboard to {DASHBOARD_PATH}. Check path and permissions. Error: {e}")

# --- MAIN BOT LOGIC ---

def main():
    global ml_model, scaler, initial_fit_done

    # State variables for dashboard and trade tracking
    position_entry_time = None 
    
    # Initialize dashboard variables (used for dashboard update on first cycle)
    wallet_balance = 0.0
    current_position = {'size': 0.0, 'side': 'NONE', 'entry_price': 0.0}
    bid_price = 0.0
    ask_price = 0.0
    ml_accuracy = 0.5
    prob_buy = 0.5
    prob_sell = 0.5
    adaptive_threshold = BASE_PROBABILITY_THRESHOLD
    adaptive_risk_percent = calculate_adaptive_risk(ml_accuracy)
    unrealized_pnl = 0.0
    last_cycle_time = 0.0
    
    # --- Initial Setup ---
    try:
        # Initial fetch to get data for ML training
        wallet_balance, current_position, historical_df, bid_price, ask_price = get_current_state()
        
        # Initial position 'side' must be inferred or manually set if position exists on start
        if current_position['size'] > 0:
            print("WARNING: Existing position detected. Setting side to BUY placeholder.")
            current_position['side'] = 'BUY' 
            position_entry_time = datetime.now() # Assume current time as entry time
            
        if historical_df.empty:
            print("FATAL: Cannot initialize due to empty historical data DataFrame.")
            sys.exit(1)

        historical_df = create_target_variable(historical_df)
        historical_df = calculate_advanced_indicators(historical_df)
        
        # Train model for the first time
        # FIX: Pass only historical_df, as globals are accessed directly inside the function
        ml_accuracy = setup_and_train_ml_model(historical_df)
        print("Initial ML model trained successfully.")
    except Exception as e:
        print(f"FATAL: Initial setup failed. Ensure all custom scripts are executable and return expected data. Error: {e}")
        sys.exit(1)


    while True:
        start_time = time.time()
        elapsed = 0.0

        try:
            # 1. Get current market and account state
            wallet_balance, current_position_new, historical_df, bid_price, ask_price = get_current_state()
            
            # Preserve 'side' and 'entry_time' if position is still open, otherwise reset
            if current_position_new['size'] > 0:
                # If size > 0, update size/entry_price but keep the currently tracked side
                current_position.update({
                    'size': current_position_new['size'], 
                    'entry_price': current_position_new['entry_price']
                })
                
                # If side is still 'NONE' but size is positive, assume BUY as a fail-safe
                if current_position['side'] == 'NONE':
                    current_position['side'] = 'BUY' 
                    if position_entry_time is None:
                        position_entry_time = datetime.now()

            else:
                 # Position closed or never opened
                 current_position = {'size': 0.0, 'side': 'NONE', 'entry_price': 0.0}
                 position_entry_time = None


            # 2. Update Data and Indicators
            if historical_df.empty:
                 print("ERROR: Historical data is empty, skipping cycle.")
                 raise Exception("Empty historical data.")
                 
            historical_df = create_target_variable(historical_df)
            historical_df = calculate_advanced_indicators(historical_df)
            
            # 3. Retrain ML Model (for adaptive learning)
            # FIX: Pass only historical_df
            ml_accuracy = setup_and_train_ml_model(historical_df)

            # 4. Get Prediction
            # FIX: Pass only historical_df
            prob_buy, prob_sell = get_ml_prediction(historical_df)
            
            # 5. Adaptive Strategy
            adaptive_threshold = calculate_adaptive_threshold(ml_accuracy, BASE_PROBABILITY_THRESHOLD)
            adaptive_risk_percent = calculate_adaptive_risk(ml_accuracy)
            
            # 6. PnL and Position Management

            unrealized_pnl = calculate_unrealized_pnl(current_position, bid_price, ask_price)
            print(f"Unrealized PnL: {unrealized_pnl:.4f} USDT")

            # T-SL check
            if current_position['size'] > 0 and position_entry_time:
                holding_duration = datetime.now() - position_entry_time
                if holding_duration.total_seconds() > MAX_HOLDING_PERIOD_MINUTES * 60:
                    print(f"T-SL triggered: Held for over {MAX_HOLDING_PERIOD_MINUTES}m. Closing position via {CLOSE_POSITIONS_SCRIPT}.")
                    
                    # Execute closure
                    run_bash_command(CLOSE_POSITIONS_SCRIPT)
                    
                    # Reset position tracking
                    current_position['size'] = 0.0
                    current_position['side'] = 'NONE'
                    position_entry_time = None
                    print("T-SL executed. Position closed.")
            
            # Trade Signal Generation
            trade_action = 'HOLD'
            trade_side = None
            
            if prob_buy >= adaptive_threshold and prob_buy > prob_sell:
                trade_action = 'OPEN_LONG'
                trade_side = 'Buy'
            elif prob_sell >= adaptive_threshold and prob_sell > prob_buy:
                trade_action = 'OPEN_SHORT'
                trade_side = 'Sell'
            
            
            if trade_action != 'HOLD':
                # Use Ask for Long entry, Bid for Short entry (conservative entry)
                current_market_price = ask_price if trade_side == 'Buy' else bid_price
                
                if current_market_price == 0.0:
                    print("HOLD: Market price is zero. Cannot execute trade.")
                else:
                    risk_amount = wallet_balance * adaptive_risk_percent
                    # Calculate quantity based on risk and leverage
                    quantity_to_trade = (risk_amount * LEVERAGE) / current_market_price
                    
                    if quantity_to_trade >= MIN_QTY:
                        msg = f"SIGNAL: {trade_action} ({trade_side}). Prob: {prob_buy:.4f}/{prob_sell:.4f}. Qty: {quantity_to_trade:.8f}"
                        print(msg)
                        
                        success, executed_side = execute_trade(trade_side, quantity_to_trade, current_position)
                        
                        if success:
                             # Position details and entry time are set ONLY if trade is successful
                             
                             # Wait a moment and re-fetch real info to update current_position details
                             time.sleep(1.0) 
                             # Re-fetch the *size* and *entry_price* from the script output after the trade
                             _, current_position_info, _, _, _ = get_current_state()
                             
                             current_position.update({
                                 'size': current_position_info.get('size', 0.0),
                                 'entry_price': current_position_info.get('entry_price', 0.0),
                                 'side': executed_side.upper() # Update the side to the executed side
                             })
                             
                             print(f"Trade successful. New position: {current_position}")
                             position_entry_time = datetime.now() 
                             
                        else:
                            print("Trade execution failed. Continuing...")
                            
                    else:
                        print(f"HOLD: Calculated quantity {quantity_to_trade:.8f} is too small.")
            else:
                print("HOLD: No high-confidence signal.")

        except Exception as e:
            import traceback
            print(f"ERROR: Cycle failed due to exception: {e}")
            traceback.print_exc()

        # 7. Update Dashboard (always run, even on error)
        end_time = time.time()
        elapsed = end_time - start_time
        last_cycle_time = elapsed # Use 'elapsed' as the 'last_cycle_time'
        
        update_dashboard(
            wallet_balance, 
            current_position, 
            prob_buy, 
            prob_sell, 
            ml_accuracy, 
            adaptive_threshold, 
            adaptive_risk_percent,
            position_entry_time,
            bid_price,
            ask_price,
            unrealized_pnl,
            last_cycle_time
        )

        # 8. Wait for next cycle
        sleep_duration = max(0, INTERVAL_SECONDS - elapsed)
        print(f"Cycle finished in {elapsed:.2f}s. Sleeping for {sleep_duration:.2f}s.")
        time.sleep(sleep_duration)

if __name__ == '__main__':
    # Initial setup before the main loop starts
    close_all_positions_on_start()
    
    # Run the main bot logic
    try:
        main()
    except KeyboardInterrupt:
        print("\nBot stopped by user (KeyboardInterrupt).")
    except Exception as e:
        print(f"\nCRITICAL BOT FAILURE: {e}")
        time.sleep(5) # Wait before exiting to allow console visibility
