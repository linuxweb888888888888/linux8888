import ccxt
import time
import subprocess
import pandas as pd
import numpy as np
import os
import re
import logging
from datetime import datetime
from sklearn.ensemble import RandomForestRegressor
from sklearn.preprocessing import StandardScaler
from collections import deque

# ------------------------------------------------------------------------------
# CONFIGURATION
# ------------------------------------------------------------------------------
SYMBOL_CCXT = 'ATOM/USDT'      # For CCXT Fetching
SYMBOL_BASH = 'ATOMUSDT_PERP'  # For Bash Scripts
BASE_COIN = 'ATOM'             # For placeorder arguments
MIN_QTY = 0.001                # Minimum step size
DASHBOARD_PATH = '/var/www/html/dashboard.html'
MAX_HISTORY = 200              # Data points for ML training
TRAINING_INTERVAL = 5          # Retrain model frequently (Aggressive)
FEE_RATE = 0.0006              # Est. Taker fee (0.06%)
PROFIT_TARGET_PCT = 0.002      # 0.2% Target per scalp
GRID_STEP_PCT = 0.005          # Add to position if price moves 0.5% against

# ------------------------------------------------------------------------------
# LOGGING SETUP
# ------------------------------------------------------------------------------
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger()

# ------------------------------------------------------------------------------
# SYSTEM INTERFACE (Bash Scripts)
# ------------------------------------------------------------------------------
class SystemInterface:
    @staticmethod
    def run_command(command_list):
        try:
            result = subprocess.run(command_list, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, timeout=5)
            return result.stdout.strip()
        except Exception as e:
            logger.error(f"Command failed: {command_list} | Error: {e}")
            return None

    @staticmethod
    def get_wallet_balance():
        """Reads USDT balance from /wallet.sh. First line is USDT."""
        output = SystemInterface.run_command(['bash', '/wallet.sh'])
        if output:
            try:
                lines = output.split('\n')
                balance = float(lines[0].strip())
                return balance
            except ValueError:
                logger.error("Could not parse wallet balance.")
        return 0.0

    @staticmethod
    def get_real_position(symbol_bash):
        """Parses /coinrealinfo.sh output."""
        output = SystemInterface.run_command(['bash', '/coinrealinfo.sh', symbol_bash])
        
        data = {
            'symbol': symbol_bash,
            'qty': 0.0,
            'entry_price': 0.0,
            'has_position': False
        }

        if not output or "NO INFO" in output or output == "":
            return data

        try:
            qty_match = re.search(r'Quantity:\s*([\d\.-]+)', output)
            entry_match = re.search(r'Entry Price:\s*([\d\.-]+)', output)

            if qty_match:
                data['qty'] = float(qty_match.group(1))
            if entry_match:
                data['entry_price'] = float(entry_match.group(1))
            
            if abs(data['qty']) > 0:
                data['has_position'] = True
                
        except Exception as e:
            logger.error(f"Error parsing coin info: {e}")

        return data

    @staticmethod
    def place_order(coin_base, qty, side):
        """
        Executes /placeorder.sh (base) (qty) (side)
        """
        cmd = ['bash', '/placeorder.sh', coin_base, str(qty), side]
        output = SystemInterface.run_command(cmd)
        if output and "SUCCESS" in output:
            logger.info(f"Order SUCCESS: {side} {qty} {coin_base}")
            return True
        else:
            logger.error(f"Order ERROR: {output}")
            return False

    @staticmethod
    def close_all_positions():
        """Runs /closepositions.sh"""
        output = SystemInterface.run_command(['bash', '/closepositions.sh'])
        logger.info(f"Close Positions: {output}")
        return output

# ------------------------------------------------------------------------------
# WALLET LEARNER
# ------------------------------------------------------------------------------
class WalletLearner:
    def __init__(self):
        self.initial_balance = 0.0
        self.current_balance = 0.0
        self.previous_balance = 0.0
        self.trade_history = deque(maxlen=50) # Track recent balance changes
        self.dynamic_threshold = 55.0 # Starting confidence threshold
        self.risk_multiplier = 0.98 # Start with 98% usage

    def update_balance(self, new_balance):
        if self.initial_balance == 0:
            self.initial_balance = new_balance
            self.current_balance = new_balance
            self.previous_balance = new_balance
            return

        self.previous_balance = self.current_balance
        self.current_balance = new_balance
        
        delta = self.current_balance - self.previous_balance
        
        if abs(delta) > 0.0001: # Ignore tiny fluctuations
            self.trade_history.append(delta)
            self.adapt_strategy(delta)

    def adapt_strategy(self, delta):
        """
        Learns from wallet changes to adjust Risk and Confidence.
        Goal: Increase USDT.
        """
        # If we just made money (delta > 0)
        if delta > 0:
            # We are winning. We can afford to be slightly looser with entry to catch more trades
            # But keep risk high to compound.
            self.dynamic_threshold = max(50.0, self.dynamic_threshold - 0.5)
            self.risk_multiplier = min(0.99, self.risk_multiplier + 0.01) # Increase usage
            logger.info(f"PROFIT DETECTED: (+{delta:.4f}) -> Loosening Threshold to {self.dynamic_threshold}")
            
        # If we lost money (delta < 0)
        else:
            # We are losing. Tighten up. Require higher confidence.
            self.dynamic_threshold = min(75.0, self.dynamic_threshold + 1.0)
            # Do not reduce risk multiplier too much, we need to recover, but maybe slightly safer
            self.risk_multiplier = max(0.90, self.risk_multiplier - 0.02)
            logger.info(f"LOSS DETECTED: ({delta:.4f}) -> Tightening Threshold to {self.dynamic_threshold}")

    def get_growth_pct(self):
        if self.initial_balance == 0: return 0.0
        return ((self.current_balance - self.initial_balance) / self.initial_balance) * 100

# ------------------------------------------------------------------------------
# AI & MARKET DATA ENGINE
# ------------------------------------------------------------------------------
class AIEngine:
    def __init__(self):
        self.exchange = ccxt.hitbtc({'enableRateLimit': True})
        self.history = pd.DataFrame()
        self.model = RandomForestRegressor(n_estimators=50, max_depth=7, random_state=42)
        self.scaler = StandardScaler()
        self.is_trained = False
        self.simulation_wins = 0
        self.simulation_total = 0
        self.last_prediction = 0.0
        self.confidence = 0.0

    def fetch_price(self):
        try:
            ticker = self.exchange.fetch_ticker(SYMBOL_CCXT)
            return {
                'bid': ticker['bid'],
                'ask': ticker['ask'],
                'last': ticker['last'],
                'timestamp': datetime.now()
            }
        except Exception as e:
            logger.error(f"CCXT Error: {e}")
            return None

    def update_data(self, price_data):
        new_row = pd.DataFrame([price_data])
        if self.history.empty:
            self.history = new_row
        else:
            self.history = pd.concat([self.history, new_row], ignore_index=True)
        
        if len(self.history) > MAX_HISTORY:
            self.history = self.history.iloc[-MAX_HISTORY:]

    def calculate_features(self, df):
        df = df.copy()
        df['returns'] = df['last'].pct_change()
        
        # Fast RSI
        delta = df['last'].diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=7).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=7).mean()
        rs = gain / loss
        df['rsi'] = 100 - (100 / (1 + rs))
        
        # Volatility
        df['volatility'] = df['returns'].rolling(window=5).std()
        
        # Momentum
        df['momentum'] = df['last'] - df['last'].shift(3)

        # Spread
        df['spread'] = df['ask'] - df['bid']
        
        # Target: Immediate next tick direction
        df['target'] = df['last'].shift(-1) - df['last']
        
        df = df.dropna()
        return df

    def train_and_predict(self):
        if len(self.history) < 20:
            return 0, 0 

        df = self.calculate_features(self.history)
        
        if df.empty:
            return 0, 0

        feature_cols = ['rsi', 'volatility', 'spread', 'momentum']
        X = df[feature_cols]
        y = df['target']

        # Simulation Tracking
        if self.is_trained:
            actual_move = df.iloc[-1]['target'] if not pd.isna(df.iloc[-1]['target']) else 0
            if (self.last_prediction > 0 and actual_move > 0) or (self.last_prediction < 0 and actual_move < 0):
                self.simulation_wins += 1
            self.simulation_total += 1

        try:
            self.model.fit(X, y)
            self.is_trained = True
        except Exception as e:
            return 0, 0

        current_features = X.iloc[[-1]]
        prediction = self.model.predict(current_features)[0]
        
        avg_vol = df['volatility'].mean()
        confidence = min(abs(prediction) / (avg_vol + 1e-9), 1.0) * 100
        
        self.last_prediction = prediction
        self.confidence = confidence
        
        return prediction, confidence

# ------------------------------------------------------------------------------
# MAIN BOT LOGIC
# ------------------------------------------------------------------------------
class TradingBot:
    def __init__(self):
        self.sys = SystemInterface()
        self.ai = AIEngine()
        self.wallet_learner = WalletLearner()
        self.running = True
        self.iteration = 0

    def generate_dashboard(self, wallet, position, price_info, prediction, confidence, action_msg):
        unrealized_pnl = 0.0
        pnl_class = "neutral"
        
        if position['has_position']:
            qty = position['qty']
            entry = position['entry_price']
            curr_price = price_info['bid'] if qty > 0 else price_info['ask']
            
            if qty > 0: unrealized_pnl = (curr_price - entry) * qty
            else: unrealized_pnl = (entry - curr_price) * abs(qty)
                
            if unrealized_pnl > 0: pnl_class = "success"
            elif unrealized_pnl < 0: pnl_class = "danger"

        sim_acc = 0
        if self.ai.simulation_total > 0:
            sim_acc = (self.ai.simulation_wins / self.ai.simulation_total) * 100
            
        growth_pct = self.wallet_learner.get_growth_pct()
        growth_class = "success-text" if growth_pct >= 0 else "danger-text"

        html = f"""
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta http-equiv="refresh" content="1">
            <title>HitBTC SMART WALLET BOT</title>
            <style>
                body {{ font-family: 'Roboto', sans-serif; background-color: #000000; color: #e0e0e0; margin: 0; padding: 20px; }}
                .container {{ display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; }}
                .card {{ background-color: #121212; border-radius: 8px; padding: 20px; border: 1px solid #333; }}
                .card.success {{ border-color: #00ff00; background-color: #051a05; }}
                .card.danger {{ border-color: #ff0000; background-color: #1a0505; }}
                .card.info {{ border-color: #0088ff; }}
                h2 {{ margin-top: 0; font-size: 1.2rem; color: #888; }}
                .value {{ font-size: 2.5rem; font-weight: 900; }}
                .sub {{ font-size: 0.9rem; color: #666; }}
                .success-text {{ color: #00ff00; }}
                .danger-text {{ color: #ff0000; }}
                .status-bar {{ background: #222; padding: 15px; margin-bottom: 20px; border-radius: 4px; border-bottom: 2px solid #0088ff; }}
            </style>
        </head>
        <body>
            <div class="status-bar">
                <strong>STATUS:</strong> {action_msg} | <strong>MODE:</strong> {self.wallet_learner.risk_multiplier*100:.0f}% Usage
            </div>
            <div class="container">
                <div class="card info">
                    <h2>WALLET (SMART LEARNING)</h2>
                    <div class="value">${wallet:.2f}</div>
                    <div class="sub">Growth: <span class="{growth_class}">{growth_pct:.2f}%</span></div>
                    <div class="sub">Dynamic Threshold: {self.wallet_learner.dynamic_threshold:.1f}%</div>
                </div>
                <div class="card {pnl_class}">
                    <h2>ACTIVE PNL</h2>
                    <div class="value" style="color: {'#00ff00' if unrealized_pnl > 0 else '#ff0000'}">{unrealized_pnl:.4f}</div>
                    <div class="sub">Entry: {position['entry_price']} | Qty: {position['qty']}</div>
                </div>
                <div class="card info">
                    <h2>AI SIGNAL</h2>
                    <div class="value">{'BUY' if prediction > 0 else 'SELL'}</div>
                    <div class="sub">Conf: {confidence:.1f}% | Acc: {sim_acc:.1f}%</div>
                </div>
            </div>
        </body>
        </html>
        """
        try:
            with open(DASHBOARD_PATH, 'w') as f:
                f.write(html)
        except Exception as e:
            logger.error(f"Failed to write dashboard: {e}")

    def run(self):
        logger.info("Starting SMART WALLET LEARNING Bot...")
        self.sys.close_all_positions()
        
        # Initial Wallet Read
        initial_wallet = self.sys.get_wallet_balance()
        self.wallet_learner.update_balance(initial_wallet)
        
        while self.running:
            try:
                action_log = "Scanning..."
                wallet = self.sys.get_wallet_balance()
                
                # Update Learning (Detect changes in balance from closed trades)
                self.wallet_learner.update_balance(wallet)
                
                pos_data = self.sys.get_real_position(SYMBOL_BASH)
                price_data = self.ai.fetch_price()
                
                if not price_data:
                    time.sleep(0.5)
                    continue

                self.ai.update_data(price_data)
                prediction, confidence = self.ai.train_and_predict()
                
                # ---------------------------------------------------------
                # CASE A: HAS POSITION -> MANAGE, PYRAMID, OR CLOSE
                # ---------------------------------------------------------
                if pos_data['has_position']:
                    qty = pos_data['qty']
                    entry = pos_data['entry_price']
                    is_long = qty > 0
                    
                    # Calculate Real PnL
                    current_pnl = 0
                    price_diff_pct = 0
                    
                    if is_long:
                        current_pnl = (price_data['bid'] - entry) * abs(qty)
                        price_diff_pct = (price_data['last'] - entry) / entry
                    else:
                        current_pnl = (entry - price_data['ask']) * abs(qty)
                        price_diff_pct = (entry - price_data['last']) / entry

                    total_fee = (entry * abs(qty) * FEE_RATE) + (price_data['last'] * abs(qty) * FEE_RATE)
                    net_pnl = current_pnl - total_fee

                    action_log = f"PnL: {net_pnl:.4f}"

                    # 1. TAKE PROFIT (Strict PnL > Fee)
                    if net_pnl > 0 and net_pnl > (total_fee * 1.2): # Slightly higher buffer
                        logger.info(f"$$$ PROFIT CLOSE: {net_pnl:.6f}")
                        side = 'sell' if is_long else 'buy'
                        self.sys.place_order(BASE_COIN, abs(qty), side)
                        action_log = "CLOSING PROFIT"

                    # 2. PYRAMIDING (Adding to winners to MAXIMIZE USDT)
                    # If we are winning, trending, and have wallet space -> ADD
                    elif net_pnl > (total_fee * 0.5) and confidence > self.wallet_learner.dynamic_threshold:
                         # Use remaining wallet to compound
                        usable_wallet = wallet * self.wallet_learner.risk_multiplier
                        # Subtract estimated current position value to find free margin
                        current_pos_val = abs(qty) * price_data['last']
                        free_margin = usable_wallet - current_pos_val
                        
                        if free_margin > (price_data['last'] * MIN_QTY):
                            if (is_long and prediction > 0) or (not is_long and prediction < 0):
                                logger.info("PYRAMIDING (Adding to winner)")
                                add_qty = free_margin / price_data['last']
                                add_qty = max(MIN_QTY, round(add_qty, 3))
                                side = 'buy' if is_long else 'sell'
                                self.sys.place_order(BASE_COIN, add_qty, side)
                                action_log = "MAXIMIZING PROFIT"
                    
                    # 3. GRID RECOVERY (If losing)
                    elif price_diff_pct < -GRID_STEP_PCT:
                        usable_wallet = wallet * self.wallet_learner.risk_multiplier
                        # Note: In cross margin, wallet is shared. 
                        # Just try to add a step to lower entry price
                        cost_min = price_data['last'] * MIN_QTY
                        if wallet > cost_min: # Check raw wallet for recovery
                            if (is_long and prediction > 0) or (not is_long and prediction < 0):
                                logger.info("Grid Recovery Addition")
                                # Add modest amount to fix entry, not full all-in to avoid liquidation risk
                                recovery_qty = MIN_QTY * 2 
                                side = 'buy' if is_long else 'sell'
                                self.sys.place_order(BASE_COIN, recovery_qty, side)
                                action_log = "GRID RECOVERY"

                # ---------------------------------------------------------
                # CASE B: NO POSITION -> OPEN SMART
                # ---------------------------------------------------------
                else:
                    # Use Dynamic Threshold learned from Wallet Performance
                    if self.ai.is_trained and confidence > self.wallet_learner.dynamic_threshold: 
                        
                        # SMART WALLET USAGE
                        # Usage % adapts based on winning/losing streak
                        max_usd_to_use = wallet * self.wallet_learner.risk_multiplier
                        
                        if max_usd_to_use > (price_data['last'] * MIN_QTY):
                            calc_qty = max_usd_to_use / price_data['last']
                            trade_qty = max(MIN_QTY, round(calc_qty, 3))
                            
                            if prediction > 0:
                                self.sys.place_order(BASE_COIN, trade_qty, 'buy')
                                action_log = "SMART ENTRY LONG"
                            elif prediction < 0:
                                self.sys.place_order(BASE_COIN, trade_qty, 'sell')
                                action_log = "SMART ENTRY SHORT"

                self.generate_dashboard(wallet, pos_data, price_data, prediction, confidence, action_log)
                self.iteration += 1
                time.sleep(0.1)

            except KeyboardInterrupt:
                self.running = False
            except Exception as e:
                logger.error(f"Loop Error: {e}")
                time.sleep(1)

if __name__ == "__main__":
    bot = TradingBot()
    bot.run()
