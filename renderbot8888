import ccxt
import time
import subprocess
import pandas as pd
import numpy as np
import os
import re
import logging
from datetime import datetime
from sklearn.ensemble import RandomForestRegressor
from sklearn.preprocessing import StandardScaler
from collections import deque

# ------------------------------------------------------------------------------
# CONFIGURATION
# ------------------------------------------------------------------------------
SYMBOL_CCXT = 'ATOM/USDT'      # For CCXT Fetching
SYMBOL_BASH = 'ATOMUSDT_PERP'  # For Bash Scripts
BASE_COIN = 'ATOM'             # For placeorder arguments
MIN_QTY = 0.001                # Minimum step size
DASHBOARD_PATH = '/var/www/html/dashboard.html'
MAX_HISTORY = 200              # Data points for ML training
TRAINING_INTERVAL = 10         # Retrain model every X iterations
FEE_RATE = 0.0006              # Est. Taker fee (0.06%) - adjust as needed
PROFIT_TARGET_PCT = 0.002      # 0.2% Target per scalp
GRID_STEP_PCT = 0.005          # Add to position if price moves 0.5% against

# ------------------------------------------------------------------------------
# LOGGING SETUP
# ------------------------------------------------------------------------------
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger()

# ------------------------------------------------------------------------------
# SYSTEM INTERFACE (Bash Scripts)
# ------------------------------------------------------------------------------
class SystemInterface:
    @staticmethod
    def run_command(command_list):
        try:
            result = subprocess.run(command_list, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, timeout=10)
            return result.stdout.strip()
        except Exception as e:
            logger.error(f"Command failed: {command_list} | Error: {e}")
            return None

    @staticmethod
    def get_wallet_balance():
        """Reads USDT balance from /wallet.sh. First line is USDT."""
        output = SystemInterface.run_command(['bash', '/wallet.sh'])
        if output:
            try:
                # Assuming first line is just the number, e.g., "104.50"
                lines = output.split('\n')
                balance = float(lines[0].strip())
                return balance
            except ValueError:
                logger.error("Could not parse wallet balance.")
        return 0.0

    @staticmethod
    def get_real_position(symbol_bash):
        """Parses /coinrealinfo.sh output."""
        output = SystemInterface.run_command(['bash', '/coinrealinfo.sh', symbol_bash])
        
        data = {
            'symbol': symbol_bash,
            'qty': 0.0,
            'entry_price': 0.0,
            'has_position': False
        }

        if not output or "NO INFO" in output or output == "":
            return data

        try:
            # Regex to extract values
            # Expected: Symbol: "COINUSDT_PERP"\nQuantity: 1000\nEntry Price: 0.000009025
            qty_match = re.search(r'Quantity:\s*([\d\.-]+)', output)
            entry_match = re.search(r'Entry Price:\s*([\d\.-]+)', output)

            if qty_match:
                data['qty'] = float(qty_match.group(1))
            if entry_match:
                data['entry_price'] = float(entry_match.group(1))
            
            if abs(data['qty']) > 0:
                data['has_position'] = True
                
        except Exception as e:
            logger.error(f"Error parsing coin info: {e}")

        return data

    @staticmethod
    def place_order(coin_base, qty, side):
        """
        Executes /placeorder.sh (base) (qty) (side)
        Side must be 'buy' or 'sell'.
        Returns True if 'SUCCESS' in output.
        """
        cmd = ['bash', '/placeorder.sh', coin_base, str(qty), side]
        output = SystemInterface.run_command(cmd)
        if output and "SUCCESS" in output:
            logger.info(f"Order SUCCESS: {side} {qty} {coin_base}")
            return True
        else:
            logger.error(f"Order ERROR: {output}")
            return False

    @staticmethod
    def close_all_positions():
        """Runs /closepositions.sh"""
        output = SystemInterface.run_command(['bash', '/closepositions.sh'])
        logger.info(f"Close Positions: {output}")
        return output

# ------------------------------------------------------------------------------
# AI & MARKET DATA ENGINE
# ------------------------------------------------------------------------------
class AIEngine:
    def __init__(self):
        self.exchange = ccxt.hitbtc({'enableRateLimit': True})
        self.history = pd.DataFrame()
        self.model = RandomForestRegressor(n_estimators=50, max_depth=5, random_state=42)
        self.scaler = StandardScaler()
        self.is_trained = False
        self.simulation_wins = 0
        self.simulation_total = 0
        self.last_prediction = 0.0
        self.confidence = 0.0

    def fetch_price(self):
        try:
            ticker = self.exchange.fetch_ticker(SYMBOL_CCXT)
            return {
                'bid': ticker['bid'],
                'ask': ticker['ask'],
                'last': ticker['last'],
                'timestamp': datetime.now()
            }
        except Exception as e:
            logger.error(f"CCXT Error: {e}")
            return None

    def update_data(self, price_data):
        new_row = pd.DataFrame([price_data])
        if self.history.empty:
            self.history = new_row
        else:
            self.history = pd.concat([self.history, new_row], ignore_index=True)
        
        # Keep window size fixed
        if len(self.history) > MAX_HISTORY:
            self.history = self.history.iloc[-MAX_HISTORY:]

    def calculate_features(self, df):
        """
        Calculates manual technical indicators (RSI, Volatility)
        to avoid external heavy libraries like ta-lib.
        """
        df = df.copy()
        df['returns'] = df['last'].pct_change()
        
        # RSI Calculation
        delta = df['last'].diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=14).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=14).mean()
        rs = gain / loss
        df['rsi'] = 100 - (100 / (1 + rs))
        
        # Volatility
        df['volatility'] = df['returns'].rolling(window=10).std()
        
        # Spread
        df['spread'] = df['ask'] - df['bid']
        
        # Target (Next Price Change) - For training
        df['target'] = df['last'].shift(-1) - df['last']
        
        df = df.dropna()
        return df

    def train_and_predict(self):
        if len(self.history) < 30:
            return 0, 0 # Not enough data

        df = self.calculate_features(self.history)
        
        if df.empty:
            return 0, 0

        # Features for ML
        feature_cols = ['rsi', 'volatility', 'spread']
        X = df[feature_cols]
        y = df['target']

        # Background Simulation: Check if last prediction was correct
        if self.is_trained:
            actual_move = df.iloc[-1]['target'] if not pd.isna(df.iloc[-1]['target']) else 0
            if (self.last_prediction > 0 and actual_move > 0) or (self.last_prediction < 0 and actual_move < 0):
                self.simulation_wins += 1
            self.simulation_total += 1

        # Train Model
        try:
            self.model.fit(X, y)
            self.is_trained = True
        except Exception as e:
            logger.warning(f"Training skipped: {e}")
            return 0, 0

        # Predict next move using current state
        current_features = X.iloc[[-1]] # Last row
        prediction = self.model.predict(current_features)[0]
        
        # Calculate Confidence (based on volatility proxy)
        avg_vol = df['volatility'].mean()
        confidence = min(abs(prediction) / (avg_vol + 1e-9), 1.0) * 100
        
        self.last_prediction = prediction
        self.confidence = confidence
        
        return prediction, confidence

# ------------------------------------------------------------------------------
# MAIN BOT LOGIC
# ------------------------------------------------------------------------------
class TradingBot:
    def __init__(self):
        self.sys = SystemInterface()
        self.ai = AIEngine()
        self.running = True
        self.iteration = 0
        self.pnl_history = deque(maxlen=20) # Store last 20 closed PnL for dashboard

    def generate_dashboard(self, wallet, position, price_info, prediction, confidence, action_msg):
        """Generates a static Material Design HTML dashboard."""
        
        # Calculate Real PnL for display
        unrealized_pnl = 0.0
        pnl_class = "neutral"
        
        if position['has_position']:
            qty = position['qty']
            entry = position['entry_price']
            
            curr_price = 0
            if qty > 0: # Long
                curr_price = price_info['bid']
                unrealized_pnl = (curr_price - entry) * qty
            else: # Short
                curr_price = price_info['ask']
                unrealized_pnl = (entry - curr_price) * abs(qty)
                
            if unrealized_pnl > 0: pnl_class = "success"
            elif unrealized_pnl < 0: pnl_class = "danger"

        # Simulation Accuracy
        sim_acc = 0
        if self.ai.simulation_total > 0:
            sim_acc = (self.ai.simulation_wins / self.ai.simulation_total) * 100

        html = f"""
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta http-equiv="refresh" content="1">
            <title>HitBTC AI Scalper</title>
            <style>
                body {{ font-family: 'Roboto', sans-serif; background-color: #121212; color: #e0e0e0; margin: 0; padding: 20px; }}
                .container {{ display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px; }}
                .card {{ background-color: #1e1e1e; border-radius: 8px; padding: 20px; box-shadow: 0 4px 6px rgba(0,0,0,0.3); border-left: 4px solid #333; }}
                .card.success {{ border-left-color: #00c853; }}
                .card.danger {{ border-left-color: #d50000; }}
                .card.info {{ border-left-color: #2962ff; }}
                h2 {{ margin-top: 0; font-size: 1.2rem; color: #9e9e9e; }}
                .value {{ font-size: 2rem; font-weight: bold; }}
                .sub {{ font-size: 0.9rem; color: #757575; }}
                .success-text {{ color: #00c853; }}
                .danger-text {{ color: #d50000; }}
                .table {{ width: 100%; border-collapse: collapse; margin-top: 10px; }}
                .table th, .table td {{ text-align: left; padding: 8px; border-bottom: 1px solid #333; }}
                .status-bar {{ background: #263238; padding: 10px; margin-bottom: 20px; border-radius: 4px; }}
            </style>
        </head>
        <body>
            <div class="status-bar">
                <strong>SYSTEM STATUS:</strong> {action_msg} | <strong>Last Update:</strong> {datetime.now().strftime('%H:%M:%S')}
            </div>

            <div class="container">
                <!-- Wallet Card -->
                <div class="card info">
                    <h2>Wallet Balance (USDT)</h2>
                    <div class="value">${wallet:.2f}</div>
                    <div class="sub">Goal: Continuous Growth</div>
                </div>

                <!-- Position Card -->
                <div class="card {pnl_class}">
                    <h2>Active Position ({SYMBOL_BASH})</h2>
                    <div class="value">{unrealized_pnl:.4f} USDT</div>
                    <table class="table">
                        <tr><td>Qty:</td><td>{position['qty']}</td></tr>
                        <tr><td>Entry:</td><td>{position['entry_price']}</td></tr>
                        <tr><td>Current:</td><td>{price_info['last'] if price_info else 0}</td></tr>
                    </table>
                </div>

                <!-- AI Prediction Card -->
                <div class="card info">
                    <h2>AI Prediction (RandomForest)</h2>
                    <div class="value">{'UP' if prediction > 0 else 'DOWN'}</div>
                    <div class="sub">Confidence: {confidence:.1f}%</div>
                    <div class="sub">Sim Accuracy: {sim_acc:.1f}% ({self.ai.simulation_wins}/{self.ai.simulation_total})</div>
                </div>

                <!-- Market Data -->
                <div class="card">
                    <h2>Market Data</h2>
                    <table class="table">
                        <tr><td>Bid</td><td>{price_info['bid']}</td></tr>
                        <tr><td>Ask</td><td>{price_info['ask']}</td></tr>
                        <tr><td>Spread</td><td>{price_info['ask'] - price_info['bid']:.8f}</td></tr>
                    </table>
                </div>
            </div>
        </body>
        </html>
        """
        
        try:
            with open(DASHBOARD_PATH, 'w') as f:
                f.write(html)
        except Exception as e:
            logger.error(f"Failed to write dashboard: {e}")

    def run(self):
        logger.info("Starting Bot...")
        
        # 1. Close existing positions on start
        self.sys.close_all_positions()
        
        while self.running:
            try:
                action_log = "Scanning..."
                
                # 2. Gather Info
                wallet = self.sys.get_wallet_balance()
                pos_data = self.sys.get_real_position(SYMBOL_BASH)
                price_data = self.ai.fetch_price()
                
                if not price_data:
                    time.sleep(2)
                    continue

                # 3. Update AI
                self.ai.update_data(price_data)
                prediction, confidence = self.ai.train_and_predict()
                
                # 4. Trading Logic
                
                # --- CASE A: HAS POSITION ---
                if pos_data['has_position']:
                    qty = pos_data['qty']
                    entry = pos_data['entry_price']
                    
                    # Calculate PnL (Approximation based on side)
                    # Assuming Qty > 0 is Long, Qty < 0 is Short
                    is_long = qty > 0
                    
                    current_pnl = 0
                    price_diff_pct = 0
                    
                    if is_long:
                        current_pnl = (price_data['bid'] - entry) * abs(qty)
                        price_diff_pct = (price_data['last'] - entry) / entry
                    else:
                        current_pnl = (entry - price_data['ask']) * abs(qty)
                        price_diff_pct = (entry - price_data['last']) / entry

                    # Estimated Fee (Entry + Exit)
                    total_fee = (entry * abs(qty) * FEE_RATE) + (price_data['last'] * abs(qty) * FEE_RATE)
                    net_pnl = current_pnl - total_fee

                    action_log = f"Monitoring PnL: {net_pnl:.6f}"

                    # TAKE PROFIT
                    if net_pnl > 0 and net_pnl > (total_fee * 1.5): # Ensure decent profit over fee
                        logger.info(f"Take Profit Triggered. PnL: {net_pnl}")
                        # Close logic: Place opposite order
                        side = 'sell' if is_long else 'buy'
                        self.sys.place_order(BASE_COIN, abs(qty), side)
                        action_log = "TAKING PROFIT"

                    # MARTINGALE / GRID (Adaptive Position Management)
                    # If losing, and AI is confident in reversal, add to position
                    elif price_diff_pct < -GRID_STEP_PCT: 
                        # Only add if we haven't maxed out wallet usage (simple safety)
                        cost = price_data['last'] * abs(qty)
                        if cost < (wallet * 0.5): # Use max 50% of wallet
                            if (is_long and prediction > 0) or (not is_long and prediction < 0):
                                logger.info("Adding to position (Grid/Martingale)")
                                side = 'buy' if is_long else 'sell'
                                self.sys.place_order(BASE_COIN, MIN_QTY, side)
                                action_log = "GRID ADDITION"

                # --- CASE B: NO POSITION ---
                else:
                    # Open Trade based on AI
                    if self.ai.is_trained and confidence > 60: # Threshold for entry
                        
                        # Dynamic Sizing based on Wallet
                        # Use 5% of wallet for initial entry, but respecting min qty
                        safe_amount_usdt = wallet * 0.05
                        calc_qty = safe_amount_usdt / price_data['last']
                        
                        # Round to 3 decimals (assuming atom uses 3 decimals)
                        trade_qty = max(MIN_QTY, round(calc_qty, 3))
                        
                        if prediction > 0:
                            self.sys.place_order(BASE_COIN, trade_qty, 'buy')
                            action_log = "OPENING LONG"
                        elif prediction < 0:
                            self.sys.place_order(BASE_COIN, trade_qty, 'sell')
                            action_log = "OPENING SHORT"

                # 5. Update Dashboard
                self.generate_dashboard(wallet, pos_data, price_data, prediction, confidence, action_log)
                
                self.iteration += 1
                time.sleep(2) # Fast scalping loop

            except KeyboardInterrupt:
                logger.info("Stopping bot...")
                self.running = False
            except Exception as e:
                logger.error(f"Main Loop Error: {e}")
                time.sleep(5)

if __name__ == "__main__":
    bot = TradingBot()
    bot.run()
