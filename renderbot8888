import time
import subprocess
import json
import re
import pandas as pd
import numpy as np
import os
from datetime import datetime, timedelta
from sklearn.ensemble import HistGradientBoostingClassifier
from sklearn.preprocessing import StandardScaler
from collections import deque

# --- CONFIGURATION & CONSTANTS ---
SYMBOL = "ATOMUSDT_PERP"
BASE_COIN = "ATOM"
MIN_QTY = 0.001
LEVERAGE = 100 
INTERVAL_SECONDS = 30 
LOOKBACK_PERIOD = 300 
WINDOW_SIZE = 14 # Standard size for indicators (RSI, ADX, ROC)
VOLATILITY_WINDOW = 20 # Window for Volatility check

# ML/Adaptive Parameters
MIN_TRAINING_SAMPLES = 50 
BASE_PROBABILITY_THRESHOLD = 0.55 
PROFIT_TO_TRAIL_PERCENT = 0.003 # 0.3% profit triggers move SL to break-even

# Dynamic SL/TP Multipliers
ATR_MULTIPLIER_TP = 2.0 
ATR_MULTIPLIER_SL = 1.0 

# NEW: Time-Based Stop Loss (T-SL)
MAX_HOLDING_PERIOD_MINUTES = 60 # Close position if held for more than 1 hour

# Paths (Persistence files removed, only dashboard remains)
DASHBOARD_PATH = "/var/www/html/dashboard.html"

# --- REMOVED: PERSISTENCE FUNCTIONS (load_bot_state, save_bot_state) ---
# Bot now runs in a purely ephemeral, clean state.

# --- UTILITY & BASH FUNCTIONS ---

def run_bash_command(command_parts):
    """Executes a bash command and returns the output string."""
    try:
        result = subprocess.run(
            command_parts,
            capture_output=True,
            text=True,
            check=False,
            timeout=5
        )
        
        output = result.stdout.strip()
        
        if result.returncode != 0 and not ("NO INFO" in output or output.startswith("ERROR")):
             print(f"ERROR: Bash command exited with code {result.returncode}. Stderr: {result.stderr.strip()}")
             return f"ERROR: Exit code {result.returncode}. {result.stderr.strip()}"

        return output
    except Exception as e:
        print(f"An unexpected error occurred during bash execution: {e}")
        return f"UNEXPECTED ERROR: {e}"

def get_wallet_balance():
    """Fetches and parses the USDT balance using /wallet.sh."""
    output = run_bash_command(['bash', '/wallet.sh'])
    try:
        if output.startswith("ERROR"):
            return 0.0
        # Assuming the first line of output is the balance
        balance = float(output.split('\n')[0].strip())
        return balance
    except:
        return 0.0

def get_current_prices():
    """Simulates fetching real bid/ask prices (mocked for runnable script)."""
    current_time = datetime.now()
    # Ensure changing inputs for ML
    mock_mid_price = 10.0 + (current_time.minute % 10) * 0.1 + (current_time.second % 10) * 0.001
    bid = mock_mid_price - 0.0005
    ask = mock_mid_price + 0.0005
    return bid, ask

def parse_position_info(historical_df):
    """Parses position data and calculates PnL and dynamic risk levels."""
    output = run_bash_command(['bash', '/coinrealinfo.sh', SYMBOL])
    
    if output == "NO INFO" or output.startswith("ERROR"):
        return None
    
    info = {}
    try:
        symbol_match = re.search(r'Symbol: "([^"]+)"', output)
        qty_match = re.search(r'Quantity: ([\d.e-]+)', output)
        entry_match = re.search(r'Entry Price: ([\d.e-]+)', output)

        if not (symbol_match and qty_match and entry_match):
            return None

        info['symbol'] = symbol_match.group(1)
        raw_qty = float(qty_match.group(1))
        info['quantity'] = abs(raw_qty)
        info['entry_price'] = float(entry_match.group(1))
        
        if info['quantity'] == 0:
            return None
            
        info['direction'] = 'buy' if raw_qty > 0 else 'sell'
        
        bid, ask = get_current_prices()
        
        # PnL calculation
        current_price = bid if info['direction'] == 'buy' else ask
        pnl_usdt = (current_price - info['entry_price']) * raw_qty
        info['pnl'] = pnl_usdt
        
        # --- Dynamic SL/TP calculation based on current Volatility (ATR) ---
        if historical_df.empty or len(historical_df) < VOLATILITY_WINDOW:
            volatility = 0.01 # Fallback
        else:
             volatility = historical_df['atr'].iloc[-1] # Use ATR as volatility measure
             
        # Dynamic Risk Levels (in price change)
        tp_level_distance = volatility * ATR_MULTIPLIER_TP
        sl_level_distance = volatility * ATR_MULTIPLIER_SL

        if info['direction'] == 'buy':
            info['take_profit'] = info['entry_price'] + tp_level_distance
            info['stop_loss'] = info['entry_price'] - sl_level_distance
        else: # 'sell'
            info['take_profit'] = info['entry_price'] - tp_level_distance
            info['stop_loss'] = info['entry_price'] + sl_level_distance
            
        # Store initial SL/TP to track trailing stop effectiveness
        # Note: Since there is no persistence, initial_stop_loss will be equal to stop_loss on every run
        info['initial_stop_loss'] = info.get('initial_stop_loss', info['stop_loss'])
        info['initial_take_profit'] = info.get('initial_take_profit', info['take_profit'])

        return info
    except Exception as e:
        print(f"ERROR in parse_position_info: {e}")
        return None

def close_all_positions_on_start():
    """Runs /closepositions.sh at bot startup."""
    print("ATTEMPTING TO CLOSE ALL POSITIONS on startup...")
    run_bash_command(['bash', '/closepositions.sh'])
    print("-" * 50)
    
def execute_trade(quantity, direction, current_position, is_time_out=False):
    """Executes a trade and returns success status and message."""
    
    if not is_time_out:
        print(f"Attempting to PLACE {direction.upper()} order for {quantity:.4f} {BASE_COIN}...")
        output = run_bash_command(['bash', '/placeorder.sh', BASE_COIN, str(quantity), direction])
    else:
        # Time-out exit is a market order close
        close_direction = 'sell' if direction == 'buy' else 'buy'
        print(f"T-SL TRIGGER: Closing {current_position['direction'].upper()} position (Held too long). Qty: {quantity:.4f}")
        output = run_bash_command(['bash', '/placeorder.sh', BASE_COIN, str(quantity), close_direction])
        
    if "SUCCESS" in output or "order placed" in output.lower():
        return True, f"SUCCESS: Order placed for {direction.upper()} {quantity:.4f}."
    else:
        return False, f"ERROR: Failed to place order. Output: {output}"


# --- ADVANCED INDICATOR FUNCTIONS (ROC & NVI Added) ---

def calculate_advanced_indicators(df):
    """Calculates CCI, RSI, MACD, %B, ADX, ROC, and NVI."""
    
    # Check for minimal data size before proceeding to calculations
    if df.empty:
        return df

    # Basic features
    df['mid_price'] = (df['bid'] + df['ask']) / 2
    df['price_change'] = df['mid_price'].diff().fillna(0)
    df['volatility_std'] = df['mid_price'].rolling(window=VOLATILITY_WINDOW).std().fillna(0)

    # --- True Range (TR) and Average True Range (ATR) Calculation ---
    # TR calculation uses np.maximum.reduce which returns a NumPy array.
    # We must assign it to the DataFrame column first before calling pandas methods like fillna().
    range_elements = [
        df['ask'] - df['bid'], 
        abs(df['ask'] - df['ask'].shift(1)), 
        abs(df['bid'] - df['bid'].shift(1))
    ]
    df['tr'] = np.maximum.reduce(range_elements)
    # The .fillna(0) must be called on the Series df['tr'], not the raw array.
    df['tr'] = df['tr'].fillna(0) 
    
    df['atr'] = df['tr'].ewm(alpha=1/WINDOW_SIZE, adjust=False).mean().fillna(0)
    
    # Exit if insufficient data for other WINDOW_SIZE indicators
    if len(df) < WINDOW_SIZE:
        return df


    # RSI (Relative Strength Index)
    delta = df['mid_price'].diff(1)
    gain = (delta.where(delta > 0, 0)).rolling(window=WINDOW_SIZE).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=WINDOW_SIZE).mean()
    rs = gain / loss.replace(0, 1e-6) 
    df['rsi'] = 100 - (100 / (1 + rs)).fillna(0)

    # CCI (Commodity Channel Index)
    TP = (df['bid'] + df['ask']) / 2 
    window = WINDOW_SIZE
    df['ma'] = TP.rolling(window=window).mean()
    df['md'] = TP.rolling(window=window).apply(lambda x: pd.Series(x).mad(), raw=True)
    md_safe = df['md'].replace(0, 1e-6)
    df['cci'] = (TP - df['ma']) / (0.015 * md_safe)
    df['cci'] = df['cci'].replace([np.inf, -np.inf], 0).fillna(0)
    df = df.drop(columns=['ma', 'md'], errors='ignore')

    # MACD (Moving Average Convergence Divergence)
    exp1 = df['mid_price'].ewm(span=12, adjust=False).mean()
    exp2 = df['mid_price'].ewm(span=26, adjust=False).mean()
    df['macd'] = exp1 - exp2
    
    # Bollinger Bands (%B)
    std_dev = df['mid_price'].rolling(window=VOLATILITY_WINDOW).std()
    ma = df['mid_price'].rolling(window=VOLATILITY_WINDOW).mean()
    upper_band = ma + (std_dev * 2)
    lower_band = ma - (std_dev * 2)
    band_range_safe = (upper_band - lower_band).replace(0, 1e-6)
    df['percent_b'] = (df['mid_price'] - lower_band) / band_range_safe
    df['percent_b'] = df['percent_b'].fillna(0)
    
    # ADX (Average Directional Index) - Trend Strength
    df['dm_plus'] = ((df['ask'] - df['ask'].shift(1)).clip(lower=0)).where( (df['ask'] - df['ask'].shift(1)) > (df['bid'].shift(1) - df['bid']), 0)
    df['dm_minus'] = ((df['bid'].shift(1) - df['bid']).clip(lower=0)).where( (df['bid'].shift(1) - df['bid']) > (df['ask'] - df['ask'].shift(1)), 0)
    df['di_plus'] = (df['dm_plus'].ewm(alpha=1/WINDOW_SIZE, adjust=False).mean() / df['atr']).fillna(0)
    df['di_minus'] = (df['dm_minus'].ewm(alpha=1/WINDOW_SIZE, adjust=False).mean() / df['atr']).fillna(0)
    df['dx'] = (abs(df['di_plus'] - df['di_minus']) / (df['di_plus'] + df['di_minus'])).replace(np.inf, 1).fillna(0)
    df['adx'] = df['dx'].ewm(alpha=1/WINDOW_SIZE, adjust=False).mean()
    df['adx'] = df['adx'] * 100 
    
    # NEW FEATURE 1: Rate of Change (ROC) - Momentum
    roc_period = WINDOW_SIZE
    df['roc'] = (df['mid_price'].diff(roc_period) / df['mid_price'].shift(roc_period)).fillna(0) * 100 
    
    # NEW FEATURE 2: Normalized Volatility Index (NVI) - Current volatility relative to its long-term average
    # Need sufficient data for long-term rolling mean
    if len(df) < VOLATILITY_WINDOW * 3:
        df['nvi'] = 1.0
    else:
        df['nvi'] = (df['volatility_std'] / df['volatility_std'].rolling(window=VOLATILITY_WINDOW * 3).mean()).fillna(1)
    
    df = df.drop(columns=['bid', 'ask', 'tr', 'dm_plus', 'dm_minus', 'di_plus', 'di_minus', 'dx'], errors='ignore')
    return df.drop(columns=['volatility_std'], errors='ignore')

# --- ML CLASSIFICATION & TRAINING ---

def create_target_signal(df):
    """Creates the target variable: 1 (Buy/Long), -1 (Sell/Short), 0 (Hold)."""
    if len(df) < 4: return df
    
    df['future_price'] = df['mid_price'].shift(-3)
    PROFIT_THRESHOLD = 0.0005 # 0.05% movement (5 BPS)

    price_change_ratio = (df['future_price'] - df['mid_price']) / df['mid_price']
    
    # Target encoding: 1=Buy/Long, -1=Sell/Short, 0=Hold
    df['next_move_signal'] = 0 
    df.loc[price_change_ratio > PROFIT_THRESHOLD, 'next_move_signal'] = 1
    df.loc[price_change_ratio < -PROFIT_THRESHOLD, 'next_move_signal'] = -1
    
    df = df.drop(columns=['future_price'], errors='ignore')
    return df

def setup_and_train_ml_model(df, scaler, model, initial_fit_done):
    """Prepares data, trains the HistGradientBoostingClassifier, and returns accuracy."""
    
    # Ensure all indicators are calculated and non-NaN
    features = ['price_change', 'atr', 'cci', 'rsi', 'macd', 'percent_b', 'adx', 'roc', 'nvi']
    train_df = df.copy().dropna(subset=['next_move_signal'] + features)
    
    if len(train_df) < MIN_TRAINING_SAMPLES:
        return scaler, model, False, 0.0

    X = train_df[features].values
    y = train_df['next_move_signal'].values
    
    # Fit or refit scaler if necessary
    if not initial_fit_done:
        scaler.partial_fit(X) 
        initial_fit_done = True
        
    X_scaled = scaler.transform(X)
    
    # HistGradientBoosting is fast and replaces partial_fit logic
    # For speed and continuous learning, we use a fixed, small training set
    try:
        # Train on the most recent MIN_TRAINING_SAMPLES
        X_train = X_scaled[-MIN_TRAINING_SAMPLES:]
        y_train = y[-MIN_TRAINING_SAMPLES:]
        
        # HistGradientBoosting is fast and performs a full fit
        model.fit(X_train, y_train) 
    except Exception as e:
        print(f"ML Training Error (HGB): {e}")
        return scaler, model, initial_fit_done, 0.0

    # Calculate accuracy on the training set
    accuracy = model.score(X_train, y_train) * 100
    
    return scaler, model, initial_fit_done, accuracy

def get_ml_prediction(df, scaler, model, adaptive_threshold):
    """Generates a probability prediction for the current state."""
    if not hasattr(scaler, 'scale_') or df.empty or len(df) < 1:
        return 0.0, 0.0, 0.0, "hold" 

    current_state = df.iloc[[-1]]
    features = ['price_change', 'atr', 'cci', 'rsi', 'macd', 'percent_b', 'adx', 'roc', 'nvi']
    
    try:
        X_current = scaler.transform(current_state[features].values)
    except:
        return 0.0, 0.0, 0.0, "hold"

    # Predict probabilities for each class (-1, 0, 1)
    probabilities = model.predict_proba(X_current)[0]
    classes = model.classes_
    
    # Map classes to probabilities
    prob_map = dict(zip(classes, probabilities))
    
    prob_buy = prob_map.get(1, 0.0)
    prob_sell = prob_map.get(-1, 0.0)
    
    if prob_buy > prob_sell and prob_buy >= adaptive_threshold:
        return prob_buy, prob_sell, prob_map.get(0, 0.0), "buy"
    elif prob_sell > prob_buy and prob_sell >= adaptive_threshold:
        return prob_buy, prob_sell, prob_map.get(0, 0.0), "sell"
    else:
        return prob_buy, prob_sell, prob_map.get(0, 0.0), "hold"

# --- ADAPTIVE RISK & POSITION SIZING ---

def calculate_volatility_quantity(wallet_balance, mid_price, sl_price_level, direction, adaptive_risk_percent):
    """Calculates the quantity based on max risk (adaptive) and stop-loss distance."""
    
    if sl_price_level <= 0:
        print("Sizing Error: SL level is zero or negative.")
        return 0.0

    # Adaptive Max Risk based on ML confidence
    max_risk_usdt = wallet_balance * adaptive_risk_percent

    # Distance to Stop Loss (Price difference)
    if direction == 'buy':
        sl_distance = mid_price - sl_price_level
    else: # 'sell'
        sl_distance = sl_price_level - mid_price
        
    if sl_distance <= 0:
        print("Sizing Error: SL distance is zero or negative.")
        return 0.0

    # Quantity = Max Risk USDT / Distance to SL 
    raw_quantity = max_risk_usdt / sl_distance
    
    # Quantize and enforce minimum
    quantized_quantity = max(MIN_QTY, round(raw_quantity / MIN_QTY) * MIN_QTY)
    
    return quantized_quantity

# --- TRADE EXECUTION AND RISK MANAGEMENT ---

def check_risk_targets(current_position, current_prices, historical_df, current_entry_time):
    """Checks for TP, SL, Trailing Stop, AND Time-Based Stop Loss (T-SL) logic."""
    if current_position is None or current_position['quantity'] == 0:
        # Returns current_entry_time (which should be None) if no position is open
        return historical_df, False, 0, "No open position.", current_entry_time 

    direction = current_position['direction']
    qty = current_position['quantity']
    entry_price = current_position['entry_price']
    
    current_price = current_prices[0] if direction == 'buy' else current_prices[1]

    # --- 1. Trailing Stop Logic (Move SL to Break-Even + Fees) ---
    is_profitable = (direction == 'buy' and current_price > entry_price) or \
                    (direction == 'sell' and current_price < entry_price)
    
    profit_usdt_ratio = abs(current_position['pnl']) / (current_position['quantity'] * entry_price / LEVERAGE)
    fee_buffer = entry_price * PROFIT_TO_TRAIL_PERCENT 
    
    new_sl = current_position['stop_loss']
    trailing_status = "No trail."
    
    if is_profitable and profit_usdt_ratio > PROFIT_TO_TRAIL_PERCENT:
        be_price = entry_price + fee_buffer if direction == 'buy' else entry_price - fee_buffer
        
        if (direction == 'buy' and be_price > current_position['stop_loss']) or \
           (direction == 'sell' and be_price < current_position['stop_loss']):
            new_sl = be_price
            trailing_status = f"SL moved to BE ({new_sl:.4f})"
            current_position['stop_loss'] = new_sl # Update for the next checks

    # --- 2. Time-Based Stop Loss (T-SL) ---
    is_time_out = False
    time_out_msg = ""
    if current_entry_time:
        time_elapsed = datetime.now() - current_entry_time
        max_hold_delta = timedelta(minutes=MAX_HOLDING_PERIOD_MINUTES)
        
        if time_elapsed > max_hold_delta:
            is_time_out = True
            time_out_msg = f"T-SL: Held for {int(time_elapsed.total_seconds() / 60)} min (Max {MAX_HOLDING_PERIOD_MINUTES} min)."
            
    # --- 3. Check for TP, SL, or T-SL hit ---
    tp_hit = (direction == 'buy' and current_price >= current_position['take_profit']) or \
             (direction == 'sell' and current_price <= current_position['take_profit'])
             
    sl_hit = (direction == 'buy' and current_price <= current_position['stop_loss']) or \
             (direction == 'sell' and current_price >= current_position['stop_loss'])

    if tp_hit or sl_hit or is_time_out:
        action_type = "TAKE PROFIT" if tp_hit else ("STOP LOSS" if sl_hit else "TIME OUT")
        
        # Close the position using the execution function
        success, output_msg = execute_trade(qty, direction, current_position, is_time_out)

        if success:
            # The trade outcome is now determined
            return historical_df, True, current_position['pnl'], f"SUCCESS: Position closed via {action_type}. {time_out_msg}", None # Reset entry time
        else:
            return historical_df, False, 0, f"ERROR: Failed to close position via {action_type}. Output: {output_msg}", current_entry_time
    
    # Return status if holding
    hold_msg = f"Holding. PnL {current_position['pnl']:.4f} USDT. Targets: SL {current_position['stop_loss']:.4f} (Actual: {current_position['initial_stop_loss']:.4f}), TP {current_position['take_profit']:.4f}. {trailing_status}"
    if current_entry_time:
        time_elapsed = datetime.now() - current_entry_time
        time_msg = f" | Time Left: {MAX_HOLDING_PERIOD_MINUTES - int(time_elapsed.total_seconds() / 60)} min"
        hold_msg += time_msg
        
    return historical_df, False, 0, hold_msg, current_entry_time


# --- DASHBOARD FUNCTIONS ---

def update_dashboard(wallet_balance, current_position, prob_buy, prob_sell, ml_accuracy, wins, losses, adaptive_threshold, adaptive_risk_percent, current_entry_time):
    """Writes all advanced metrics to the HTML dashboard."""
    
    time_held_display = "N/A"
    
    if current_position:
        pos_status = f"{current_position['direction'].upper()} {current_position['quantity']:.4f} {BASE_COIN}"
        entry_price = f"{current_position['entry_price']:.8f}"
        pnl_usdt = f"{current_position['pnl']:.4f}"
        pnl_class = "text-green-500" if current_position['pnl'] >= 0 else "text-red-500"
        sl_tp_info = f"SL: {current_position['stop_loss']:.4f}, TP: {current_position['take_profit']:.4f}"
        if current_position['stop_loss'] != current_position['initial_stop_loss']:
             sl_tp_info += " (TRAILED)"
             
        # Calculate time held for dashboard display (using passed entry time)
        if current_entry_time:
            time_held = datetime.now() - current_entry_time
            time_held_display = f"{int(time_held.total_seconds() / 60)} min"
    else:
        pos_status = "FLAT (0.0000 ATOM)"
        entry_price = "N/A"
        pnl_usdt = "0.0000"
        pnl_class = "text-gray-500"
        sl_tp_info = "N/A"

    best_prob = max(prob_buy, prob_sell)
    signal = "BUY" if prob_buy == best_prob and prob_buy >= adaptive_threshold else \
             ("SELL" if prob_buy == best_prob and prob_buy >= adaptive_threshold else "HOLD")
    
    pred_status_class = "bg-green-100 text-green-700" if signal in ["BUY", "SELL"] else "bg-gray-100 text-gray-700"
    
    html_content = f"""
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ATOM Advanced Futures Bot Dashboard (V3 - CLEAN START)</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body {{ font-family: 'Inter', sans-serif; background-color: #f0f2f5; }}
        .card {{ background-color: white; border-radius: 12px; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1); transition: all 0.3s ease; }}
    </style>
</head>
<body class="p-4 md:p-8">

    <div class="max-w-6xl mx-auto">
        <h1 class="text-3xl font-bold text-gray-800 mb-6 border-b-2 pb-2">ATOM Adaptive Futures Bot (V3 - CLEAN START/No Persistence)</h1>
        <p class="text-sm text-gray-500 mb-8">Last Updated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>
        <div class="bg-yellow-100 p-4 rounded-lg mb-6 text-yellow-800 text-sm font-semibold border-l-4 border-yellow-500">
            NOTICE: This bot is running in non-persistent mode. Wins/Losses/Accuracy reset on every run.
        </div>

        <div class="grid grid-cols-2 md:grid-cols-5 gap-4 mb-8">
            <div class="card p-4 border-l-4 border-indigo-500">
                <p class="text-xs font-medium text-gray-500">USDT Wallet Balance</p>
                <p class="text-2xl font-bold text-gray-900 mt-1">${wallet_balance:.2f}</p>
            </div>
            
            <div class="card p-4 border-l-4 border-yellow-500">
                <p class="text-xs font-medium text-gray-500">ML Accuracy (HGB)</p>
                <p class="text-2xl font-bold text-gray-900 mt-1">{ml_accuracy:.2f}%</p>
            </div>
            
            <div class="card p-4 border-l-4 border-green-500">
                <p class="text-xs font-medium text-gray-500">Wins / Losses (Realized)</p>
                <p class="text-2xl font-bold text-gray-900 mt-1">
                    <span class="text-green-600">{wins}</span> / <span class="text-red-600">{losses}</span>
                </p>
            </div>
             <div class="card p-4 border-l-4 border-pink-500">
                <p class="text-xs font-medium text-gray-500">Adaptive Risk/Trade</p>
                <p class="text-2xl font-bold text-gray-900 mt-1">{adaptive_risk_percent * 100:.2f}%</p>
            </div>
            <div class="card p-4 border-l-4 border-red-500">
                <p class="text-xs font-medium text-gray-500">Max Hold Time</p>
                <p class="text-2xl font-bold text-gray-900 mt-1">{MAX_HOLDING_PERIOD_MINUTES} min</p>
            </div>
        </div>

        <!-- CURRENT POSITION STATUS -->
        <div class="card p-6 mb-8 border-t-8 border-blue-500">
            <h2 class="text-xl font-semibold text-gray-700 mb-4">Current Real Position & Dynamic Risk</h2>
            <div class="grid grid-cols-2 md:grid-cols-5 gap-4 text-sm">
                <div><p class="text-gray-500">Status / Size</p><p class="font-bold text-lg">{pos_status}</p></div>
                <div><p class="text-gray-500">Time Held</p><p class="font-bold text-lg">{time_held_display}</p></div>
                <div><p class="text-gray-500">Entry Price</p><p class="font-mono text-lg">{entry_price}</p></div>
                <div><p class="text-gray-500">Unrealized PnL (USDT)</p><p class="font-mono text-lg font-bold {pnl_class}">{pnl_usdt}</p></div>
                <div><p class="text-gray-500">SL / TP Levels</p><p class="font-mono text-lg text-blue-500">{sl_tp_info}</p></div>
            </div>
        </div>

        <!-- AI PREDICTION & NEXT ACTION -->
        <div class="card p-6 {pred_status_class}">
            <h2 class="text-xl font-bold text-gray-800 mb-4">HGB Classifier Signal</h2>
            <div class="grid grid-cols-1 md:grid-cols-4 gap-4 text-sm font-medium">
                <div>
                    <p class="text-gray-600">Buy Probability</p>
                    <p class="text-2xl font-bold mt-1 text-green-700">{prob_buy:.2f}</p>
                </div>
                <div>
                    <p class="text-gray-600">Sell Probability</p>
                    <p class="text-2xl font-bold mt-1 text-red-700">{prob_sell:.2f}</p>
                </div>
                <div>
                    <p class="text-gray-600">Hold Probability</p>
                    <p class="text-2xl font-bold mt-1 text-gray-700">{1 - prob_buy - prob_sell:.2f}</p>
                </div>
                <div>
                    <p class="text-gray-600">Action Signal</p>
                    <p class="text-2xl font-bold mt-1 text-indigo-700">{signal}</p>
                </div>
            </div>
            <p class="text-xs mt-4 text-gray-600">Trading only occurs if Buy/Sell probability is >= {adaptive_threshold:.4f}</p>
        </div>

    </div>
</body>
</html>
    """
    
    try:
        with open(DASHBOARD_PATH, 'w') as f:
            f.write(html_content)
    except Exception as e:
        print(f"ERROR: Could not write HTML dashboard to {DASHBOARD_PATH}. Check permissions: {e}")

# --- MAIN BOT LOGIC ---

def main():
    """The main trading loop of the advanced bot."""
    
    # --- Non-Persistence Initialization (Clean Start) ---
    realized_wins = 0
    realized_losses = 0
    ml_accuracy = 0.0
    position_entry_time = None # Tracks time for T-SL (Time-based Stop Loss)
    
    # Initialize Scaler (No state loaded)
    scaler = StandardScaler()
    initial_fit_done = False
    print("Starting bot in clean, non-persistent mode. State variables are reset.")

    # Initialize historical data as empty
    global historical_df 
    # Initialize an empty DataFrame and explicitly set the index name to 'timestamp'.
    historical_df = pd.DataFrame(columns=['bid', 'ask']).set_index(pd.Index([], name='timestamp'))
    print("Historical data initialized as empty.")

    # NEW ML Model: HistGradientBoostingClassifier (Faster, more powerful ensemble)
    ml_model = HistGradientBoostingClassifier(
        max_iter=100, 
        max_depth=5, 
        l2_regularization=0.1,
        random_state=42,
        class_weight='balanced' # Helps with class imbalance
    )
    # The HGB model needs to be fitted once before prediction. Since we start clean, we must wait 
    # until MIN_TRAINING_SAMPLES are collected.

    # --- Main Loop ---
    while True:
        start_time = time.time()
        print(f"\n--- Bot Cycle Start: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')} ---")
        
        # 1. Fetch data
        bid, ask = get_current_prices()
        current_time = datetime.now()

        # Append new data point
        new_row = pd.DataFrame([{'bid': bid, 'ask': ask}], index=[current_time])
        new_row.index.name = 'timestamp'
        historical_df = pd.concat([historical_df, new_row])
        historical_df = historical_df.iloc[-LOOKBACK_PERIOD:]
        
        # 2. Calculate Indicators & Target
        historical_df = calculate_advanced_indicators(historical_df)
        historical_df = create_target_signal(historical_df)

        # 3. ML Training
        if len(historical_df) >= MIN_TRAINING_SAMPLES:
            scaler, ml_model, initial_fit_done, ml_accuracy = setup_and_train_ml_model(
                historical_df, scaler, ml_model, initial_fit_done
            )
            print(f"ML Model Trained (Accuracy: {ml_accuracy:.2f}%)")

        # --- Adaptive Threshold Calculation ---
        # The higher the accuracy, the lower the required probability can be, 
        # allowing the bot to trade more frequently with high-confidence models.
        # Linearly scales between BASE_PROBABILITY_THRESHOLD (at 100% accuracy) 
        # and 0.99 (at 0% accuracy).
        accuracy_ratio = max(0.0, min(1.0, ml_accuracy / 100.0))
        # The threshold gets tighter (closer to 0.99) as accuracy drops toward 0.
        adaptive_threshold = 0.99 - (0.99 - BASE_PROBABILITY_THRESHOLD) * accuracy_ratio
        
        # 4. Get Prediction
        prob_buy, prob_sell, prob_hold, signal = get_ml_prediction(
            historical_df, scaler, ml_model, adaptive_threshold
        )
        print(f"Prediction: {signal.upper()} | Prob Buy: {prob_buy:.4f}, Prob Sell: {prob_sell:.4f} (Required: {adaptive_threshold:.4f})")
        
        # --- Adaptive Risk Management ---
        # Risk scales with confidence: Max risk at 100% accuracy (e.g., 2%), Min risk at 0% (e.g., 0.5%)
        MAX_RISK_PERCENT = 0.02 # 2.0%
        MIN_RISK_PERCENT = 0.005 # 0.5%
        adaptive_risk_percent = MIN_RISK_PERCENT + (MAX_RISK_PERCENT - MIN_RISK_PERCENT) * accuracy_ratio
        
        # 5. Position Management
        wallet_balance = get_wallet_balance()
        current_position = parse_position_info(historical_df)
        
        # Check for SL/TP/T-SL hit
        historical_df, position_closed, pnl_realized, status_msg, position_entry_time = check_risk_targets(
            current_position, (bid, ask), historical_df, position_entry_time
        )
        print(f"Risk Check Status: {status_msg}")
        
        if position_closed:
            # Update realized stats
            if pnl_realized > 0:
                realized_wins += 1
                print(f"POSITION CLOSED: WIN (+{pnl_realized:.4f} USDT) | Total Wins/Losses: {realized_wins}/{realized_losses}")
            else:
                realized_losses += 1
                print(f"POSITION CLOSED: LOSS ({pnl_realized:.4f} USDT) | Total Wins/Losses: {realized_wins}/{realized_losses}")
            current_position = None
            position_entry_time = None # Ensure entry time is reset
        
        # 6. Execute New Trade
        if current_position is None:
            if signal in ['buy', 'sell']:
                # Need sufficient data for ATR-based SL/TP calculation
                if len(historical_df) < VOLATILITY_WINDOW:
                     print("WAITING: Insufficient data for dynamic risk sizing.")
                     continue
                     
                mid_price = (bid + ask) / 2
                
                # Use a mock volatility measure for initial sizing before parse_position_info runs after trade
                if historical_df.empty or 'atr' not in historical_df.columns:
                    print("WAITING: ATR not yet calculated for sizing.")
                    continue
                
                # Mock a stop loss distance for sizing calculation
                volatility_atr = historical_df['atr'].iloc[-1]
                sl_distance_mock = volatility_atr * ATR_MULTIPLIER_SL
                
                # Mock SL price level based on current mid_price and distance
                if signal == 'buy':
                    sl_price_level_mock = mid_price - sl_distance_mock
                else:
                    sl_price_level_mock = mid_price + sl_distance_mock
                    
                quantity_to_trade = calculate_volatility_quantity(
                    wallet_balance, mid_price, sl_price_level_mock, signal, adaptive_risk_percent
                )
                
                if quantity_to_trade > MIN_QTY:
                    success, msg = execute_trade(quantity_to_trade, signal, current_position)
                    print(msg)
                    if success:
                        # Set entry time for T-SL tracking if trade was successful
                        position_entry_time = datetime.now()
                else:
                    print(f"HOLD: Calculated quantity {quantity_to_trade:.4f} is too small.")
            else:
                print("HOLD: No high-confidence signal.")

        # 7. Update Dashboard
        update_dashboard(
            wallet_balance, 
            current_position, 
            prob_buy, 
            prob_sell, 
            ml_accuracy, 
            realized_wins, 
            realized_losses, 
            adaptive_threshold, 
            adaptive_risk_percent,
            position_entry_time # Pass the entry time explicitly
        )

        # 8. Wait for next cycle
        end_time = time.time()
        elapsed = end_time - start_time
        sleep_duration = max(0, INTERVAL_SECONDS - elapsed)
        print(f"Cycle finished in {elapsed:.2f}s. Sleeping for {sleep_duration:.2f}s.")
        time.sleep(sleep_duration)

if __name__ == '__main__':
    # Initial setup before the main loop starts
    close_all_positions_on_start()
    
    # Run the main bot logic
    try:
        main()
    except KeyboardInterrupt:
        print("\nBot stopped by user (KeyboardInterrupt).")
    except Exception as e:
        print(f"\nCRITICAL BOT FAILURE: {e}")
        time.sleep(5) # Wait before exiting to allow console visibility
