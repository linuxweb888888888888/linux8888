import time
import subprocess
import json
import re
import pandas as pd
import numpy as np
import os
from datetime import datetime
from sklearn.linear_model import SGDRegressor
from sklearn.preprocessing import StandardScaler
from collections import deque

# --- CONFIGURATION & CONSTANTS ---
# Trading Parameters
SYMBOL = "ATOMUSDT_PERP"
BASE_COIN = "ATOM"
MIN_QTY = 0.001  # Minimum quantity for ATOM trades
FEE_RATE = 0.00075  # 0.075% standard futures maker/taker fee
LEVERAGE = 100 # Assumed leverage for PnL calculations
INTERVAL_SECONDS = 30 # Target interval for main loop (must be < 60s)
LOOKBACK_PERIOD = 200 # Candles/ticks for technical indicator calculations
WINDOW_SIZE = 14 # Standard CCI/RSI window size

# ML/Adaptive Parameters
MIN_TRAINING_SAMPLES = 10 # Minimum data points needed before first ML prediction
WIN_CONFIDENCE_THRESHOLD = 0.55 # ML confidence score needed to open a new position
RISK_PER_TRADE_PERCENT = 0.01 # Max percentage of balance to risk per new position
MAX_POSITION_RISK_PERCENT = 0.50 # Max percentage of balance for total position size

# Dashboard path
DASHBOARD_PATH = "/var/www/html/dashboard.html"

print("linux8888")

# --- GLOBAL STATE (Persisted DataFrames for ML learning) ---
try:
    historical_df = pd.read_csv('historical_data.csv', index_col='timestamp')
    historical_df.index = pd.to_datetime(historical_df.index)
except Exception as e:
    print(f"Initializing new historical data file. Load error: {e}")
    historical_df = pd.DataFrame(columns=[
        'timestamp', 'bid', 'ask', 'mid_price', 'price_change', 'cci', 'rsi', 
        'volatility', 'PnL_Future', 'trade_size', 'direction', 'realized'
    ]).set_index('timestamp')

# --- UTILITY FUNCTIONS ---

def run_bash_command(command_parts):
    """Executes a bash command and returns the output string."""
    try:
        # Added universal_newlines=True (same as text=True) for better cross-platform compatibility
        result = subprocess.run(
            command_parts,
            capture_output=True,
            text=True,
            check=False, # Changed check to False here to capture ERROR output gracefully
            timeout=5
        )
        
        output = result.stdout.strip()
        
        if result.returncode != 0 and not ("NO INFO" in output or output.startswith("ERROR")):
             print(f"ERROR: Bash command exited with code {result.returncode}. Stderr: {result.stderr.strip()}")
             return f"ERROR: Exit code {result.returncode}. {result.stderr.strip()}"

        return output
    except subprocess.CalledProcessError as e:
        # This block should be unreachable now that check=False, but kept for robustness
        print(f"ERROR: Bash command failed (CalledProcessError): {' '.join(command_parts)}")
        return f"ERROR: {e.stderr.strip()}"
    except Exception as e:
        print(f"An unexpected error occurred during bash execution: {e}")
        return f"UNEXPECTED ERROR: {e}"

def get_wallet_balance():
    """Fetches and parses the USDT balance using /wallet.sh."""
    output = run_bash_command(['bash', '/wallet.sh'])
    try:
        # Assumes the first line is the USDT balance
        return float(output.split('\n')[0].strip())
    except:
        print(f"WARNING: Could not parse wallet balance from output: {output}")
        return 0.0

def get_current_prices():
    """Simulates fetching real bid/ask prices (mocked for runnable script)."""
    # Simple simulation to ensure the ML has changing inputs
    current_time = datetime.now()
    mock_mid_price = 10.0 + (current_time.minute % 10) * 0.1 + (current_time.second % 10) * 0.001
    bid = mock_mid_price - 0.0005
    ask = mock_mid_price + 0.0005
    return bid, ask

def parse_position_info():
    """Parses position data from /coinrealinfo.sh and calculates PnL."""
    output = run_bash_command(['bash', '/coinrealinfo.sh', SYMBOL])
    if output == "NO INFO" or output.startswith("ERROR"):
        return None
    
    info = {}
    try:
        # Regex to extract structured info
        symbol_match = re.search(r'Symbol: "([^"]+)"', output)
        qty_match = re.search(r'Quantity: ([\d.e-]+)', output)
        entry_match = re.search(r'Entry Price: ([\d.e-]+)', output)

        if not (symbol_match and qty_match and entry_match):
            print(f"ERROR: Failed to parse required fields from coinrealinfo.sh output: {output}")
            return None

        info['symbol'] = symbol_match.group(1)
        # Handle case where quantity might be negative (short)
        raw_qty = float(qty_match.group(1))
        info['quantity'] = abs(raw_qty)
        info['entry_price'] = float(entry_match.group(1))
        
        info['direction'] = 'buy' if raw_qty > 0 else ('sell' if raw_qty < 0 else None)
        
        bid, ask = get_current_prices()
        
        if info['direction'] == 'buy':
            # Long PnL: (Current Bid - Entry Price) * Quantity
            pnl_usdt = (bid - info['entry_price']) * info['quantity']
        elif info['direction'] == 'sell':
            # Short PnL: (Entry Price - Current Ask) * Quantity
            pnl_usdt = (info['entry_price'] - ask) * info['quantity']
        else:
            pnl_usdt = 0.0

        info['pnl'] = pnl_usdt

        return info
    except ValueError as e:
        print(f"ERROR: Data type conversion failure in parse_position_info: {e}. Output: {output}")
        return None
    except Exception as e:
        print(f"An unexpected error occurred in parse_position_info: {e}")
        return None

def close_all_positions_on_start():
    """Runs /closepositions.sh at bot startup."""
    print("ATTEMPTING TO CLOSE ALL POSITIONS on startup...")
    output = run_bash_command(['bash', '/closepositions.sh'])
    print(f"CLOSE POSITIONS script output: {output}")
    if output and not output.startswith("ERROR"):
        print("Positions might have been closed successfully.")
    print("-" * 50)

# --- ML & INDICATOR FUNCTIONS (Unchanged, as logic is sound) ---

def calculate_indicators(df):
    """Calculates technical indicators for ML features."""
    if df.empty or len(df) < WINDOW_SIZE:
        return df

    df['price_change'] = df['mid_price'].diff().fillna(0)
    df['volatility'] = df['mid_price'].rolling(window=WINDOW_SIZE).std().fillna(0)

    delta = df['mid_price'].diff(1)
    gain = (delta.where(delta > 0, 0)).rolling(window=WINDOW_SIZE).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=WINDOW_SIZE).mean()
    rs = gain / loss
    df['rsi'] = 100 - (100 / (1 + rs)).fillna(0)

    window = WINDOW_SIZE
    TP = (df['bid'] + df['ask']) / 2 
    df['ma'] = TP.rolling(window=window).mean()
    df['md'] = TP.rolling(window=window).apply(lambda x: pd.Series(x).mad(), raw=True)
    df['cci'] = (TP - df['ma']) / (0.015 * df['md'])
    df['cci'] = df['cci'].replace([np.inf, -np.inf], 0).fillna(0)

    df = df.drop(columns=['ma', 'md'], errors='ignore')
    return df

def setup_and_train_ml_model(df, scaler, model):
    """Prepares data and trains the SGDRegressor model."""
    if len(df) < MIN_TRAINING_SAMPLES:
        return scaler, model, False, 0.0
    
    train_df = df[df['realized'] == True].copy()
    if len(train_df) < MIN_TRAINING_SAMPLES:
        # ML model is trained only on realized trades, so we still return False if not enough realized data
        return scaler, model, False, 0.0

    features = ['price_change', 'volatility', 'cci', 'rsi', 'trade_size', 'direction_int']
    train_df['direction_int'] = train_df['direction'].apply(lambda x: 1 if x == 'buy' else -1)
    
    X = train_df[features].values
    y = train_df['PnL_Future'].values
    
    # Handle the UserWarning: X does not have valid feature names (by passing numpy arrays)
    
    if not hasattr(scaler, 'scale_'):
        scaler.fit(X)

    X_scaled = scaler.transform(X)

    try:
        model.partial_fit(X_scaled, y)
    except Exception as e:
        print(f"ML Training Error: {e}. Check if data is clean.")
        return scaler, model, False, 0.0

    y_pred = model.predict(X_scaled)
    # Simple win/loss prediction accuracy
    accuracy = (np.sign(y_pred) == np.sign(y)).mean() * 100
    
    # Model is considered trained when we have MIN_TRAINING_SAMPLES realized trades
    return scaler, model, True, accuracy


def get_ml_prediction(df, scaler, model):
    """Generates a profit prediction for the current state."""
    if not hasattr(scaler, 'scale_') or df.empty:
        return 0.0, 0.5, "Untrained" 

    current_state = df.iloc[[-1]]

    features = ['price_change', 'volatility', 'cci', 'rsi', 'trade_size', 'direction_int']
    base_features = current_state[['price_change', 'volatility', 'cci', 'rsi']].iloc[0].tolist()

    # Predict for BUY (Long)
    buy_size = MIN_QTY 
    buy_features = base_features + [buy_size, 1] # 1 for 'buy'
    X_buy = scaler.transform([buy_features])
    pred_buy_pnl = model.predict(X_buy)[0]

    # Predict for SELL (Short)
    sell_size = MIN_QTY
    sell_features = base_features + [sell_size, -1] # -1 for 'sell'
    X_sell = scaler.transform([sell_features])
    pred_sell_pnl = model.predict(X_sell)[0]
    
    if pred_buy_pnl > pred_sell_pnl:
        best_pnl = pred_buy_pnl
        best_direction = 'buy'
    else:
        best_pnl = pred_sell_pnl
        best_direction = 'sell'
        
    historical_pnl = df[df['realized'] == True]['PnL_Future'].values
    confidence = 0.5
    if len(historical_pnl) > 5:
        pnl_std = np.std(historical_pnl)
        if pnl_std > 1e-6:
            # Calculate confidence using tanh based on predicted PnL vs historical volatility
            confidence = 0.5 + 0.5 * np.tanh(best_pnl / (2 * pnl_std))
        else:
            confidence = 1.0 if best_pnl > 0 else 0.5
        
    return best_pnl, confidence, best_direction

# --- ADAPTIVE POSITION MANAGEMENT (Added logging) ---

def calculate_adaptive_quantity(wallet_balance, current_position, predicted_pnl, direction):
    """Calculates the quantity (in steps of MIN_QTY) for the next trade."""
    
    max_risk_usdt = wallet_balance * MAX_POSITION_RISK_PERCENT
    base_quantity = MIN_QTY
    quantity_to_place = 0.0 # Start at 0.0
    
    if current_position is None or current_position['quantity'] == 0:
        if predicted_pnl > 0:
            quantity_to_place = MIN_QTY
        else:
            print("Adaptive Sizing: Holding (No position & predicted PnL <= 0).")
            return 0.0
    else:
        current_pnl = current_position['pnl']
        current_abs_qty = current_position['quantity']
        current_direction = current_position['direction']
        
        if direction == current_direction:
            # Direction ALIGNED 
            if current_pnl < 0:
                # Losing trade: Martingale step.
                loss_magnitude = abs(current_pnl) / (wallet_balance * RISK_PER_TRADE_PERCENT)
                # Ensure factor is at least 1, and always add at least MIN_QTY
                martingale_factor = max(1, int(np.ceil(loss_magnitude))) 
                
                # Calculate incremental quantity to place for the next step
                quantity_to_place = max(MIN_QTY, martingale_factor * MIN_QTY) 
                
                entry_price_estimate = get_current_prices()[0] if direction == 'buy' else get_current_prices()[1]
                required_usdt = entry_price_estimate * (current_abs_qty + quantity_to_place) / LEVERAGE
                
                if required_usdt > max_risk_usdt:
                    print(f"Adaptive Sizing: MAX RISK CAP hit. Cannot increase position. Current Size: {current_abs_qty:.4f} ATOM.")
                    return 0.0
                print(f"Adaptive Sizing: Martingale step calculated. Increasing by {quantity_to_place:.4f} ATOM.")
                
            elif current_pnl > 0 and predicted_pnl > 0.001:
                # Winning trade: Adaptive Scalping. Smallest increase.
                quantity_to_place = MIN_QTY
                print(f"Adaptive Sizing: Profitable trade increase calculated: {MIN_QTY:.4f} ATOM.")
        else:
            # Direction MISALIGNED (Should be handled by TP check before this)
            print("Adaptive Sizing: Holding (Direction Misaligned).")
            return 0.0
            
    # Final check and rounding to MIN_QTY steps
    quantity_to_place = round(quantity_to_place / MIN_QTY) * MIN_QTY
    
    return max(0.0, quantity_to_place)

# --- TRADE EXECUTION AND PNL MANAGEMENT (Added logging) ---

def execute_trade(quantity, direction, current_position, current_prices):
    """Executes a market order or closes/reduces a position."""
    if quantity < MIN_QTY:
        return False, f"ERROR: Quantity too small ({quantity:.4f})."
    
    is_opening = current_position is None or current_position['quantity'] == 0
    is_increasing = (not is_opening) and (current_position['direction'] == direction)

    if is_opening or is_increasing:
        
        command_parts = ['bash', '/placeorder.sh', BASE_COIN, str(quantity), direction]
        command_str = ' '.join(command_parts)
        
        print(f"ATTEMPTING ORDER: {command_str}")
        
        output = run_bash_command(command_parts)
        
        if "SUCCESS" in output:
            return True, f"SUCCESS: Order placed. Output: {output}"
        else:
            return False, f"ERROR: Order failed. Command output: {output}"

    return False, "Trade execution logic error: tried to execute an unexpected trade type."

def check_for_take_profit(current_position, current_prices, historical_df):
    """Checks if the current position should be closed for profit and handles ML realization."""
    if current_position is None or current_position['quantity'] == 0:
        return historical_df, False, "No open position to check for TP."

    qty = current_position['quantity']
    entry_price = current_position['entry_price']
    pnl_usdt = current_position['pnl']
    direction = current_position['direction']

    total_fee_estimate = 2 * qty * entry_price * FEE_RATE
    
    # Condition: PnL must be larger than the estimated fee for profit
    if pnl_usdt > total_fee_estimate:
        print(f"TAKE PROFIT CONDITION MET: PnL {pnl_usdt:.4f} USDT > Fee {total_fee_estimate:.4f} USDT.")
        
        close_direction = 'sell' if direction == 'buy' else 'buy'
        command_parts = ['bash', '/placeorder.sh', BASE_COIN, str(qty), close_direction]
        command_str = ' '.join(command_parts)
        
        print(f"CLOSING POSITION: {command_str}")
        output = run_bash_command(command_parts)
        
        if "SUCCESS" in output:
            # --- ML Learning Update (Realized PnL) ---
            # Mark the latest trade state as realized PnL
            if not historical_df.empty:
                historical_df.loc[historical_df.index[-1], 'PnL_Future'] = pnl_usdt
                historical_df.loc[historical_df.index[-1], 'realized'] = True
                print(f"ML Learning: Realized PnL of {pnl_usdt:.4f} USDT recorded for position closure.")
            
            return historical_df, True, f"SUCCESS: Position closed for PnL {pnl_usdt:.4f} USDT."
        else:
            return historical_df, False, f"ERROR: Failed to close position. Command output: {output}"
    
    return historical_df, False, "PnL too low or insufficient to cover fees."

# --- DASHBOARD FUNCTIONS (Unchanged) ---

def update_dashboard(wallet_balance, current_position, pred_pnl, confidence, accuracy, wins, losses):
    """Writes all metrics to the HTML dashboard with a Material Design aesthetic."""
    
    if current_position:
        pos_status = f"{current_position['direction'].upper()} {current_position['quantity']:.4f} {BASE_COIN}"
        entry_price = f"{current_position['entry_price']:.8f}"
        pnl_usdt = f"{current_position['pnl']:.4f}"
        pnl_class = "text-green-500" if current_position['pnl'] >= 0 else "text-red-500"
    else:
        pos_status = "FLAT (0.0000 ATOM)"
        entry_price = "N/A"
        pnl_usdt = "0.0000"
        pnl_class = "text-gray-500"

    pred_status_class = "bg-green-100 text-green-700" if pred_pnl > 0 and confidence > WIN_CONFIDENCE_THRESHOLD else "bg-red-100 text-red-700"
    
    html_content = f"""
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ATOM Futures Bot Dashboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap');
        body {{ font-family: 'Inter', sans-serif; background-color: #f0f2f5; }}
        .card {{ background-color: white; border-radius: 12px; box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.1); transition: all 0.3s ease; }}
        .card:hover {{ box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -4px rgba(0, 0, 0, 0.1); }}
    </style>
</head>
<body class="p-4 md:p-8">

    <div class="max-w-4xl mx-auto">
        <h1 class="text-3xl font-bold text-gray-800 mb-6 border-b-2 pb-2">ATOM Adaptive Futures Bot</h1>
        <p class="text-sm text-gray-500 mb-8">Last Updated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}</p>

        <div class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-8">
            <!-- WALLET BALANCE CARD -->
            <div class="card p-5 border-l-4 border-indigo-500">
                <p class="text-sm font-medium text-gray-500">USDT Wallet Balance</p>
                <p class="text-3xl font-bold text-gray-900 mt-1">${wallet_balance:.2f}</p>
                <p class="text-xs text-gray-400 mt-2">Target: Fast USDT Growth</p>
            </div>
            
            <!-- TOTAL TRADES CARD -->
            <div class="card p-5 border-l-4 border-yellow-500">
                <p class="text-sm font-medium text-gray-500">ML Signal Accuracy</p>
                <p class="text-3xl font-bold text-gray-900 mt-1">{accuracy:.2f}%</p>
                <p class="text-xs text-gray-400 mt-2">Predictive Success Rate (Sign of PnL)</p>
            </div>
            
            <!-- WINS/LOSSES CARD -->
            <div class="card p-5 border-l-4 border-green-500">
                <p class="text-sm font-medium text-gray-500">Win / Loss History</p>
                <p class="text-3xl font-bold text-gray-900 mt-1">
                    <span class="text-green-600">{wins}</span> / <span class="text-red-600">{losses}</span>
                </p>
                <p class="text-xs text-gray-400 mt-2">Realized Profitable vs. Loss Trades</p>
            </div>
        </div>

        <!-- CURRENT POSITION STATUS -->
        <div class="card p-6 mb-8">
            <h2 class="text-xl font-semibold text-gray-700 mb-4">Current Real Position</h2>
            <div class="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
                <div><p class="text-gray-500">Symbol</p><p class="font-mono text-lg text-indigo-600">{SYMBOL}</p></div>
                <div><p class="text-gray-500">Status / Size</p><p class="font-bold text-lg">{pos_status}</p></div>
                <div><p class="text-gray-500">Entry Price</p><p class="font-mono text-lg">{entry_price}</p></div>
                <div><p class="text-gray-500">Unrealized PnL (USDT)</p><p class="font-mono text-lg font-bold {pnl_class}">{pnl_usdt}</p></div>
            </div>
        </div>

        <!-- AI PREDICTION & NEXT ACTION -->
        <div class="card p-6 {pred_status_class}">
            <h2 class="text-xl font-bold text-gray-800 mb-4">AI Prediction & Next Action</h2>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 text-sm font-medium">
                <div>
                    <p class="text-gray-600">Predicted PnL (Next Trade)</p>
                    <p class="text-2xl font-bold mt-1 text-gray-900">{pred_pnl:.4f} USDT</p>
                </div>
                <div>
                    <p class="text-gray-600">Confidence Score</p>
                    <p class="text-2xl font-bold mt-1 text-gray-900">{confidence:.2f}</p>
                </div>
                <div>
                    <p class="text-gray-600">Action Signal</p>
                    <p class="text-2xl font-bold mt-1 text-indigo-700">{'BUY (LONG)' if pred_pnl > 0 and confidence > WIN_CONFIDENCE_THRESHOLD else 'HOLD / WAIT'}</p>
                </div>
            </div>
            <p class="text-xs mt-4 text-gray-600">Prediction is based on current market state and {len(historical_df)} simulated learning points.</p>
        </div>

        <!-- BOT LOG/METRICS (Simulated Trades Count) -->
        <div class="mt-8">
            <h2 class="text-xl font-semibold text-gray-700 mb-4">Learning Metrics</h2>
            <div class="card p-6 bg-gray-50">
                <p class="text-sm text-gray-600">Total Learning Data Points (Simulated Trades): <span class="font-bold">{len(historical_df)}</span></p>
                <p class="text-sm text-gray-600">Realized (Closed) Learning Trades: <span class="font-bold">{historical_df['realized'].sum()}</span></p>
            </div>
        </div>

    </div>
</body>
</html>
    """
    
    try:
        with open(DASHBOARD_PATH, 'w') as f:
            f.write(html_content)
    except Exception as e:
        print(f"ERROR: Could not write HTML dashboard to {DASHBOARD_PATH}. Check permissions: {e}")

# --- MAIN BOT LOGIC (Added extensive checks) ---

def main():
    """The main trading loop of the bot."""
    global historical_df 
    
    close_all_positions_on_start()
    
    scaler = StandardScaler()
    ml_model = SGDRegressor(random_state=42, max_iter=1000, tol=1e-3, penalty='l2') 
    
    realized_wins = 0
    realized_losses = 0
    ml_accuracy = 0.0
    
    print("AI Futures Bot Initialized. Starting continuous trading loop...")

    while True:
        start_time = time.time()
        
        # --- STEP 1: Get Real-Time Data ---
        wallet_balance = get_wallet_balance()
        bid, ask = get_current_prices()
        mid_price = (bid + ask) / 2
        
        print(f"\n--- {datetime.now().strftime('%H:%M:%S')} ---")
        print(f"Wallet: ${wallet_balance:.2f} | Bid: {bid:.8f} | Ask: {ask:.8f}")
        
        # --- STEP 2: Update Historical Data & Indicators ---
        new_data = pd.DataFrame([{
            'timestamp': datetime.now(), 
            'bid': bid, 
            'ask': ask, 
            'mid_price': mid_price, 
            'price_change': 0.0, 'cci': 0.0, 'rsi': 0.0, 'volatility': 0.0, 
            'PnL_Future': 0.0, 'trade_size': 0.0, 'direction': 'none', 
            'realized': False 
        }]).set_index('timestamp')

        historical_df = pd.concat([historical_df, new_data])
        historical_df = historical_df.iloc[-LOOKBACK_PERIOD:] 
        historical_df = calculate_indicators(historical_df)
        
        # --- STEP 3: ML Training & Prediction ---
        ml_model_trained = False
        if len(historical_df) >= MIN_TRAINING_SAMPLES:
            scaler, ml_model, ml_model_trained, ml_accuracy = setup_and_train_ml_model(historical_df, scaler, ml_model)
        
        pred_pnl, confidence, pred_direction = get_ml_prediction(historical_df, scaler, ml_model)
        
        print(f"ML: Pred PnL={pred_pnl:.6f} | Confidence={confidence:.2f} | Signal={pred_direction.upper()}")
        print(f"ML Accuracy (Realized): {ml_accuracy:.2f}%")

        # --- STEP 4: Position Management (Fetch & Check TP) ---
        current_position = parse_position_info()
        historical_df, closed, msg = check_for_take_profit(current_position, (bid, ask), historical_df)
        
        if closed:
            current_position = parse_position_info()
            if msg and "PnL" in msg:
                pnl_str = msg.split("PnL ")[-1].split(" USDT")[0]
                try:
                    closed_pnl = float(pnl_str)
                    if closed_pnl > 0:
                        realized_wins += 1
                    else:
                        realized_losses += 1
                except:
                    pass
        
        print(f"Position Status: {'FLAT' if current_position is None else f'{current_position['direction'].upper()} {current_position['quantity']:.4f} ATOM (PnL: {current_position['pnl']:.4f} USDT)'}")

        # --- STEP 5: Trade Execution (Open/Increase Position) ---
        
        is_flat = current_position is None or current_position['quantity'] == 0
        can_open_trade = False
        
        # Check primary ML gates and implement the bootstrap fix
        if not ml_model_trained:
            # BOOTSTRAP CHECK: If model is untrained, allow initial trade if flat and signal is positive.
            if is_flat and pred_pnl > 0.0:
                print("TRADE BOOTSTRAP: Allowing initial trade to gather first PnL data points (ML untrained, positive signal, flat).")
                can_open_trade = True
            else:
                print("TRADE BLOCKED: ML model is untrained and cannot bootstrap (position already open or no positive signal).")
                can_open_trade = False
        elif pred_pnl <= 0.0:
            print(f"TRADE BLOCKED: Predicted PnL ({pred_pnl:.6f}) is not positive.")
            can_open_trade = False
        elif confidence < WIN_CONFIDENCE_THRESHOLD:
            print(f"TRADE BLOCKED: Confidence ({confidence:.2f}) is below threshold ({WIN_CONFIDENCE_THRESHOLD}).")
            can_open_trade = False
        else:
            # All ML gates passed (trained, positive PnL, high confidence)
            can_open_trade = True


        if can_open_trade:
            # All ML gates passed, calculate quantity
            quantity_to_trade = calculate_adaptive_quantity(
                wallet_balance, 
                current_position, 
                pred_pnl, 
                pred_direction
            )
            
            if quantity_to_trade > 0.0:
                if current_position and current_position['direction'] != pred_direction and current_position['quantity'] > 0:
                    print("TRADE BLOCKED: Waiting for existing opposite position to close before opening new direction.")
                else:
                    success, trade_msg = execute_trade(quantity_to_trade, pred_direction, current_position, (bid, ask))
                    print(f"TRADE EXECUTION RESULT: {trade_msg}")
                    
                    if success:
                        historical_df.loc[historical_df.index[-1], 'trade_size'] = quantity_to_trade
                        historical_df.loc[historical_df.index[-1], 'direction'] = pred_direction
                        
                    current_position = parse_position_info()
            else:
                 print("TRADE BLOCKED: Adaptive sizing returned 0.0 quantity (risk cap or Martingale conditions not met).")
        
        # --- STEP 6: Dashboard Update & Persistence ---
        current_pnl = current_position['pnl'] if current_position else 0.0
        update_dashboard(wallet_balance, current_position, pred_pnl, confidence, ml_accuracy, realized_wins, realized_losses)
        
        try:
            # Save historical data in every loop for resilience
            historical_df.to_csv('historical_data.csv')
        except Exception as e:
            print(f"WARNING: Could not save historical data: {e}")
            
        # --- STEP 7: Delay for loop interval ---
        elapsed = time.time() - start_time
        sleep_time = max(0, INTERVAL_SECONDS - elapsed)
        # print(f"Loop time: {elapsed:.2f}s. Sleeping for {sleep_time:.2f}s.")
        time.sleep(sleep_time)

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\nBot interrupted by user. Exiting gracefully.")
    except Exception as e:
        print(f"CRITICAL ERROR in main loop: {e}")
