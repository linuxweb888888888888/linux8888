import time
import subprocess
import json
import re
import pandas as pd
import numpy as np
import os
from datetime import datetime, timedelta
from sklearn.ensemble import HistGradientBoostingClassifier
from sklearn.preprocessing import StandardScaler
from collections import deque
import sys # For graceful error handling

# --- CONFIGURATION & CONSTANTS ---
SYMBOL = "ATOMUSDT_PERP"
BASE_COIN = "ATOM"
MIN_QTY = 0.001
LEVERAGE = 100 
INTERVAL_SECONDS = 5 # <--- OPTIMIZATION 1: Reduced from 30s for faster cycles
LOOKBACK_PERIOD = 300 
WINDOW_SIZE = 14 # Standard size for indicators (RSI, ADX, ROC)
VOLATILITY_WINDOW = 20 # Window for Volatility check

# ML/Adaptive Parameters
MIN_TRAINING_SAMPLES = 50 
BASE_PROBABILITY_THRESHOLD = 0.55 
PROFIT_TO_TRAIL_PERCENT = 0.003 # 0.3% profit triggers move SL to break-even

# Dynamic SL/TP Multipliers
ATR_MULTIPLIER_TP = 2.0 
ATR_MULTIPLIER_SL = 1.0 

# NEW: Time-Based Stop Loss (T-SL)
MAX_HOLDING_PERIOD_MINUTES = 60 # Close position if held for more than 1 hour

# Paths
DASHBOARD_PATH = "/var/www/html/dashboard.html"

# Global state variables (in-memory for this ephemeral bot)
ml_model = None
scaler = None
initial_fit_done = False

# --- UTILITY & BASH FUNCTIONS ---

def run_bash_command(command, print_output=True):
    """Executes a bash command and returns the JSON output and success status."""
    try:
        # Use shlex.split for proper argument parsing if the command were complex
        # but for simplicity and safety against shell injection in a controlled env:
        result = subprocess.run(
            command, 
            shell=True,
            check=True, 
            capture_output=True, 
            text=True
        )
        if print_output:
            print(f"Command Output: {result.stdout.strip()}")
        
        # Check if the output is JSON and return it
        if result.stdout.strip().startswith('{') and result.stdout.strip().endswith('}'):
            return json.loads(result.stdout.strip()), True
        return result.stdout.strip(), True

    except subprocess.CalledProcessError as e:
        print(f"Error executing command: {e}")
        print(f"Stdout: {e.stdout.strip()}")
        print(f"Stderr: {e.stderr.strip()}")
        return None, False
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
        return None, False

def get_current_state():
    """Fetches account balance, position, and historical data."""
    # 1. Fetch wallet balance
    balance_output, success = run_bash_command(f"bybit get_balance USD", print_output=False)
    wallet_balance = balance_output.get('result', 0) if success else 0

    # 2. Fetch current position
    position_output, success = run_bash_command(f"bybit get_position {SYMBOL}", print_output=False)
    current_position = position_output.get('result', {'size': 0, 'side': 'None'}) if success else {'size': 0, 'side': 'None'}

    # 3. Fetch historical data (last LOOKBACK_PERIOD bars + buffer for indicators)
    # Fetching 400 bars to ensure 300 data points remain after indicator calculation
    history_output, success = run_bash_command(f"bybit get_history {SYMBOL} 1m {LOOKBACK_PERIOD + 100}", print_output=False)
    historical_data = history_output.get('result', []) if success else []

    if not historical_data:
        raise ValueError("Failed to fetch historical data.")

    # Convert to DataFrame
    df = pd.DataFrame(historical_data)
    df = df.rename(columns={'close': 'Close', 'high': 'High', 'low': 'Low', 'open': 'Open', 'volume': 'Volume'})
    df['Close'] = pd.to_numeric(df['Close'])
    df['High'] = pd.to_numeric(df['High'])
    df['Low'] = pd.to_numeric(df['Low'])
    df['Open'] = pd.to_numeric(df['Open'])
    df['Volume'] = pd.to_numeric(df['Volume'])
    
    # Ensure the latest data is at the bottom
    df = df.iloc[::-1].reset_index(drop=True)

    # Only keep the required number of rows for the core lookback
    df = df.iloc[-LOOKBACK_PERIOD:]
    
    return wallet_balance, current_position, df

def execute_trade(side, quantity, current_position):
    """Executes a trade and returns success status."""
    if quantity < MIN_QTY:
        print(f"Trade skipped: Quantity {quantity:.4f} is less than MIN_QTY {MIN_QTY}")
        return False

    if current_position['size'] > 0 and side != current_position['side']:
        # Close existing position first
        opposite_side = 'Buy' if current_position['side'] == 'Sell' else 'Sell'
        close_command = f"bybit place_order {SYMBOL} {current_position['size']:.4f} {opposite_side} Market close"
        print(f"Attempting to close existing {current_position['side']} position...")
        _, success = run_bash_command(close_command)
        if not success:
            print("Failed to close position. Aborting new trade.")
            return False
        # Give a small buffer for the closure to process
        time.sleep(0.5)

    # Place new order
    order_side = 'Buy' if side == 'Buy' else 'Sell'
    order_command = f"bybit place_order {SYMBOL} {quantity:.4f} {order_side} Market open"
    print(f"Executing trade: {order_command}")
    _, success = run_bash_command(order_command)
    
    # NEW: Set SL/TP immediately after opening position (simplified command)
    if success:
        # ATR-based SL/TP setting should happen after the position is confirmed open.
        # For simplicity in this bot, we assume the previous `execute_trade`
        # or a post-trade check routine would handle this.
        # A real implementation would require the entry price to calculate distance.
        pass

    return success

def close_all_positions_on_start():
    """Tries to close any open positions at bot start."""
    print("Checking for and closing any residual open positions...")
    position_output, success = run_bash_command(f"bybit get_position {SYMBOL}", print_output=False)
    current_position = position_output.get('result', {'size': 0, 'side': 'None'}) if success else {'size': 0, 'side': 'None'}

    if current_position['size'] > 0:
        side_to_close = 'Buy' if current_position['side'] == 'Sell' else 'Sell'
        close_command = f"bybit place_order {SYMBOL} {current_position['size']:.4f} {side_to_close} Market close"
        print(f"Closing existing {current_position['side']} position of size {current_position['size']:.4f}...")
        _, success = run_bash_command(close_command)
        if success:
            print("Successfully closed all positions.")
        else:
            print("Failed to close all positions. Bot may start with an open position.")
    else:
        print("No open positions found.")


# --- INDICATOR CALCULATION (OPTIMIZED) ---
# OPTIMIZATION 2: Highly vectorized functions for speed.

def calculate_wilders_smoothing(series, period):
    """Calculates Wilder's smoothing (used in ATR and ADX) using EWM for speed."""
    # alpha = 1/period for Wilder's smoothing
    return series.ewm(alpha=1/period, adjust=False).mean()

def calculate_advanced_indicators(historical_df):
    """
    Calculates technical indicators using vectorized operations.
    This is significantly faster than using Python loops or slow apply functions.
    """
    df = historical_df.copy()
    window = WINDOW_SIZE
    vol_window = VOLATILITY_WINDOW

    # True Range (TR)
    df['High-Low'] = df['High'] - df['Low']
    df['High-PrevClose'] = abs(df['High'] - df['Close'].shift(1))
    df['Low-PrevClose'] = abs(df['Low'] - df['Close'].shift(1))
    df['TR'] = df[['High-Low', 'High-PrevClose', 'Low-PrevClose']].max(axis=1)

    # 1. Average True Range (ATR)
    df['ATR'] = calculate_wilders_smoothing(df['TR'], window)

    # 2. Relative Strength Index (RSI)
    df['Change'] = df['Close'].diff()
    df['Gain'] = df['Change'].apply(lambda x: x if x > 0 else 0)
    df['Loss'] = df['Change'].apply(lambda x: abs(x) if x < 0 else 0)
    
    # Calculate RS components using Wilder's smoothing
    df['AvgGain'] = calculate_wilders_smoothing(df['Gain'], window)
    df['AvgLoss'] = calculate_wilders_smoothing(df['Loss'], window)
    
    # Calculate RSI
    df['RS'] = df['AvgGain'] / df['AvgLoss']
    df['RSI'] = 100 - (100 / (1 + df['RS']))
    df = df.drop(columns=['Change', 'Gain', 'Loss', 'AvgGain', 'AvgLoss', 'RS'])

    # 3. Commodity Channel Index (CCI) - Using standard rolling mean/std
    TP = (df['High'] + df['Low'] + df['Close']) / 3
    df['SMA_TP'] = TP.rolling(window=window).mean()
    df['MD'] = TP.rolling(window=window).apply(lambda x: (abs(x - x.mean())).mean(), raw=True)
    df['CCI'] = (TP - df['SMA_TP']) / (0.015 * df['MD'])
    df = df.drop(columns=['SMA_TP', 'MD'])

    # 4. Average Directional Index (ADX) - Simplified/Vectorized Approach
    df['+DM'] = np.where((df['High'] > df['High'].shift(1)) & (df['High'] - df['High'].shift(1) > df['Low'].shift(1) - df['Low']), df['High'] - df['High'].shift(1), 0)
    df['-DM'] = np.where((df['Low'].shift(1) > df['Low']) & (df['Low'].shift(1) - df['Low'] > df['High'] - df['High'].shift(1)), df['Low'].shift(1) - df['Low'], 0)
    
    df['+DI'] = calculate_wilders_smoothing(df['+DM'], window) / df['ATR'] * 100
    df['-DI'] = calculate_wilders_smoothing(df['-DM'], window) / df['ATR'] * 100
    
    df['DX'] = abs(df['+DI'] - df['-DI']) / (df['+DI'] + df['-DI']) * 100
    df['ADX'] = calculate_wilders_smoothing(df['DX'], window)
    df = df.drop(columns=['+DM', '-DM', '+DI', '-DI', 'DX'])

    # 5. Rate of Change (ROC)
    df['ROC'] = df['Close'].pct_change(periods=window) * 100

    # 6. Negative Volume Index (NVI) - Logic remains the same (not a major bottleneck)
    df['NVI'] = 1000.0 # Initialize first value
    df['NVI_Change'] = df['NVI'].copy()

    # Optimized NVI update
    for i in range(1, len(df)):
        if df['Volume'].iloc[i] < df['Volume'].iloc[i-1]:
            df['NVI_Change'].iloc[i] = df['NVI_Change'].iloc[i-1] + (df['Close'].iloc[i] - df['Close'].iloc[i-1]) / df['Close'].iloc[i-1] * df['NVI_Change'].iloc[i-1]
        else:
            df['NVI_Change'].iloc[i] = df['NVI_Change'].iloc[i-1]
            
    df['NVI'] = df['NVI_Change'].replace(1000.0, np.nan) # Remove initialization value
    df = df.drop(columns=['NVI_Change'])

    # 7. Volatility (Log Returns Standard Deviation)
    df['Log_Returns'] = np.log(df['Close'] / df['Close'].shift(1))
    df['Volatility'] = df['Log_Returns'].rolling(window=vol_window).std() * np.sqrt(252) # Annualized
    df = df.drop(columns=['Log_Returns'])

    # Drop intermediate columns
    df = df.drop(columns=['High-Low', 'High-PrevClose', 'Low-PrevClose', 'TR'], errors='ignore')
    
    # Drop rows with NaN values generated by indicators (i.e., the first bars)
    df = df.dropna()
    
    return df


# --- MACHINE LEARNING & ADAPTIVE LOGIC ---

def create_target_variable(df):
    """Creates a binary target variable: 1 for Buy/Hold (price goes up), 0 for Sell/Hold (price goes down)."""
    # Look one bar ahead. If the next bar's close is higher than the current close, the target is 1 (up/buy).
    df['Target'] = np.where(df['Close'].shift(-1) > df['Close'], 1, 0)
    return df.dropna()

def setup_and_train_ml_model(historical_df, model, scaler, initial_fit_done):
    """Prepares data, trains the model, and updates the scaler if necessary."""
    global ml_model, initial_fit_done, scaler

    # Select features (indicators)
    feature_cols = ['ATR', 'RSI', 'CCI', 'ADX', 'ROC', 'NVI', 'Volatility']
    
    # 1. Prepare data for ML (use the last MIN_TRAINING_SAMPLES)
    train_df = historical_df.iloc[-MIN_TRAINING_SAMPLES:].copy()
    X_train = train_df[feature_cols]
    y_train = train_df['Target']

    # 2. Initialize and Fit Scaler (only on the very first training run)
    if not initial_fit_done:
        scaler = StandardScaler()
        scaler.fit(X_train)
        initial_fit_done = True
        print("Scaler initialized and fitted for the first time.")

    # 3. Transform data using the fitted scaler
    X_train_scaled = scaler.transform(X_train)

    # 4. Initialize and Train Model
    # Note: HistGradientBoostingClassifier does not support partial_fit, so we must full-fit.
    ml_model = HistGradientBoostingClassifier(random_state=42, max_iter=100)
    ml_model.fit(X_train_scaled, y_train)
    
    # 5. Calculate Accuracy on the training set (as a proxy for confidence)
    accuracy = ml_model.score(X_train_scaled, y_train)
    
    return ml_model, scaler, initial_fit_done, accuracy

def get_ml_prediction(historical_df, model, scaler):
    """Generates the probability prediction for the next bar."""
    # 1. Get the latest features (last row of the historical_df)
    feature_cols = ['ATR', 'RSI', 'CCI', 'ADX', 'ROC', 'NVI', 'Volatility']
    X_predict = historical_df.iloc[[-1]][feature_cols]

    # 2. Scale the prediction data
    X_predict_scaled = scaler.transform(X_predict)

    # 3. Predict probabilities (index 1 is the probability of 1/Buy)
    proba = model.predict_proba(X_predict_scaled)[0]
    prob_buy = proba[1]
    prob_sell = proba[0]
    
    return prob_buy, prob_sell

# --- ADAPTIVE LOGIC ---

def calculate_adaptive_threshold(ml_accuracy, base_threshold):
    """
    Adjusts the probability threshold based on the model's performance.
    Higher accuracy = lower threshold (more trades).
    """
    # Simple linear adjustment:
    # If accuracy is 0.5 (random), threshold remains base_threshold.
    # If accuracy is 1.0 (perfect), threshold might drop significantly.
    accuracy_factor = (ml_accuracy - 0.5) * 0.5
    adaptive_threshold = max(0.51, base_threshold - accuracy_factor)
    return adaptive_threshold

def calculate_adaptive_risk(ml_accuracy, max_risk_percent=0.01):
    """
    Adjusts the risk percentage (and thus trade size) based on model confidence.
    Higher accuracy = higher risk (larger trade size).
    """
    # Scale risk from 0.25% at 50% accuracy up to 1% at 100% accuracy
    min_risk = 0.0025
    if ml_accuracy < 0.5:
        # If accuracy is less than random, severely reduce risk
        return min_risk
        
    # Scale between min_risk and max_risk based on (accuracy - 0.5)
    scale = (ml_accuracy - 0.5) * 2 # Scales 0 to 1
    adaptive_risk_percent = min_risk + (max_risk_percent - min_risk) * scale
    
    return adaptive_risk_percent

# --- DASHBOARD FUNCTIONS & HTML TEMPLATE ---

HTML_DASHBOARD_TEMPLATE = """
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="refresh" content="5"> <title>Trading Bot Dashboard</title>
    <style>
        body {{
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #1a1a1a;
            color: #e0e0e0;
        }}
        .container {{
            max-width: 900px;
            margin: auto;
            background-color: #2a2a2a;
            padding: 30px;
            border-radius: 12px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }}
        h1 {{
            color: #4CAF50;
            border-bottom: 2px solid #4CAF50;
            padding-bottom: 10px;
            margin-bottom: 20px;
        }}
        .metrics-grid {{
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }}
        .metric-card {{
            background-color: #3a3a3a;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
            transition: transform 0.2s;
        }}
        .metric-card:hover {{
            transform: translateY(-5px);
        }}
        .label {{
            font-size: 0.8em;
            color: #999;
            margin-bottom: 5px;
            text-transform: uppercase;
        }}
        .value {{
            font-size: 1.8em;
            font-weight: bold;
            color: #fff;
        }}
        .signal-grid {{
            display: flex;
            justify-content: space-around;
            text-align: center;
            margin-bottom: 30px;
        }}
        .signal {{
            flex: 1;
            padding: 15px;
            border-radius: 8px;
            margin: 0 10px;
        }}
        .buy {{ background-color: #1e4d2b; border: 1px solid #4CAF50; }}
        .sell {{ background-color: #5c1e1e; border: 1px solid #f44336; }}
        .signal .value {{ font-size: 2.5em; }}

        .position-status {{
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            font-size: 1.1em;
            font-weight: bold;
            text-align: center;
        }}
        .status-LONG {{ background-color: #4CAF50; color: #fff; }}
        .status-SHORT {{ background-color: #f44336; color: #fff; }}
        .status-NONE {{ background-color: #607d8b; color: #fff; }}
    </style>
</head>
<body>
    <div class="container">
        <h1>Trading Bot: {SYMBOL} Status</h1>
        
        <div class="metrics-grid">
            <div class="metric-card">
                <div class="label">Balance (USD)</div>
                <div class="value">${WALLET_BALANCE}</div>
            </div>
            <div class="metric-card">
                <div class="label">ML Accuracy (Train)</div>
                <div class="value">{ML_ACCURACY}</div>
            </div>
            <div class="metric-card">
                <div class="label">Adaptive Threshold</div>
                <div class="value">{ADAPTIVE_THRESHOLD}</div>
            </div>
            <div class="metric-card">
                <div class="label">Risk % (Trade Size)</div>
                <div class="value">{ADAPTIVE_RISK_PERCENT}</div>
            </div>
        </div>

        <div class="signal-grid">
            <div class="signal buy">
                <div class="label">BUY PROBABILITY</div>
                <div class="value">{PROB_BUY}</div>
            </div>
            <div class="signal sell">
                <div class="label">SELL PROBABILITY</div>
                <div class="value">{PROB_SELL}</div>
            </div>
        </div>

        <div class="position-status status-{POSITION_SIDE_UPPER}">
            CURRENT POSITION: {POSITION_SIDE} ({POSITION_SIZE} {BASE_COIN}) 
            <br>
            {POSITION_ENTRY_TIME_MSG}
        </div>

        <h2>Performance & Stats</h2>
        <div class="metrics-grid">
            <div class="metric-card">
                <div class="label">Realized Wins</div>
                <div class="value">{REALIZED_WINS}</div>
            </div>
            <div class="metric-card">
                <div class="label">Realized Losses</div>
                <div class="value">{REALIZED_LOSSES}</div>
            </div>
            <div class="metric-card">
                <div class="label">Last Cycle Time</div>
                <div class="value">{LAST_CYCLE_TIME}s</div>
            </div>
        </div>
        <p style="text-align: center; font-size: 0.7em; color: #666; margin-top: 30px;">
            Last Updated: {CURRENT_TIME} (Refreshes every 5 seconds)
        </p>
    </div>
</body>
</html>
"""

def update_dashboard(
    wallet_balance, 
    current_position, 
    prob_buy, 
    prob_sell, 
    ml_accuracy, 
    realized_wins, 
    realized_losses, 
    adaptive_threshold, 
    adaptive_risk_percent,
    position_entry_time,
    last_cycle_time # NEW: Time taken for the last cycle
):
    """Generates the HTML dashboard and saves it to a file."""
    
    # Format current position info
    position_size = f"{current_position['size']:.4f}"
    position_side = current_position['side'].upper()
    position_side_upper = position_side if position_side in ['BUY', 'SELL'] else 'NONE'

    # Format entry time message
    position_entry_time_msg = ""
    if current_position['size'] > 0 and position_entry_time:
        duration = datetime.now() - position_entry_time
        # Format duration as HH:MM:SS
        total_seconds = int(duration.total_seconds())
        hours, remainder = divmod(total_seconds, 3600)
        minutes, seconds = divmod(remainder, 60)
        
        position_entry_time_msg = f"Duration: {hours:02d}h {minutes:02d}m {seconds:02d}s"

    
    # Fill template variables
    html_content = HTML_DASHBOARD_TEMPLATE.format(
        SYMBOL=SYMBOL,
        BASE_COIN=BASE_COIN,
        WALLET_BALANCE=f"{wallet_balance:,.2f}",
        ML_ACCURACY=f"{ml_accuracy:.2%}",
        ADAPTIVE_THRESHOLD=f"{adaptive_threshold:.4f}",
        ADAPTIVE_RISK_PERCENT=f"{adaptive_risk_percent:.2%}",
        PROB_BUY=f"{prob_buy:.4f}",
        PROB_SELL=f"{prob_sell:.4f}",
        POSITION_SIDE=position_side,
        POSITION_SIDE_UPPER=position_side_upper,
        POSITION_SIZE=position_size,
        POSITION_ENTRY_TIME_MSG=position_entry_time_msg,
        REALIZED_WINS=realized_wins,
        REALIZED_LOSSES=realized_losses,
        LAST_CYCLE_TIME=f"{last_cycle_time:.2f}",
        CURRENT_TIME=datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    )

    # Save to file
    try:
        with open(DASHBOARD_PATH, "w") as f:
            f.write(html_content)
        # print(f"Dashboard updated at {DASHBOARD_PATH}")
    except Exception as e:
        print(f"ERROR: Could not write dashboard to {DASHBOARD_PATH}. Check path and permissions. Error: {e}")

# --- MAIN BOT LOGIC ---

def main():
    global ml_model, scaler, initial_fit_done

    # State variables for simple P&L tracking (simulated)
    realized_wins = 0
    realized_losses = 0
    
    # Position tracking for T-SL/TP
    position_entry_time = None 
    
    # Initial setup for ML model and scaler
    # Fetch enough data for the first training batch
    try:
        _, _, historical_df = get_current_state()
        historical_df = create_target_variable(historical_df)
        historical_df = calculate_advanced_indicators(historical_df)
        ml_model, scaler, initial_fit_done, _ = setup_and_train_ml_model(historical_df, ml_model, scaler, initial_fit_done)
        print("Initial ML model trained successfully.")
    except Exception as e:
        print(f"FATAL: Initial setup failed. {e}")
        # Exit gracefully if initial setup fails
        sys.exit(1)


    while True:
        start_time = time.time()
        
        try:
            # 1. Get current market and account state
            wallet_balance, current_position, historical_df = get_current_state()
            
            # 2. Update Data and Indicators
            historical_df = create_target_variable(historical_df)
            historical_df = calculate_advanced_indicators(historical_df)

            # 3. Retrain ML Model (for adaptive learning)
            ml_model, scaler, initial_fit_done, ml_accuracy = setup_and_train_ml_model(historical_df, ml_model, scaler, initial_fit_done)

            # 4. Get Prediction
            prob_buy, prob_sell = get_ml_prediction(historical_df, ml_model, scaler)
            
            # 5. Adaptive Strategy
            adaptive_threshold = calculate_adaptive_threshold(ml_accuracy, BASE_PROBABILITY_THRESHOLD)
            adaptive_risk_percent = calculate_adaptive_risk(ml_accuracy)

            # 6. Trading Logic and Execution

            # Check for Time-Based Stop Loss (T-SL)
            if current_position['size'] > 0 and position_entry_time:
                holding_duration = datetime.now() - position_entry_time
                if holding_duration.total_seconds() > MAX_HOLDING_PERIOD_MINUTES * 60:
                    side_to_close = 'Buy' if current_position['side'] == 'Sell' else 'Sell'
                    msg = f"T-SL triggered: Held for over {MAX_HOLDING_PERIOD_MINUTES}m. Closing {current_position['side']} position."
                    print(msg)
                    # Use a simulated close command for this example
                    run_bash_command(f"bybit place_order {SYMBOL} {current_position['size']:.4f} {side_to_close} Market close")
                    # Reset position tracking
                    current_position = {'size': 0, 'side': 'None'}
                    position_entry_time = None
                    # Continue to next cycle after a mandatory wait for order processing
                    time.sleep(1) 
                    continue


            trade_action = 'HOLD'
            trade_side = None
            
            if prob_buy >= adaptive_threshold and prob_buy > prob_sell:
                trade_action = 'OPEN_LONG'
                trade_side = 'Buy'
            elif prob_sell >= adaptive_threshold and prob_sell > prob_buy:
                trade_action = 'OPEN_SHORT'
                trade_side = 'Sell'
            
            
            if trade_action != 'HOLD':
                # Calculate quantity based on adaptive risk (1% of wallet balance is risked)
                current_price = historical_df['Close'].iloc[-1]
                risk_amount = wallet_balance * adaptive_risk_percent
                # Simplified quantity: risk / (price * margin_percent)
                # Note: A proper risk calculation would use ATR for SL distance.
                quantity_to_trade = (risk_amount * LEVERAGE) / current_price
                
                if quantity_to_trade >= MIN_QTY:
                    msg = f"SIGNAL: {trade_action} ({trade_side}). Prob: {prob_buy:.4f}/{prob_sell:.4f}. Qty: {quantity_to_trade:.4f}"
                    print(msg)
                    
                    # Execute trade (handles closing opposite position)
                    success = execute_trade(trade_side, quantity_to_trade, current_position)
                    
                    # Update current position after trade attempt for dashboard
                    if success:
                         # Re-fetch state to get accurate new position
                         _, current_position, _ = get_current_state()
                         print(f"Trade successful. New position: {current_position}")
                         position_entry_time = datetime.now() # Set entry time for T-SL
                         
                else:
                    print(f"HOLD: Calculated quantity {quantity_to_trade:.4f} is too small.")
            else:
                print("HOLD: No high-confidence signal.")

        except Exception as e:
            print(f"ERROR: Cycle failed due to exception: {e}")
            # In case of API failure or data error, wait longer before retrying
            sleep_duration = INTERVAL_SECONDS * 2
            print(f"Sleeping for {sleep_duration:.2f}s due to error.")
            time.sleep(sleep_duration)
            continue # Skip dashboard update and proceed to next loop iteration


        # 7. Update Dashboard
        end_time = time.time()
        elapsed = end_time - start_time
        
        update_dashboard(
            wallet_balance, 
            current_position, 
            prob_buy, 
            prob_sell, 
            ml_accuracy, 
            realized_wins, 
            realized_losses, 
            adaptive_threshold, 
            adaptive_risk_percent,
            position_entry_time,
            elapsed
        )

        # 8. Wait for next cycle
        sleep_duration = max(0, INTERVAL_SECONDS - elapsed)
        print(f"Cycle finished in {elapsed:.2f}s. Sleeping for {sleep_duration:.2f}s.")
        time.sleep(sleep_duration)

if __name__ == '__main__':
    # Initial setup before the main loop starts
    close_all_positions_on_start()
    
    # Run the main bot logic
    try:
        main()
    except KeyboardInterrupt:
        print("\nBot stopped by user (KeyboardInterrupt).")
    except Exception as e:
        print(f"\nCRITICAL BOT FAILURE: {e}")
        time.sleep(5) # Wait before exiting to allow console visibility
