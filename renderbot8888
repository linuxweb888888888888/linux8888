import ccxt
import time
import subprocess
import pandas as pd
import numpy as np
import os
import re
import logging
from datetime import datetime
from sklearn.ensemble import RandomForestRegressor
from sklearn.preprocessing import StandardScaler
from collections import deque

# ------------------------------------------------------------------------------
# CONFIGURATION
# ------------------------------------------------------------------------------
SYMBOL_CCXT = 'ATOM/USDT'      # For CCXT Fetching
SYMBOL_BASH = 'ATOMUSDT_PERP'  # For Bash Scripts
BASE_COIN = 'ATOM'             # For placeorder arguments
MIN_QTY = 0.001                # Minimum step size (Confirmed 0.001)
# NEW: Calculate required decimal precision from MIN_QTY for robust stepping
DECIMAL_PRECISION = len(str(MIN_QTY).split('.')[-1]) 
DASHBOARD_PATH = '/var/www/html/dashboard.html'
MAX_HISTORY = 200              # Data points for ML training
TRAINING_INTERVAL = 1          # Train every step for max adaptation
FEE_RATE = 0.0006              # Est. Taker fee (0.06%)
# MAX SPEED: Target 0.01% gross profit + fees for immediate closure
TARGET_PROFIT_PCT = 0.0001     
# MAX SPEED: Averaging down extremely close (0.1%)
GRID_STEP_PCT = 0.001          
# MAX SPEED: Larger initial entry size to maximize tiny profits
INITIAL_ENTRY_SIZE_MULTIPLIER = 2.0 

# ------------------------------------------------------------------------------
# LOGGING SETUP
# ------------------------------------------------------------------------------
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger()

# ------------------------------------------------------------------------------
# SYSTEM INTERFACE (Bash Scripts)
# ------------------------------------------------------------------------------
class SystemInterface:
    @staticmethod
    def run_command(command_list):
        try:
            # Added shorter timeout for faster feedback loop
            result = subprocess.run(command_list, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, timeout=3)
            return result.stdout.strip()
        except Exception as e:
            logger.error(f"Command failed: {command_list} | Error: {e}")
            return None

    @staticmethod
    def get_wallet_balance():
        """Reads USDT balance from /wallet.sh. First line is USDT."""
        output = SystemInterface.run_command(['bash', '/wallet.sh'])
        if output:
            try:
                lines = output.split('\n')
                balance = float(lines[0].strip())
                return balance
            except ValueError:
                logger.error("Could not parse wallet balance.")
        return 0.0

    @staticmethod
    def get_real_position(symbol_bash):
        """Parses /coinrealinfo.sh output."""
        output = SystemInterface.run_command(['bash', '/coinrealinfo.sh', symbol_bash])
        
        data = {
            'symbol': symbol_bash,
            'qty': 0.0,
            'entry_price': 0.0,
            'has_position': False
        }

        if not output or "NO INFO" in output or output == "":
            return data

        try:
            qty_match = re.search(r'Quantity:\s*([\d\.-]+)', output)
            entry_match = re.search(r'Entry Price:\s*([\d\.-]+)', output)

            if qty_match:
                data['qty'] = float(qty_match.group(1))
            if entry_match:
                data['entry_price'] = float(entry_match.group(1))
            
            if abs(data['qty']) > 0:
                data['has_position'] = True
                
        except Exception as e:
            logger.error(f"Error parsing coin info: {e}")

        return data

    @staticmethod
    def place_order(coin_base, qty, side):
        """
        Executes /placeorder.sh (base) (qty) (side)
        """
        cmd = ['bash', '/placeorder.sh', coin_base, str(qty), side]
        output = SystemInterface.run_command(cmd)
        if output and "SUCCESS" in output:
            logger.info(f"Order SUCCESS: {side} {qty} {coin_base}")
            return True
        else:
            logger.error(f"Order ERROR: {output}")
            return False

    @staticmethod
    def close_all_positions():
        """Runs /closepositions.sh"""
        output = SystemInterface.run_command(['bash', '/closepositions.sh'])
        logger.info(f"Close Positions: {output}")
        return output

# ------------------------------------------------------------------------------
# WALLET LEARNER (ULTRA-AGGRESSIVE MODE)
# ------------------------------------------------------------------------------
class WalletLearner:
    def __init__(self):
        self.initial_balance = 0.0
        self.current_balance = 0.0
        self.previous_balance = 0.0
        self.trade_history = deque(maxlen=50)
        # MAX SPEED: Low starting threshold (30.0%) for maximum trade frequency
        self.dynamic_threshold = 30.0 
        self.risk_multiplier = 0.99   # Start MAX usage (99% - leaving 1% for fees)

    def update_balance(self, new_balance):
        if self.initial_balance == 0:
            self.initial_balance = new_balance
            self.current_balance = new_balance
            self.previous_balance = new_balance
            return

        self.previous_balance = self.current_balance
        self.current_balance = new_balance
        
        delta = self.current_balance - self.previous_balance
        
        if abs(delta) > 0.0001:
            self.trade_history.append(delta)
            self.adapt_strategy(delta)

    def adapt_strategy(self, delta):
        """
        Ultra-aggressive adaptation for maximum frequency trading.
        """
        if delta > 0:
            # Winning: Go faster (lower threshold for faster entries, down to 25.0)
            self.dynamic_threshold = max(25.0, self.dynamic_threshold - 0.5)
            self.risk_multiplier = 0.99 # Keep pinned at max
            logger.info(f"PROFIT (+{delta:.6f}) -> MAX VELOCITY (Threshold: {self.dynamic_threshold:.2f}%)")
            
        else:
            # Losing: Tighten threshold slightly (max 40.0 to maintain high activity but manage risk)
            self.dynamic_threshold = min(40.0, self.dynamic_threshold + 1.0)
            self.risk_multiplier = 0.99 # STAY AGGRESSIVE
            logger.info(f"LOSS ({delta:.6f}) -> RECOVERY MODE (Threshold: {self.dynamic_threshold:.2f}%)")

    def get_growth_pct(self):
        if self.initial_balance == 0: return 0.0
        return ((self.current_balance - self.initial_balance) / self.initial_balance) * 100

# ------------------------------------------------------------------------------
# AI & MARKET DATA ENGINE (FASTEST POSSIBLE INDICATORS)
# ------------------------------------------------------------------------------
class AIEngine:
    def __init__(self):
        self.exchange = ccxt.hitbtc({'enableRateLimit': True})
        self.history = pd.DataFrame()
        # MAX SPEED: Less complex model for ultra-fast training
        self.model = RandomForestRegressor(n_estimators=20, max_depth=8, random_state=42)
        self.scaler = StandardScaler()
        self.is_trained = False
        self.simulation_wins = 0
        self.simulation_total = 0
        self.last_prediction = 0.0
        self.confidence = 0.0

    def fetch_price(self):
        try:
            ticker = self.exchange.fetch_ticker(SYMBOL_CCXT)
            return {
                'bid': ticker['bid'],
                'ask': ticker['ask'],
                'last': ticker['last'],
                'timestamp': datetime.now()
            }
        except Exception as e:
            logger.error(f"CCXT Error: {e}")
            return None

    def update_data(self, price_data):
        new_row = pd.DataFrame([price_data])
        if self.history.empty:
            self.history = new_row
        else:
            self.history = pd.concat([self.history, new_row], ignore_index=True)
        
        if len(self.history) > MAX_HISTORY:
            self.history = self.history.iloc[-MAX_HISTORY:]

    def calculate_features(self, df):
        df = df.copy()
        df['returns'] = df['last'].pct_change()
        
        # FIX: Increased look-back window from 3 to 5 to generate more stable, non-zero signals.
        # This is necessary because 50ms gaps often result in zero-change data, causing the model to predict 0.
        
        # Ultra Fast RSI (Period 5) 
        delta = df['last'].diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=5).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=5).mean()
        rs = gain / loss
        df['rsi'] = 100 - (100 / (1 + rs))
        
        # Volatility (Period 5) - Measures short-term instability
        df['volatility'] = df['returns'].rolling(window=5).std()
        
        # Momentum (Period 3)
        df['momentum'] = df['last'] - df['last'].shift(3)

        # Spread
        df['spread'] = df['ask'] - df['bid']
        
        # Fast Moving Average (MA 5)
        df['ma_5'] = df['last'].rolling(window=5).mean()
        
        # Target: Immediate next tick
        df['target'] = df['last'].shift(-1) - df['last']
        
        return df

    def train_and_predict(self):
        # Increased requirement to 50 to ensure robust feature calculation after dropna, matching the 5-period window.
        if len(self.history) < 50: 
            return 0, 0 

        df_all = self.calculate_features(self.history)
        
        # Separate the current, untargeted row for prediction
        X_current = df_all.iloc[[-1]].drop(columns=['target']).dropna()
        
        # Create the training set (removes last row with NaN target, and early rows with NaN features)
        df_train = df_all.iloc[:-1].dropna()

        # Check for sufficient data after cleaning
        if df_train.empty or X_current.empty: 
            return 0, 0

        # Feature definition (Updated feature name from 'ma_3' to 'ma_5')
        feature_cols = ['rsi', 'volatility', 'spread', 'momentum', 'ma_5'] 
        
        # Check if the needed features exist in the current feature set
        X_current = X_current[feature_cols]

        X = df_train[feature_cols]
        y = df_train['target']

        # Simulation Tracking - Run *before* training the new model
        if self.is_trained:
            # Check the outcome of the last data point in the training set
            actual_move = df_all.iloc[-2]['target'] if not pd.isna(df_all.iloc[-2]['target']) else 0
            if (self.last_prediction > 0 and actual_move > 0) or (self.last_prediction < 0 and actual_move < 0):
                self.simulation_wins += 1
            self.simulation_total += 1

        try:
            self.model.fit(X, y)
            self.is_trained = True
        except Exception as e:
            logger.error(f"ML Training failed: {e}")
            return 0, 0

        # Predict using the clean, current feature vector
        prediction = self.model.predict(X_current)[0]
        
        # Calculate volatility based on the training data
        avg_vol = df_train['volatility'].mean()
        # Confidence based on strength of signal vs noise (capped at 100%)
        confidence = min(abs(prediction) / (avg_vol + 1e-9), 1.0) * 100
        
        self.last_prediction = prediction
        self.confidence = confidence
        
        return prediction, confidence

# ------------------------------------------------------------------------------
# MAIN BOT LOGIC
# ------------------------------------------------------------------------------
class TradingBot:
    def __init__(self):
        self.sys = SystemInterface()
        self.ai = AIEngine()
        self.wallet_learner = WalletLearner()
        self.running = True
        self.iteration = 0

    def generate_dashboard(self, wallet, position, price_info, prediction, confidence, action_msg):
        unrealized_pnl = 0.0
        pnl_class = "neutral"
        
        if position['has_position']:
            qty = position['qty']
            entry = position['entry_price']
            curr_price = price_info['bid'] if qty > 0 else price_info['ask']
            
            if qty > 0: unrealized_pnl = (curr_price - entry) * qty
            else: unrealized_pnl = (entry - curr_price) * abs(qty)
                
            if unrealized_pnl > 0: pnl_class = "success"
            elif unrealized_pnl < 0: pnl_class = "danger"

        sim_acc = 0
        if self.ai.simulation_total > 0:
            sim_acc = (self.ai.simulation_wins / self.ai.simulation_total) * 100
            
        growth_pct = self.wallet_learner.get_growth_pct()
        growth_class = "success-text" if growth_pct >= 0 else "danger-text"
        
        ai_signal = 'BUY' if prediction > 0 else 'SELL'
        signal_color = '#00ff00' if prediction > 0 else ('#ff0000' if prediction < 0 else '#ffffff')

        html = f"""
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta http-equiv="refresh" content="1">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>ULTRA-HIGH FREQUENCY SCALPER (Max Speed)</title>
            <style>
                @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@100;300;400;700;900&display=swap');
                
                :root {{
                    --bg-dark: #0D1117;
                    --card-bg: #161B22;
                    --text-light: #C9D1D9;
                    --accent-blue: #00A3FF;
                    --success-green: #2ECC71;
                    --danger-red: #E74C3C;
                    --neutral-gray: #7F8C8D;
                }}

                body {{ 
                    font-family: 'Roboto', sans-serif; 
                    background-color: var(--bg-dark); 
                    color: var(--text-light); 
                    margin: 0; 
                    padding: 20px;
                    transition: all 0.5s ease;
                }}
                
                .header {{
                    text-align: center;
                    margin-bottom: 30px;
                    font-size: 2.5rem;
                    font-weight: 900;
                    color: var(--success-green); /* Green for 'Profit/Speed' */
                }}

                .container {{ 
                    display: grid; 
                    grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); 
                    gap: 20px; 
                    max-width: 1200px;
                    margin: auto;
                }}
                
                .card {{ 
                    background-color: var(--card-bg); 
                    border-radius: 12px; 
                    padding: 25px; 
                    border: 1px solid #30363D;
                    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.4);
                    transition: transform 0.3s ease, box-shadow 0.3s ease;
                }}
                
                .card:hover {{
                    transform: translateY(-5px);
                    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.6);
                }}

                .card.success {{ border-left: 5px solid var(--success-green); }}
                .card.danger {{ border-left: 5px solid var(--danger-red); }}
                .card.info {{ border-left: 5px solid var(--accent-blue); }}
                
                h2 {{ 
                    margin-top: 0; 
                    font-size: 1.1rem; 
                    color: var(--neutral-gray);
                    text-transform: uppercase;
                    letter-spacing: 1px;
                    border-bottom: 1px solid #30363D;
                    padding-bottom: 10px;
                }}
                
                .value {{ 
                    font-size: 2.8rem; 
                    font-weight: 900; 
                    margin-top: 10px; 
                    margin-bottom: 5px;
                    line-height: 1;
                }}
                
                .sub {{ 
                    font-size: 0.85rem; 
                    color: #99A9B9; 
                    margin-top: 5px;
                }}
                
                .success-text {{ color: var(--success-green); font-weight: 700; }}
                .danger-text {{ color: var(--danger-red); font-weight: 700; }}
                
                .status-bar {{ 
                    background: #161B22; 
                    padding: 15px 25px; 
                    margin-bottom: 30px; 
                    border-radius: 8px; 
                    border: 1px solid var(--success-green); /* Green border for max speed */
                    font-weight: 700;
                    box-shadow: 0 2px 8px rgba(46, 204, 113, 0.3);
                }}
                
                .status-bar strong {{ color: var(--success-green); margin-right: 10px; }}

                /* Responsive Adjustments */
                @media (max-width: 600px) {{
                    body {{ padding: 10px; }}
                    .header {{ font-size: 2rem; margin-bottom: 20px; }}
                    .value {{ font-size: 2.2rem; }}
                }}
            </style>
        </head>
        <body>
            <div class="header">ULTRA-HIGH FREQUENCY SCALPER</div>
            
            <div class="status-bar">
                <strong>ACTION:</strong> {action_msg} | 
                <strong>RISK:</strong> {self.wallet_learner.risk_multiplier*100:.6f}%
            </div>
            
            <div class="container">
                
                <!-- WALLET CARD -->
                <div class="card success">
                    <h2>USDT BALANCE</h2>
                    <div class="value">${wallet:.6f}</div>
                    <div class="sub">Growth: <span class="{growth_class}">{growth_pct:.6f}%</span> YTD</div>
                    <div class="sub">Min Conf. Entry: {self.wallet_learner.dynamic_threshold:.6f}%</div>
                </div>
                
                <!-- PNL CARD -->
                <div class="card {pnl_class}">
                    <h2>UNREALIZED PNL ({SYMBOL_BASH})</h2>
                    <div class="value" style="color: {'var(--success-green)' if unrealized_pnl > 0 else 'var(--danger-red)' if unrealized_pnl < 0 else 'var(--neutral-gray)'}">{unrealized_pnl:.6f}</div>
                    <div class="sub">Entry: {position['entry_price']} | Qty: {position['qty']}</div>
                </div>
                
                <!-- AI CARD -->
                <div class="card info">
                    <h2>AI SIGNAL ({SYMBOL_CCXT})</h2>
                    <div class="value" style="color: {signal_color}">{ai_signal}</div>
                    <div class="sub">Confidence: {confidence:.6f}%</div>
                    <div class="sub">Sim. Accuracy: {sim_acc:.6f}%</div>
                </div>
                
            </div>
        </body>
        </html>
        """
        try:
            with open(DASHBOARD_PATH, 'w') as f:
                f.write(html)
        except Exception as e:
            logger.error(f"Failed to write dashboard: {e}")

    def run(self):
        logger.info("Starting ULTRA-HIGH FREQUENCY SCALPER Bot...")
        self.sys.close_all_positions()
        
        initial_wallet = self.sys.get_wallet_balance()
        self.wallet_learner.update_balance(initial_wallet)
        
        while self.running:
            try:
                action_log = "Scanning..."
                wallet = self.sys.get_wallet_balance()
                
                self.wallet_learner.update_balance(wallet)
                
                pos_data = self.sys.get_real_position(SYMBOL_BASH)
                price_data = self.ai.fetch_price()
                
                if not price_data:
                    # MAX SPEED: Continue faster if price data fetch fails
                    time.sleep(0.01) 
                    continue

                self.ai.update_data(price_data)
                
                # Check if we should retrain based on a very fast, continuous interval (1 == every loop)
                if self.iteration % TRAINING_INTERVAL == 0:
                    prediction, confidence = self.ai.train_and_predict()
                else:
                    prediction = self.ai.last_prediction
                    confidence = self.ai.confidence
                
                # ---------------------------------------------------------
                # TRADING LOGIC
                # ---------------------------------------------------------
                if pos_data['has_position']:
                    qty = pos_data['qty']
                    entry = pos_data['entry_price']
                    is_long = qty > 0
                    
                    # Real PnL calculation
                    if is_long:
                        # If closing long, we sell at the BID
                        current_pnl = (price_data['bid'] - entry) * abs(qty)
                        price_diff_pct = (price_data['bid'] - entry) / entry
                    else:
                        # If closing short, we buy at the ASK
                        current_pnl = (entry - price_data['ask']) * abs(qty)
                        price_diff_pct = (entry - price_data['ask']) / entry

                    total_fee = (entry * abs(qty) * FEE_RATE) + (price_data['last'] * abs(qty) * FEE_RATE)
                    net_pnl = current_pnl - total_fee
                    action_log = f"PnL: {net_pnl:.6f}"

                    # Calculate required gross profit for a scalp exit (0.01% target + transaction fees)
                    entry_value = entry * abs(qty)
                    required_gross_profit = entry_value * TARGET_PROFIT_PCT
                    
                    # Required PnL (Gross PnL - Target PnL)
                    required_pnl_usd = required_gross_profit + total_fee

                    # 1. MAX SPEED SCALP PROFIT TAKER (Full Close)
                    if current_pnl > required_pnl_usd:
                        logger.info(f"$$$ MAX SPEED SCALP PROFIT (Target {TARGET_PROFIT_PCT*100:.4f}% + Fees): {net_pnl:.6f}")
                        side = 'sell' if is_long else 'buy'
                        self.sys.place_order(BASE_COIN, abs(qty), side)
                        action_log = "MAX SCALP CLOSE (Full)"
                        
                    # 2. PARTIAL PROFIT SCALING (Decrease Trade) - If profitable, but AI predicts reversal
                    elif net_pnl > 0 and (
                        (is_long and prediction < 0) or (not is_long and prediction > 0)
                    ):
                        # AI predicts a move against us -> scale out 25% profit
                        reduce_qty = abs(qty) * 0.25
                        
                        # Robust step-based calculation using numpy for precision
                        raw_qty = reduce_qty
                        reduce_qty = np.floor(raw_qty / MIN_QTY) * MIN_QTY
                        reduce_qty = max(MIN_QTY, round(reduce_qty, DECIMAL_PRECISION))
                        
                        if abs(qty) > reduce_qty: # Ensure we don't try to reduce more than held
                            side = 'sell' if is_long else 'buy'
                            self.sys.place_order(BASE_COIN, reduce_qty, side)
                            action_log = f"SCALE OUT PROFIT (Qty: {reduce_qty})"
                            logger.info(action_log)

                    # 3. AGGRESSIVE PYRAMIDING (Increase Trade) - Add if green AND AI confirms more profit ahead
                    # MAX SPEED: Lowered confidence requirement to 55.0% for stacking trades
                    elif net_pnl > 0 and confidence > 55.0:
                        # Check if AI confirms the direction
                        if (is_long and prediction > 0) or (not is_long and prediction < 0):
                            usable_wallet = wallet * self.wallet_learner.risk_multiplier
                            
                            # Use Ask for Long (buy cost), Bid for Short (sell cost) to calculate current value
                            execution_price = price_data['ask'] if is_long else price_data['bid']
                            current_pos_val = abs(qty) * execution_price 
                            
                            free_margin = usable_wallet - current_pos_val
                            
                            if free_margin > (execution_price * MIN_QTY):
                                raw_qty = free_margin / execution_price
                                # Robust step-based calculation using numpy for precision
                                add_qty = np.floor(raw_qty / MIN_QTY) * MIN_QTY
                                add_qty = max(MIN_QTY, round(add_qty, DECIMAL_PRECISION)) 
                                side = 'buy' if is_long else 'sell'
                                self.sys.place_order(BASE_COIN, add_qty, side)
                                action_log = f"COMPOUNDING (Qty: {add_qty})"
                                logger.info(action_log)
                    
                    # 4. GRID RECOVERY (Increase Trade) - If losing and AI predicts recovery
                    elif price_diff_pct < -GRID_STEP_PCT:
                        # Check if AI confirms the recovery direction
                        if (is_long and prediction > 0) or (not is_long and prediction < 0):
                            usable_wallet = wallet * self.wallet_learner.risk_multiplier

                            # Use Ask for Long (buy cost), Bid for Short (sell cost) to calculate current value
                            execution_price = price_data['ask'] if is_long else price_data['bid']
                            current_pos_val = abs(qty) * execution_price 

                            free_margin = usable_wallet - current_pos_val

                            if free_margin > (execution_price * MIN_QTY): 
                                # Use 75% of remaining free margin to avg down for faster recovery
                                raw_qty = (free_margin * 0.75) / execution_price
                                # Robust step-based calculation using numpy for precision
                                recovery_qty = np.floor(raw_qty / MIN_QTY) * MIN_QTY
                                recovery_qty = max(MIN_QTY, round(recovery_qty, DECIMAL_PRECISION)) 
                                side = 'buy' if is_long else 'sell'
                                self.sys.place_order(BASE_COIN, recovery_qty, side)
                                action_log = f"AVG DOWN (Qty: {recovery_qty})"
                                logger.info(action_log)

                else:
                    # -----------------------------------------------------
                    # NEW ENTRY (MAX-FREQUENCY)
                    # -----------------------------------------------------
                    if self.ai.is_trained and confidence > self.wallet_learner.dynamic_threshold: 
                        
                        
                        if prediction > 0:
                            # Buy order for Long entry hits the ASK
                            execution_price = price_data['ask']
                            side = 'buy'
                        elif prediction < 0:
                            # Sell order for Short entry hits the BID
                            execution_price = price_data['bid']
                            side = 'sell'
                        else:
                            # No strong prediction
                            continue 
                            
                        # Uses INITIAL_ENTRY_SIZE_MULTIPLIER = 2.0 for larger, max-speed entry
                        max_usd_to_use = (wallet * self.wallet_learner.risk_multiplier) * INITIAL_ENTRY_SIZE_MULTIPLIER
                        
                        if max_usd_to_use > (execution_price * MIN_QTY):
                            # Calculate max quantity based on the execution price (Ask or Bid)
                            raw_qty = max_usd_to_use / execution_price
                            # Robust step-based calculation using numpy for precision
                            trade_qty = np.floor(raw_qty / MIN_QTY) * MIN_QTY
                            trade_qty = max(MIN_QTY, round(trade_qty, DECIMAL_PRECISION)) 
                            
                            self.sys.place_order(BASE_COIN, trade_qty, side)
                            action_log = f"NEW MAX ENTRY {side.upper()} (Qty: {trade_qty})"
                            
                self.generate_dashboard(wallet, pos_data, price_data, prediction, confidence, action_log)
                self.iteration += 1
                # MAX SPEED: Reduce sleep time to 50ms for hyper-responsiveness
                time.sleep(0.05) 

            except KeyboardInterrupt:
                self.running = False
            except Exception as e:
                logger.error(f"Loop Error: {e}")
                time.sleep(1)

if __name__ == "__main__":
    bot = TradingBot()
    bot.run()
