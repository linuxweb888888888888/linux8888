import ccxt
import time
import subprocess
import pandas as pd
import numpy as np
import os
import re
import logging
from datetime import datetime
from sklearn.ensemble import GradientBoostingClassifier
from sklearn.preprocessing import StandardScaler
from collections import deque
from statsmodels.api import OLS # Used for Hurst Exponent (R/S analysis)
import json # V5.1: Needed for passing price data to HTML

# ------------------------------------------------------------------------------
# CONFIGURATION
# ------------------------------------------------------------------------------
SYMBOL_CCXT = 'ATOM/USDT'      
SYMBOL_BASH = 'ATOMUSDT_PERP'  
BASE_COIN = 'ATOM'             
MIN_QTY = 0.001                
MIN_TRADE_QTY_FACTOR = 1       
DECIMAL_PRECISION = len(str(MIN_QTY).split('.')[-1]) 
DASHBOARD_PATH = '/var/www/html/dashboard.html'
MAX_HISTORY = 400              
TRAINING_INTERVAL = 1          
FEE_RATE = 0.0006              

# V5.1 Strategy Parameters (inherited from V5.0)
TARGET_PROFIT_PCT = 0.00015    
GRID_STEP_PCT = 0.001          
INITIAL_ENTRY_RISK_CAP = 0.005 
UHF_SLEEP_SECONDS = 0.05 

# V5.1 Risk Management Parameters (inherited from V5.0)
RECOVERY_CONFIDENCE_MIN = 60.0 
MIN_VOLATILITY_FACTOR = 0.0001 
ATR_MULTIPLIER = 2.0           
ATR_PERIOD = 10                

# Dashboard Configuration
SPREAD_TIGHT_THRESHOLD = 0.0005 

# ------------------------------------------------------------------------------
# LOGGING SETUP
# ------------------------------------------------------------------------------
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger()

# ------------------------------------------------------------------------------
# HELPER FUNCTIONS
# ------------------------------------------------------------------------------

def calculate_hurst_exponent(series, max_lag=20):
    """V4.0: Calculates the Hurst Exponent (H) using Rescaled Range (R/S) analysis."""
    # (Implementation remains the same as V4.0 for continuity)
    lags = range(2, max_lag)
    tau = [np.std(series.diff().dropna())]
    if tau[0] == 0: return 0.5 
    
    rs_data = []
    for lag in lags:
        chunks = [series.iloc[i:i + lag] for i in range(0, len(series) - lag + 1, lag)]
        if not chunks: continue
        
        rs_values = []
        for chunk in chunks:
            if len(chunk) < lag: continue
            mean = chunk.mean()
            y_t = (chunk - mean).cumsum()
            
            R = y_t.max() - y_t.min()
            S = chunk.std()
            if S > 0:
                rs_values.append(R / S)
        
        if rs_values:
            rs_data.append(np.mean(rs_values))

    if len(rs_data) < 5: return 0.5 
    
    log_lags = np.log(list(lags)[:len(rs_data)])
    log_rs = np.log(rs_data)

    if len(log_lags) > 1 and len(log_lags) == len(log_rs):
        model = OLS(log_rs, log_lags).fit()
        H = model.params[0]
        return max(0.0, min(1.0, H)) 
        
    return 0.5 

# ------------------------------------------------------------------------------
# SYSTEM INTERFACE (Bash Scripts)
# ------------------------------------------------------------------------------
class SystemInterface:
    @staticmethod
    def run_command(command_list):
        # (Implementation remains the same as V4.0)
        try:
            result = subprocess.run(command_list, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, timeout=3)
            return result.stdout.strip()
        except Exception as e:
            logger.error(f"Command failed: {command_list} | Error: {e}")
            return None

    @staticmethod
    def get_wallet_balance():
        output = SystemInterface.run_command(['bash', '/wallet.sh'])
        if output:
            try:
                lines = output.split('\n')
                balance = float(lines[0].strip())
                return balance
            except ValueError:
                logger.error("Could not parse wallet balance.")
        return 0.0

    @staticmethod
    def get_real_position(symbol_bash):
        output = SystemInterface.run_command(['bash', '/coinrealinfo.sh', symbol_bash])
        
        data = {
            'symbol': symbol_bash,
            'qty': 0.0,
            'entry_price': 0.0,
            'has_position': False
        }

        if not output or "NO INFO" in output or output == "":
            return data

        try:
            qty_match = re.search(r'Quantity:\s*([\d\.-]+)', output)
            entry_match = re.search(r'Entry Price:\s*([\d\.-]+)', output)

            if qty_match:
                data['qty'] = float(qty_match.group(1))
            if entry_match:
                data['entry_price'] = float(entry_match.group(1))
            
            if abs(data['qty']) > 0:
                data['has_position'] = True
                
        except Exception as e:
            logger.error(f"Error parsing coin info: {e}")

        return data

    @staticmethod
    def place_order(coin_base, qty, side):
        cmd = ['bash', '/placeorder.sh', coin_base, str(qty), side]
        output = SystemInterface.run_command(cmd)
        if output and "SUCCESS" in output:
            logger.info(f"Order SUCCESS: {side} {qty} {coin_base}")
            return True
        else:
            logger.error(f"Order ERROR: {output}")
            return False

    @staticmethod
    def close_all_positions():
        output = SystemInterface.run_command(['bash', '/closepositions.sh'])
        logger.info(f"Close Positions: {output}")
        return output

# ------------------------------------------------------------------------------
# WALLET LEARNER (ADAPTIVE RISK MODE)
# ------------------------------------------------------------------------------
class WalletLearner:
    # (Implementation remains the same as V4.0)
    def __init__(self):
        self.initial_balance = 0.0
        self.current_balance = 0.0
        self.trade_history = deque(maxlen=50)
        self.dynamic_threshold = 30.0 
        self.risk_multiplier = 0.99   

    def update_balance(self, new_balance):
        if self.initial_balance == 0:
            self.initial_balance = new_balance
            self.current_balance = new_balance
            return

        delta = new_balance - self.current_balance
        self.current_balance = new_balance
        
        if abs(delta) > 0.0001:
            self.trade_history.append(delta)
            self.adapt_strategy(delta)

    def adapt_strategy(self, delta):
        growth_pct = self.get_growth_pct()

        if delta > 0:
            self.dynamic_threshold = max(15.0, self.dynamic_threshold - 0.5)
        else:
            self.dynamic_threshold = min(40.0, self.dynamic_threshold + 1.0)
            
        if growth_pct < 0:
            self.risk_multiplier = 0.85 
            logger.warning(f"ACCOUNT DRAWDOWN detected. Risk Multiplier reduced to {self.risk_multiplier}.")
        else:
             self.risk_multiplier = 0.99 

    def get_growth_pct(self):
        if self.initial_balance == 0: return 0.0
        return ((self.current_balance - self.initial_balance) / self.initial_balance) * 100

# ------------------------------------------------------------------------------
# AI & MARKET DATA ENGINE (GRADIENT BOOSTING CLASSIFIER)
# ------------------------------------------------------------------------------
class AIEngine:
    def __init__(self):
        self.exchange = ccxt.hitbtc({'enableRateLimit': True})
        self.history = pd.DataFrame()
        self.model = GradientBoostingClassifier(n_estimators=30, max_depth=3, learning_rate=0.1, random_state=42)
        self.scaler = StandardScaler()
        self.is_trained = False
        self.simulation_wins = 0
        self.simulation_total = 0
        self.last_prediction_proba = 0.5
        self.confidence = 0.0
        self.avg_volatility = 0.0 
        self.hurst_exponent = 0.5 
        self.current_atr = 0.0 

    def fetch_price(self):
        """V5.0: Fetching Order Book with limit=5 for BAPI calculation."""
        try:
            # We fetch up to 5 levels to ensure L1, L2, L3 are available for BAPI
            ob = self.exchange.fetch_order_book(SYMBOL_CCXT, limit=5)
            ticker = self.exchange.fetch_ticker(SYMBOL_CCXT)
            
            return {
                'bid': ticker['bid'],
                'ask': ticker['ask'],
                'last': ticker['last'],
                'timestamp': datetime.now(),
                'bids': ob['bids'][:3], # Top 3 levels for BAPI
                'asks': ob['asks'][:3], # Top 3 levels for BAPI
            }
        except Exception as e:
            logger.error(f"CCXT Error: {e}")
            return None

    def update_data(self, price_data):
        new_row = pd.DataFrame([price_data])
        
        # Extract L1 volume for compatibility with old imbalance feature
        bid_vol = new_row['bids'].apply(lambda x: x[0][1] if x and len(x[0])>1 else 0).iloc[0]
        ask_vol = new_row['asks'].apply(lambda x: x[0][1] if x and len(x[0])>1 else 0).iloc[0]
        new_row['bid_vol'] = bid_vol
        new_row['ask_vol'] = ask_vol

        if self.history.empty:
            self.history = new_row
        else:
            self.history = pd.concat([self.history, new_row], ignore_index=True)
        
        if len(self.history) > MAX_HISTORY:
            self.history = self.history.iloc[-MAX_HISTORY:]

    def calculate_features(self, df):
        df = df.copy()
        df['mid_price'] = (df['bid'] + df['ask']) / 2
        
        # V4.0 Features (EWMA, Imbalance, RSI, Momentum)
        df['ewma_3'] = df['mid_price'].ewm(span=3, adjust=False).mean()
        df['ewma_5'] = df['mid_price'].ewm(span=5, adjust=False).mean()
        df['total_vol'] = df['bid_vol'] + df['ask_vol']
        df['imbalance'] = (df['bid_vol'] - df['ask_vol']) / df['total_vol'].replace(0, 1)

        delta = df['mid_price'].diff()
        gain = (delta.where(delta > 0, 0)).ewm(span=5, adjust=False).mean()
        loss = (-delta.where(delta < 0, 0)).ewm(span=5, adjust=False).mean()
        rs = gain / loss
        df['rsi'] = 100 - (100 / (1 + rs))
        df['volatility'] = df['mid_price'].pct_change().ewm(span=5, adjust=False).std()
        df['momentum'] = df['mid_price'] - df['mid_price'].shift(3)
        df['spread'] = df['ask'] - df['bid']
        df['spread_change'] = df['spread'].diff()
        
        # V4.0: Hurst Exponent
        if len(df) >= 20:
             self.hurst_exponent = calculate_hurst_exponent(df['mid_price'].iloc[-20:])
        df['hurst'] = self.hurst_exponent 
        
        # V5.0: Bid/Ask Pressure Index (BAPI)
        # Weights: L1=3, L2=2, L3=1
        def calculate_bapi(row):
            bids = row['bids']
            asks = row['asks']
            
            # Extract volumes for L1, L2, L3 (default to 0 if not present)
            b_v = [b[1] if b and len(b)==2 else 0 for b in bids]
            a_v = [a[1] if a and len(a)==2 else 0 for a in asks]

            bid_pressure = (b_v[0] * 3) + (b_v[1] * 2) + (b_v[2] * 1) if len(b_v) >= 3 else 0
            ask_pressure = (a_v[0] * 3) + (a_v[1] * 2) + (a_v[2] * 1) if len(a_v) >= 3 else 0
            
            total_pressure = bid_pressure + ask_pressure
            if total_pressure == 0: return 0.0
            
            return (bid_pressure - ask_pressure) / total_pressure

        # Apply BAPI calculation only to the most recent row efficiently
        last_bapi = calculate_bapi(df.iloc[-1]) if not df.empty else 0.0
        df['bapi'] = last_bapi # Broadcast for training
        
        # V5.0: Average True Range (ATR)
        # Using High and Low based on the Mid Price plus/minus half the spread
        df['true_range'] = df['spread']
        df['atr'] = df['true_range'].ewm(span=ATR_PERIOD, adjust=False).mean()
        self.current_atr = df['atr'].iloc[-1] if not df.empty and 'atr' in df.columns else 0.0
        
        # TARGET - Predict Direction (1: up, -1: down)
        target_returns = df['mid_price'].pct_change().shift(-1)
        df['signal'] = np.where(target_returns > 0.000005, 1, 
                       np.where(target_returns < -0.000005, -1, 0)) 
        
        return df

    def train_and_predict(self):
        if len(self.history) < 50: 
            return 0, 0 

        df_all = self.calculate_features(self.history).dropna()
        
        if df_all.empty: return 0, 0

        # V5.0: Added 'bapi' to features
        feature_cols = ['ewma_3', 'ewma_5', 'imbalance', 'rsi', 'volatility', 
                        'spread', 'momentum', 'spread_change', 'hurst', 'bapi'] 
        
        X_current = df_all.iloc[[-1]][feature_cols]
        df_train = df_all.iloc[:-1]

        if df_train.empty or X_current.empty: 
            return 0, 0

        X = df_train[feature_cols]
        y = df_train['signal']
        
        X_filtered = X[y != 0]
        y_filtered = y[y != 0]
        
        if len(y_filtered) < 10: return 0, 0 

        # Update simulation performance (maintained from V4.0)
        if self.is_trained:
            X_prev = df_all.iloc[[-2]][feature_cols]
            actual_signal = df_all.iloc[-2]['signal']
            
            proba = self.model.predict_proba(X_prev)[0] 
            predicted_signal = 1 if proba[1] > 0.5 else (-1 if proba[0] > 0.5 else 0)

            if predicted_signal == actual_signal and actual_signal != 0:
                self.simulation_wins += 1
            if actual_signal != 0:
                 self.simulation_total += 1

        try:
            self.model.fit(X_filtered, y_filtered)
            self.is_trained = True
        except Exception as e:
            logger.error(f"ML Training failed: {e}")
            return 0, 0

        proba = self.model.predict_proba(X_current)[0]
        
        if proba[1] > proba[0]:
            prediction = 1
            self.last_prediction_proba = proba[1]
        elif proba[0] > proba[1]:
            prediction = -1
            self.last_prediction_proba = proba[0]
        else:
            prediction = 0
            self.last_prediction_proba = 0.5

        confidence = (self.last_prediction_proba - 0.5) * 200 
        
        self.confidence = confidence
        self.avg_volatility = df_all['volatility'].mean() 
        
        return prediction, confidence

# ------------------------------------------------------------------------------
# MAIN BOT LOGIC
# ------------------------------------------------------------------------------
class TradingBot:
    def __init__(self):
        self.sys = SystemInterface()
        self.ai = AIEngine()
        self.wallet_learner = WalletLearner()
        self.running = True
        self.iteration = 0
        self.action_history = deque(maxlen=5) 

    def calculate_pnl(self, qty, entry, price_info):
        # PnL calculation remains the same
        is_long = qty > 0
        curr_price = price_info['bid'] if is_long else price_info['ask']
        
        if is_long: 
            current_pnl = (curr_price - entry) * abs(qty)
        else: 
            current_pnl = (entry - curr_price) * abs(qty)
            
        entry_value = entry * abs(qty)
        total_fee = (entry * abs(qty) * FEE_RATE) + (price_info['last'] * abs(qty) * FEE_RATE)
        net_pnl = current_pnl - total_fee
        
        required_gross_profit = entry_value * TARGET_PROFIT_PCT
        required_pnl_usd = required_gross_profit + total_fee

        pnl_pct_of_value = (current_pnl / entry_value) if entry_value > 0 else 0.0

        return net_pnl, required_pnl_usd, pnl_pct_of_value

    def calculate_position_size(self, wallet, execution_price):
        """V4.0: Calculates position size based on Volatility-Adjusted Sizing (VAS)."""
        # (Implementation remains the same as V4.0)
        current_volatility = self.ai.history['volatility'].iloc[-1] if not self.ai.history.empty and 'volatility' in self.ai.history.columns else MIN_VOLATILITY_FACTOR
        current_volatility = max(current_volatility, MIN_VOLATILITY_FACTOR)

        base_size_usd = wallet * INITIAL_ENTRY_RISK_CAP
        
        vol_factor = 1 / (current_volatility * 1000) 
        
        usable_wallet_usd = wallet * self.wallet_learner.risk_multiplier
        max_qty_based_on_wallet = usable_wallet_usd / execution_price
        
        final_qty = min((base_size_usd * vol_factor) / execution_price, max_qty_based_on_wallet)
        
        trade_qty = np.floor(final_qty / MIN_QTY) * MIN_QTY
        trade_qty = max(MIN_QTY, round(trade_qty, DECIMAL_PRECISION)) 
        
        return trade_qty, current_volatility

    def check_liquidity_sweep(self, prediction):
        """V4.0: Checks for a recent liquidity sweep (short-term reversal signal)."""
        # (Implementation remains the same as V4.0)
        if len(self.ai.history) < 5:
            return False
            
        prices = self.ai.history['mid_price'].iloc[-5:].values
        
        if prediction == 1: # Predicted LONG: Check for recent low sweep
            if prices[-1] <= prices.min() * 1.00005: 
                return True
        
        elif prediction == -1: # Predicted SHORT: Check for recent high sweep
            if prices[-1] >= prices.max() * 0.99995: 
                return True
                
        return False


    def generate_dashboard(self, wallet, position, price_info, prediction, confidence, action_msg, action_type, avg_volatility, dynamic_threshold, required_pnl_usd, action_history, pnl_pct_of_value, current_volatility, hurst_exponent, current_atr):
        # Dashboard logic updated for V5.1

        unrealized_pnl = 0.0
        target_price = 0.0
        stop_loss_price = 0.0
        
        pos_dir = "FLAT"
        pos_qty_display = "0.000"
        
        bapi = self.ai.history['bapi'].iloc[-1] if not self.ai.history.empty and 'bapi' in self.ai.history.columns else 0.0
        
        if position['has_position']:
            net_pnl, _, _ = self.calculate_pnl(position['qty'], position['entry_price'], price_info)
            unrealized_pnl = net_pnl
            
            qty = position['qty']
            entry = position['entry_price']
            is_long = qty > 0
            
            pos_dir = "LONG" if is_long else "SHORT"
            pos_qty_display = f"{abs(qty):.{DECIMAL_PRECISION}f}"
            
            if abs(qty) > 0:
                if is_long:
                    target_price = entry + (required_pnl_usd / abs(qty))
                    # V5.0 Dynamic Stop Loss: Entry - (ATR * Multiplier)
                    stop_loss_price = entry - (current_atr * ATR_MULTIPLIER) 
                else:
                    target_price = entry - (required_pnl_usd / abs(qty))
                    # V5.0 Dynamic Stop Loss: Entry + (ATR * Multiplier)
                    stop_loss_price = entry + (current_atr * ATR_MULTIPLIER)
        
        pnl_class = "neutral-text"
        if unrealized_pnl > 0: pnl_class = "success-text"
        elif unrealized_pnl < 0: pnl_class = "danger-text"

        sim_acc = 0
        if self.ai.simulation_total > 0:
            sim_acc = (self.ai.simulation_wins / self.ai.simulation_total) * 100
            
        growth_pct = self.wallet_learner.get_growth_pct()
        growth_class = "success-text" if growth_pct >= 0 else "danger-text"
        
        ai_signal = 'LONG' if prediction == 1 else ('SHORT' if prediction == -1 else 'NEUTRAL')
        signal_color = 'var(--long-color)' if prediction == 1 else ('var(--short-color)' if prediction == -1 else 'var(--neutral-gray)')
        prediction_val_str = f"{self.ai.last_prediction_proba:.4f}"
        
        spread = price_info['ask'] - price_info['bid']
        spread_status = "Tight" if spread <= SPREAD_TIGHT_THRESHOLD else "Wide"
        spread_class = "success-text" if spread_status == "Tight" else "danger-text"

        # V5.1: Mid-Price History for Sparkline
        price_history_arr = []
        if not self.ai.history.empty and 'mid_price' in self.ai.history.columns:
            # Get the last 30 mid-prices
            prices = self.ai.history['mid_price'].iloc[-30:].tolist()
            price_history_arr = [float(f'{p:.6f}') for p in prices]
        
        price_history_json = json.dumps(price_history_arr)
        
        # Confidence logic for Radial Chart
        confidence_level = confidence
        radial_dashoffset = 471 - (471 * (confidence_level / 100)) if confidence_level > 0 else 471
        
        bapi_class = 'long-color-text' if bapi > 0.1 else ('short-color-text' if bapi < -0.1 else 'neutral-text')
        bapi_text = 'BUY Pressure' if bapi > 0.1 else ('SELL Pressure' if bapi < -0.1 else 'Balanced')
        
        hurst_class = 'long-color-text' if hurst_exponent > 0.55 else ('short-color-text' if hurst_exponent < 0.45 else 'neutral-text')
        hurst_text = 'Trending' if hurst_exponent > 0.55 else ('Mean-Reverting' if hurst_exponent < 0.45 else 'Random Walk')

        history_html = ""
        for item in action_history:
            msg = item['message']
            cls = item['class']
            history_html += f"""
            <div class='log-entry {cls}'>
                <span class='log-time'>{item['time']}</span> 
                <span class='log-message'>{msg}</span>
            </div>
            """
        if not history_html:
            history_html = "<div class='log-entry neutral-pos'>Awaiting first action...</div>"

        html = f"""
        <!DOCTYPE html>
        <html lang="en">
        <head>
            <meta charset="UTF-8">
            <meta http-equiv="refresh" content="0.5"> 
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <title>UHF SCALPER COMMAND CENTER V5.1</title>
            <style>
                @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Roboto+Mono:wght@300;400;700&display=swap');
                
                :root {{
                    --bg-dark: #0A0A1A;
                    --card-bg: #14142B;
                    --success-green: #00FF99;
                    --danger-red: #FF3366; 
                    --accent-blue: #00BFFF; 
                    --neutral-gray: #4A6D7C;
                    --text-light: #E0FFEF;
                    --long-color: #00BFFF;
                    --short-color: #FF3366;
                    --critical-yellow: #FFFF66;
                }}

                body {{ 
                    font-family: 'Roboto Mono', monospace; 
                    background-color: var(--bg-dark); 
                    color: var(--text-light); 
                    margin: 0; 
                    padding: 15px;
                    overflow-x: hidden;
                }}
                
                .header {{
                    font-family: 'Orbitron', sans-serif;
                    text-align: center;
                    margin-bottom: 20px;
                    font-size: 1.8rem;
                    font-weight: 900;
                    color: var(--critical-yellow);
                    text-shadow: 0 0 10px rgba(255, 255, 102, 0.5);
                    padding-bottom: 10px;
                    border-bottom: 2px solid var(--accent-blue);
                    animation: pulse-title 5s infinite;
                }}
                @keyframes pulse-title {{
                    0% {{ color: var(--critical-yellow); }}
                    50% {{ color: var(--text-light); }}
                    100% {{ color: var(--critical-yellow); }}
                }}
                
                .container {{ 
                    max-width: 1300px;
                    margin: auto;
                }}
                
                .grid-main {{
                    display: grid; 
                    grid-template-columns: 2fr 1fr;
                    gap: 20px; 
                }}
                
                .grid-market-vitals {{
                    display: grid; 
                    grid-template-columns: repeat(3, 1fr); 
                    gap: 15px; 
                    margin-top: 15px;
                }}

                .card {{ 
                    background-color: var(--card-bg); 
                    border-radius: 8px; 
                    padding: 20px; 
                    border: 1px solid rgba(0, 191, 255, 0.15);
                    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
                    overflow: hidden;
                    transition: all 0.3s;
                }}
                .card:hover {{ transform: translateY(-3px); box-shadow: 0 6px 20px rgba(0, 191, 255, 0.2); }}

                h2 {{ 
                    font-family: 'Orbitron', sans-serif;
                    margin-top: 0; 
                    font-size: 0.8rem; 
                    color: var(--accent-blue);
                    text-transform: uppercase;
                    letter-spacing: 2px;
                    border-bottom: 1px dashed var(--neutral-gray);
                    padding-bottom: 5px;
                    margin-bottom: 15px;
                }}
                
                .value {{ 
                    font-size: 1.8rem; 
                    font-weight: 700; 
                    margin-top: 5px; 
                    line-height: 1.1;
                }}
                .value.pnl {{ font-size: 3.5rem; }}
                
                .sub {{ 
                    font-size: 0.75rem; 
                    color: var(--neutral-gray); 
                    margin-top: 5px;
                    line-height: 1.3;
                }}
                
                .success-text {{ color: var(--success-green); }}
                .danger-text {{ color: var(--danger-red); }}
                .neutral-text {{ color: var(--neutral-gray); }}
                .long-color-text {{ color: var(--long-color); }}
                .short-color-text {{ color: var(--short-color); }}

                /* PNL Block */
                .pnl-block {{
                    text-align: center;
                    display: flex;
                    flex-direction: column;
                    justify-content: center;
                    height: 100%;
                }}
                
                /* Status Bar (V5.1: Smaller, more condensed) */
                .status-bar {{
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    margin-bottom: 20px;
                    padding: 8px 15px;
                    border-radius: 6px;
                    font-family: 'Orbitron', sans-serif;
                    font-size: 0.9rem;
                    font-weight: 700;
                    border: 2px solid;
                }}
                .long-pos {{ background-color: rgba(0, 191, 255, 0.1); border-color: var(--long-color); color: var(--long-color); }}
                .short-pos {{ background-color: rgba(255, 51, 102, 0.1); border-color: var(--short-color); color: var(--short-color); }}
                .neutral-pos {{ background-color: rgba(74, 109, 124, 0.1); border-color: var(--neutral-gray); color: var(--neutral-gray); }}


                /* --- V5.1 RADIAL GAUGE --- */
                .radial-container {{
                    display: flex;
                    align-items: center;
                    justify-content: space-around;
                    padding: 10px;
                }}
                .radial-chart {{
                    width: 120px;
                    height: 120px;
                    position: relative;
                }}
                .radial-chart svg {{
                    transform: rotate(-90deg);
                    overflow: visible;
                }}
                .radial-chart circle {{
                    fill: none;
                    stroke-width: 8;
                    stroke-linecap: round;
                }}
                .radial-bg {{
                    stroke: var(--neutral-gray);
                    opacity: 0.3;
                }}
                .radial-fill {{
                    stroke: var(--critical-yellow);
                    transition: stroke-dashoffset 0.5s ease-out;
                }}
                .radial-text {{
                    position: absolute;
                    top: 50%;
                    left: 50%;
                    transform: translate(-50%, -50%);
                    font-size: 1.2rem;
                    font-weight: 700;
                    color: var(--text-light);
                    font-family: 'Orbitron', sans-serif;
                }}

                /* --- V5.1 SPARKLINE CHART (Momentum) --- */
                .sparkline-chart {{
                    width: 100%;
                    height: 80px;
                    position: relative;
                    margin-top: 10px;
                }}
                .sparkline-svg {{
                    width: 100%;
                    height: 100%;
                }}
                .sparkline-line {{
                    fill: none;
                    stroke: var(--accent-blue);
                    stroke-width: 2;
                    transition: stroke 0.3s;
                }}
                .chart-title {{
                    font-size: 0.7rem;
                    color: var(--neutral-gray);
                    margin-top: 5px;
                }}
                
                /* Action History Log */
                .log-entry {{
                    font-size: 0.75rem;
                    padding: 4px 0;
                    border-bottom: 1px dotted rgba(74, 109, 124, 0.3);
                    display: flex;
                    font-family: 'Roboto Mono', monospace;
                }}
                .log-entry:last-child {{ border-bottom: none; }}
                .log-time {{ color: var(--neutral-gray); min-width: 60px; margin-right: 10px; }}
                .log-message {{ font-weight: 400; }}

                .log-entry.entry .log-message {{ color: var(--long-color); }}
                .log-entry.profit .log-message {{ color: var(--success-green); }}
                .log-entry.recovery .log-message {{ color: var(--danger-red); }}
                .log-entry.compound .log-message {{ color: var(--success-green); }}
                .log-entry.close .log-message {{ color: var(--text-light); }}
                .log-entry.stop_loss .log-message {{ color: var(--critical-yellow); font-weight: 700; }}

                /* Responsive Adjustments */
                @media (max-width: 900px) {{
                    .grid-main {{ grid-template-columns: 1fr; }}
                    .grid-market-vitals {{ grid-template-columns: 1fr 1fr; }}
                    .value.pnl {{ font-size: 2.5rem; }}
                }}
                @media (max-width: 500px) {{
                     .grid-market-vitals {{ grid-template-columns: 1fr; }}
                }}
            </style>
        </head>
        <body>
            <div class="header">UHF SCALPER V5.1: REAL-TIME VISUALIZATION / {SYMBOL_CCXT}</div>
            
            <div class="container">
                <div class="status-bar {pos_class}">
                    <span>POSITION STATUS: {pos_dir}</span>
                    <span>QTY: {pos_qty_display} {BASE_COIN}</span>
                    <span>ENTRY: {position['entry_price']:.6f}</span>
                </div>

                <div class="grid-main">
                    <!-- LEFT COLUMN: PNL, PRICE & CHART -->
                    <div>
                        <!-- PRICE & SPARKLINE -->
                        <div class="card" style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <h2>CURRENT MARKET PRICE (LAST)</h2>
                                <div class="value neutral-text">{price_info['last']:.6f}</div>
                                <div class="sub">AI Signal: <span class="long-color-text" style="color: {signal_color}">{ai_signal} (P: {prediction_val_str})</span></div>
                            </div>
                            <!-- V5.1 Sparkline -->
                            <div class="sparkline-chart">
                                <svg class="sparkline-svg" viewBox="0 0 300 100" preserveAspectRatio="none">
                                    <polyline id="sparkline-line" class="sparkline-line" points="" />
                                </svg>
                                <div class="chart-title" style="text-align: right;">30-Tick Momentum</div>
                            </div>
                        </div>

                        <!-- PNL BLOCK (Dominant) -->
                        <div class="card pnl-block" style="margin-top: 20px; border-left: 4px solid {'var(--success-green)' if unrealized_pnl > 0 else 'var(--danger-red)' if unrealized_pnl < 0 else 'var(--neutral-gray)'};">
                            <h2>NET UNREALIZED PNL (USDT)</h2>
                            <div class="value pnl {pnl_class}">{unrealized_pnl:.6f}</div>
                            <div class="sub" style="margin-top: 15px;">Target Exit: <span class="success-text">{target_price:.6f}</span></div>
                            <div class="sub">Dynamic Stop Loss: <span class="danger-text">{stop_loss_price:.6f}</span> (2.0x ATR)</div>
                        </div>
                    </div>
                    
                    <!-- RIGHT COLUMN: AI CONFIDENCE & LOG -->
                    <div>
                        <!-- AI CONFIDENCE CARD -->
                        <div class="card">
                            <h2>AI CONFIDENCE (GBC MODEL)</h2>
                            <div class="radial-container">
                                <!-- V5.1 Radial Chart -->
                                <div class="radial-chart">
                                    <svg width="150" height="150" viewBox="0 0 160 160">
                                        <circle class="radial-bg" r="75" cx="80" cy="80"></circle>
                                        <circle class="radial-fill" r="75" cx="80" cy="80" 
                                            stroke-dasharray="471" stroke-dashoffset="{radial_dashoffset}" 
                                            style="stroke: var(--critical-yellow);"></circle>
                                    </svg>
                                    <div class="radial-text">{confidence:.1f}%</div>
                                </div>
                                
                                <div style="text-align: left; font-size: 0.9rem;">
                                    <div class="sub">Entry Threshold: <span class="long-color-text">{dynamic_threshold:.1f}%</span></div>
                                    <div class="sub">Entry Probability: <span class="long-color-text">{self.ai.last_prediction_proba:.2f}</span></div>
                                    <div class="sub">Sim. Accuracy: <span class="success-text">{sim_acc:.1f}%</span></div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- ACTION HISTORY LOG -->
                        <div class="card" style="margin-top: 20px;">
                            <h2>RECENT ACTION LOG</h2>
                            <div style="max-height: 200px; overflow-y: auto;">
                                {history_html}
                            </div>
                        </div>
                    </div>
                </div>

                <!-- BOTTOM ROW: MARKET VITALS -->
                <div class="grid-market-vitals">
                    
                    <div class="card">
                        <h2>ORDER FLOW (BAPI V5.0)</h2>
                        <div class="value {bapi_class}">{bapi:.4f}</div>
                        <div class="sub">L1-L3 Pressure: {bapi_text}</div>
                    </div>

                    <div class="card">
                        <h2>MARKET VOLATILITY (ATR)</h2>
                        <div class="value neutral-text">{current_atr:.6f}</div>
                        <div class="sub">Volatility Factor: {current_volatility:.6f}</div>
                    </div>
                    
                    <div class="card">
                        <h2>MARKET REGIME (HURST)</h2>
                        <div class="value {hurst_class}">{hurst_exponent:.4f}</div>
                        <div class="sub">Regime: {hurst_text}</div>
                    </div>

                    <div class="card">
                        <h2>BID/ASK SPREAD</h2>
                        <div class="value {spread_class}">{spread:.6f}</div>
                        <div class="sub">Status: {spread_status} (<{SPREAD_TIGHT_THRESHOLD})</div>
                    </div>
                    
                    <div class="card">
                        <h2>ACCOUNT HEALTH</h2>
                        <div class="value success-text">${wallet:.6f}</div>
                        <div class="sub">Growth YTD: <span class="{growth_class}">{growth_pct:.6f}%</span></div>
                    </div>
                    
                    <div class="card">
                        <h2>PNL % OF VALUE</h2>
                        <div class="value {pnl_class}">{(pnl_pct_of_value*100):.3f}%</div>
                        <div class="sub">Required Profit Pct: {TARGET_PROFIT_PCT*100:.3f}%</div>
                    </div>
                </div>
            </div>
            
            <script>
                const priceHistory = {price_history_json};
                const svg = document.getElementById('sparkline-line');
                const svgContainer = document.querySelector('.sparkline-svg');
                
                function updateSparkline() {{
                    if (priceHistory.length < 2) return;

                    const width = 300;
                    const height = 100;
                    
                    // Determine min/max for scaling
                    const minPrice = Math.min(...priceHistory);
                    const maxPrice = Math.max(...priceHistory);
                    const range = maxPrice - minPrice;
                    const normalizedRange = range === 0 ? 1 : range; // Avoid division by zero
                    
                    const len = priceHistory.length;
                    
                    // Generate points
                    let points = priceHistory.map((price, index) => {{
                        const x = (index / (len - 1)) * width;
                        // Normalize price to 0-100 (inverted Y-axis for chart display)
                        const y = height - ((price - minPrice) / normalizedRange) * height;
                        return `${{x}},${{y}}`;
                    }}).join(' ');
                    
                    svg.setAttribute('points', points);
                    
                    // Color the line based on the last tick change
                    const lastPrice = priceHistory[len - 1];
                    const prevPrice = priceHistory[len - 2];
                    
                    if (lastPrice > prevPrice) {{
                        svg.style.stroke = 'var(--success-green)';
                    }} else if (lastPrice < prevPrice) {{
                        svg.style.stroke = 'var(--danger-red)';
                    }} else {{
                         svg.style.stroke = 'var(--neutral-gray)';
                    }}
                }}

                window.onload = updateSparkline;
            </script>
        </body>
        </html>
        """
        try:
            with open(DASHBOARD_PATH, 'w') as f:
                f.write(html)
        except Exception as e:
            logger.error(f"Failed to write dashboard: {e}")

    def run(self):
        logger.info("Starting UHF SCALPER V5.1: Order Flow Synthesis & Microsecond Optimization Bot...")
        self.sys.close_all_positions()
        
        initial_wallet = self.sys.get_wallet_balance()
        self.wallet_learner.update_balance(initial_wallet)
        current_volatility = MIN_VOLATILITY_FACTOR
        current_atr = 0.0
        
        while self.running:
            try:
                action_log = "Scanning market for entry signal"
                action_type = "SCANNING"
                pnl_pct_of_value = 0.0
                
                # --- LOW LATENCY DATA FETCH ---
                wallet = self.sys.get_wallet_balance()
                self.wallet_learner.update_balance(wallet)
                dynamic_threshold = self.wallet_learner.dynamic_threshold
                
                pos_data = self.sys.get_real_position(SYMBOL_BASH)
                price_data = self.ai.fetch_price()
                
                if not price_data:
                    time.sleep(0.01) 
                    continue

                self.ai.update_data(price_data)
                
                # --- AI DECISION BLOCK ---
                if self.iteration % TRAINING_INTERVAL == 0:
                    prediction, confidence = self.ai.train_and_predict()
                else:
                    prediction = 1 if self.ai.last_prediction_proba > 0.5 else (-1 if self.ai.last_prediction_proba < 0.5 else 0)
                    confidence = self.ai.confidence
                
                avg_volatility = self.ai.avg_volatility 
                hurst_exponent = self.ai.hurst_exponent
                current_atr = self.ai.current_atr # V5.0 ATR
                required_pnl_usd = 0.0
                
                # Pre-calculate size based on current market volatility (V4.0)
                dummy_qty, current_volatility = self.calculate_position_size(wallet, price_data['last']) 
                
                # ---------------------------------------------------------
                # TRADING LOGIC
                # ---------------------------------------------------------
                if pos_data['has_position']:
                    qty = pos_data['qty']
                    entry = pos_data['entry_price']
                    is_long = qty > 0
                    
                    net_pnl, required_pnl_usd, pnl_pct_of_value = self.calculate_pnl(qty, entry, price_data)
                    
                    action_log = f"PnL: {net_pnl:.6f} (Required: {required_pnl_usd:.6f})"
                    action_type = "PROFIT" if net_pnl >= 0 else "RECOVERY"

                    # 1. V5.0 DYNAMIC TRAILING STOP LOSS (Volatility-Adjusted Exit)
                    stop_loss_trigger = current_atr * ATR_MULTIPLIER
                    
                    # Calculate current loss based on ATR distance
                    if is_long:
                        loss_usd = entry - price_data['bid'] 
                    else:
                        loss_usd = price_data['ask'] - entry

                    loss_pct_of_entry = loss_usd / entry 

                    if loss_pct_of_entry > stop_loss_trigger / entry:
                        logger.critical(f"!!! DYNAMIC STOP LOSS TRIGGERED: ATR Loss {loss_usd:.6f}")
                        side = 'sell' if is_long else 'buy'
                        self.sys.place_order(BASE_COIN, abs(qty), side)
                        action_log = f"STOP LOSS: {loss_pct_of_entry*100:.2f}% (ATR Exit)"
                        action_type = "STOP_LOSS"
                        continue 

                    # 2. MAX SPEED SCALP PROFIT TAKER (Full Close)
                    if net_pnl > 0: 
                        logger.info(f"$$$ MAX SPEED SCALP PROFIT: {net_pnl:.6f}")
                        side = 'sell' if is_long else 'buy'
                        self.sys.place_order(BASE_COIN, abs(qty), side)
                        action_log = f"Closed: +{net_pnl:.6f} Profit"
                        action_type = "CLOSE"
                        
                    # 3. AGGRESSIVE PYRAMIDING (Adding to a winning trade)
                    elif net_pnl > 0 and confidence > 55.0 and (
                        (is_long and prediction == 1) or (not is_long and prediction == -1)
                    ):
                        add_qty, _ = self.calculate_position_size(wallet, price_data['last'])
                        
                        side = 'buy' if is_long else 'sell'
                        if (add_qty * price_data['last'] + abs(qty) * entry) < (wallet * self.wallet_learner.risk_multiplier):
                            self.sys.place_order(BASE_COIN, add_qty, side)
                            action_log = f"Compound: +{add_qty} QTY (VAS)"
                            action_type = "COMPOUND"
                    
                    # 4. SMARTER GRID RECOVERY (Averaging down into a loss)
                    elif pnl_pct_of_value < -GRID_STEP_PCT and confidence > RECOVERY_CONFIDENCE_MIN:
                        if (is_long and prediction == 1) or (not is_long and prediction == -1):
                            recovery_qty, _ = self.calculate_position_size(wallet, price_data['last'])
                            recovery_qty *= 1.5 

                            side = 'buy' if is_long else 'sell'
                            if (recovery_qty * price_data['last'] + abs(qty) * entry) < (wallet * self.wallet_learner.risk_multiplier):
                                self.sys.place_order(BASE_COIN, recovery_qty, side)
                                action_log = f"Grid Down: +{recovery_qty} QTY (VAS)"
                                action_type = "RECOVERY"

                else:
                    # -----------------------------------------------------
                    # NEW MIN-QUANTITY ENTRY (V5.0: ATR+LS+BAPI)
                    # -----------------------------------------------------
                    if self.ai.is_trained and confidence > dynamic_threshold: 
                        
                        if prediction == 1:
                            execution_price = price_data['ask']
                            side = 'buy'
                            # V5.0: Check if BAPI confirms long pressure
                            if self.ai.history['bapi'].iloc[-1] < 0.1: continue
                            
                        elif prediction == -1:
                            execution_price = price_data['bid']
                            side = 'sell'
                            # V5.0: Check if BAPI confirms short pressure
                            if self.ai.history['bapi'].iloc[-1] > -0.1: continue
                        else:
                            continue # Neutral signal
                            
                        # V4.0: Run the Liquidity Sweep Filter
                        if not self.check_liquidity_sweep(prediction):
                            action_log = f"Signal held back (No Liquidity Sweep): {ai_signal}"
                            action_type = "SCANNING"
                            continue
                            
                        # V4.0: Calculate Volatility-Adjusted Size
                        trade_qty, _ = self.calculate_position_size(wallet, execution_price)

                        if (trade_qty * execution_price) < (wallet * self.wallet_learner.risk_multiplier):
                            self.sys.place_order(BASE_COIN, trade_qty, side)
                            action_log = f"Entry (V5.0/BAPI): {side.upper()} {trade_qty} (C:{confidence:.1f}%)"
                            action_type = "ENTRY"
                            
                # --- UPDATE ACTION HISTORY ---
                if action_type not in ["SCANNING", "NONE"]: 
                    self.action_history.appendleft({
                        'time': datetime.now().strftime('%H:%M:%S.%f')[:-3],
                        'message': action_log,
                        'class': action_type.lower()
                    })
                
                # --- DASHBOARD GENERATION (Low Priority) ---
                self.generate_dashboard(wallet, pos_data, price_data, prediction, confidence, action_log, action_type, avg_volatility, dynamic_threshold, required_pnl_usd, list(self.action_history), pnl_pct_of_value, current_volatility, hurst_exponent, current_atr)
                
                self.iteration += 1
                time.sleep(UHF_SLEEP_SECONDS) 

            except KeyboardInterrupt:
                self.running = False
            except Exception as e:
                logger.error(f"Loop Error: {e}")
                time.sleep(1)

if __name__ == "__main__":
    bot = TradingBot()
    bot.run()
