import time
import subprocess
import json
import re
import pandas as pd
import numpy as np
import os
import ccxt # Added ccxt for price fetching
from datetime import datetime, timedelta
from sklearn.ensemble import HistGradientBoostingClassifier
from sklearn.preprocessing import StandardScaler
from collections import deque
from typing import Dict, Any, Tuple, Optional

# --- CONFIGURATION & CONSTANTS ---
SYMBOL = "ATOMUSDT_PERP"
BASE_COIN = "ATOM"
QUOTE_COIN = "USDT" # Assuming USDT is the quote currency
MIN_QTY = 0.001
LEVERAGE = 100
INTERVAL_SECONDS = 30 # Signal check every 30 seconds
LOOKBACK_PERIOD = 300 # Number of bars to look back for historical data (e.g., 5-minute bars)
WINDOW_SIZE = 14 # Standard size for indicators (RSI, ADX, ROC)
VOLATILITY_WINDOW = 20 # Window for Volatility check (e.g., ATR)

# ML/Adaptive Parameters
MIN_TRAINING_SAMPLES = 50
BASE_PROBABILITY_THRESHOLD = 0.55 # Minimum confidence for a trade
BASE_RISK_PERCENT = 0.005 # Base percentage of wallet balance risked per trade (0.5%)

# Dynamic SL/TP Multipliers based on ATR
ATR_MULTIPLIER_TP = 2.5 # Take Profit is 2.5 * ATR
ATR_MULTIPLIER_SL = 1.2 # Stop Loss is 1.2 * ATR

# NEW: Time-Based Stop Loss (T-SL) - Max hold time in minutes
MAX_HOLDING_PERIOD_MINUTES = 60

# Paths
DASHBOARD_PATH = "/var/www/html/dashboard.html"

# Exchange Setup (using HitBTC)
try:
    exchange = ccxt.hitbtc({'enableRateLimit': True})
except Exception as e:
    print(f"Error initializing ccxt: {e}. Bot will run with limited functionality.")
    exchange = None

# Global State for Persistence (Simulated)
# In a real-world app, this state would be persisted via Firestore or another database
bot_state = {
    'current_position': 0.0, # Quantity: >0 for Long, <0 for Short, 0 for Flat
    'wallet_balance': 1000.0, # Starting simulated balance for calculations
    'realized_wins': 0,
    'realized_losses': 0,
    'position_entry_price': 0.0,
    'position_entry_time': None,
}

# Data Storage (using deque for efficient history management)
# We mock historical OHLCV data as the platform cannot fetch large external files/data sets
historical_data = deque(maxlen=LOOKBACK_PERIOD)
scaler = StandardScaler()
model = HistGradientBoostingClassifier(random_state=42, max_depth=5, learning_rate=0.1)

# --- UTILITY & BASH FUNCTIONS ---

def run_bash_command(command: str) -> Tuple[str, bool]:
    """Execute a bash command and return its output and success status."""
    try:
        result = subprocess.run(
            command,
            shell=True,
            check=True,
            capture_output=True,
            text=True
        )
        return result.stdout.strip(), True
    except subprocess.CalledProcessError as e:
        print(f"BASH ERROR (Code {e.returncode}): Command '{e.cmd}' failed. Stderr: {e.stderr.strip()}")
        return e.stderr.strip(), False
    except FileNotFoundError:
        print(f"BASH ERROR: Command not found. Is the path correct?")
        return "Command not found", False
    except Exception as e:
        print(f"An unexpected error occurred: {e}")
        return str(e), False

def run_wallet_sh() -> Optional[float]:
    """Get the latest USDT balance from the wallet script."""
    output, success = run_bash_command(f"bash /wallet.sh get real {QUOTE_COIN} balance from this")
    if success:
        # Assuming the output is a float number, potentially with prefix text
        match = re.search(r"(\d+(\.\d+)?)", output)
        if match:
            try:
                balance = float(match.group(0))
                return balance
            except ValueError:
                print(f"Could not parse float balance from: {output}")
                return None
    return None

def run_place_order(quantity: float, side: str) -> Tuple[str, bool]:
    """Place a market order using the bash script."""
    qty_str = f"{abs(quantity):.8f}" # Ensure high precision
    command = f"bash /placeorder.sh {BASE_COIN} {qty_str} {side}"
    output, success = run_bash_command(command)
    return output, success

def run_close_positions_sh() -> Tuple[str, bool]:
    """Execute the close positions script."""
    print("Attempting to close all open positions at bot start...")
    output, success = run_bash_command("bash /closepositions.sh")
    if success:
        print("Positions closed successfully.")
    else:
        print(f"Failed to close positions: {output}")
    return output, success

def get_unrealized_pnl(symbol: str, current_price: float) -> Tuple[float, Optional[Dict[str, Any]]]:
    """
    Parses coinrealinfo.sh output and calculates Unrealized PnL.
    Assumes quantity is absolute and side is determined by the global position state.
    """
    output, success = run_bash_command(f"bash /coinrealinfo.sh {symbol} layout")
    position_info = {
        'quantity': 0.0,
        'entry_price': 0.0,
        'side': 'Flat'
    }
    unrealized_pnl = 0.0

    if not success or "NO INFO" in output:
        # If the script fails or returns NO INFO, we treat it as flat
        bot_state['current_position'] = 0.0
        return 0.0, None

    # Parsing the output
    lines = output.split('\n')
    data = {}
    for line in lines:
        if ':' in line:
            key, value = line.split(':', 1)
            data[key.strip()] = value.strip()

    try:
        quantity = float(data.get('Quantity', 0.0))
        entry_price = float(data.get('Entry Price', 0.0))

        if quantity > 0 and entry_price > 0:
            # Determine side from bot state since /coinrealinfo.sh doesn't provide it
            side_multiplier = np.sign(bot_state['current_position'])
            position_info['quantity'] = quantity
            position_info['entry_price'] = entry_price
            position_info['side'] = 'Long' if side_multiplier > 0 else 'Short'

            # PnL Calculation: PnL = (Current Price - Entry Price) * Quantity * Side Multiplier
            unrealized_pnl = (current_price - entry_price) * quantity * side_multiplier

    except (ValueError, TypeError) as e:
        print(f"PnL Parsing Error: Could not convert data to float. {e}")

    return unrealized_pnl, position_info

# --- DATA AND INDICATOR FUNCTIONS ---

def fetch_ticker_and_historical_data() -> Tuple[Optional[pd.DataFrame], Optional[float], Optional[float]]:
    """
    Fetches real-time ticker data (bid/ask) and mocks historical OHLCV data.
    """
    bid = None
    ask = None

    if exchange:
        try:
            ticker = exchange.fetch_ticker(SYMBOL)
            bid = ticker['bid']
            ask = ticker['ask']
        except Exception as e:
            print(f"CCXT Error fetching ticker: {e}. Using simulated data.")

    # --- SIMULATE HISTORICAL DATA GENERATION ---
    # In a live bot, you would use ccxt.fetch_ohlcv here.
    # We must generate mock data to calculate indicators like ATR.
    if not historical_data:
        # Initialize with a base set of data points
        base_price = 7.0 if not bid else (bid + ask) / 2
        for i in range(LOOKBACK_PERIOD):
            # Generate slightly randomized data
            close_price = base_price + np.random.uniform(-0.1, 0.1)
            open_price = close_price + np.random.uniform(-0.05, 0.05)
            high_price = max(open_price, close_price) + np.random.uniform(0.01, 0.03)
            low_price = min(open_price, close_price) - np.random.uniform(0.01, 0.03)
            volume = np.random.uniform(100, 500)
            historical_data.append([
                time.time() - (LOOKBACK_PERIOD - i) * 60 * 5, # Mock timestamp (5 min bars)
                open_price, high_price, low_price, close_price, volume
            ])

    # Update with a new bar if time elapsed is sufficient (mocking a 5-minute interval)
    # The current best price (mid_price) is used as the new closing price
    mid_price = (bid + ask) / 2 if bid and ask else (historical_data[-1][4] * 1.0001)

    # Mock the latest bar data based on the real-time bid/ask
    new_data = [
        time.time(),
        historical_data[-1][4], # Open = previous close
        mid_price + abs(mid_price - historical_data[-1][4]) * 0.5, # Mock High
        mid_price - abs(mid_price - historical_data[-1][4]) * 0.5, # Mock Low
        mid_price, # Close = Mid-Price
        historical_data[-1][5] * np.random.uniform(0.9, 1.1) # Mock Volume
    ]

    historical_data.append(new_data)
    df = pd.DataFrame(historical_data, columns=['timestamp', 'open', 'high', 'low', 'close', 'volume'])

    return df.tail(LOOKBACK_PERIOD).reset_index(drop=True), bid, ask

def calculate_indicators(df: pd.DataFrame) -> pd.DataFrame:
    """Calculate technical indicators including ATR for volatility and features for ML."""

    # 1. Average True Range (ATR) - For adaptive risk
    def calculate_atr(df, window=VOLATILITY_WINDOW):
        high_low = df['high'] - df['low']
        high_prev_close = np.abs(df['high'] - df['close'].shift(1))
        low_prev_close = np.abs(df['low'] - df['close'].shift(1))
        true_range = pd.concat([high_low, high_prev_close, low_prev_close], axis=1).max(axis=1)
        return true_range.rolling(window=window).mean()

    df['ATR'] = calculate_atr(df)
    df['ATR_pct'] = df['ATR'] / df['close'] * 100 # ATR as a percentage of price

    # 2. Relative Strength Index (RSI) - Momentum feature
    delta = df['close'].diff()
    gain = (delta.where(delta > 0, 0)).rolling(window=WINDOW_SIZE).mean()
    loss = (-delta.where(delta < 0, 0)).rolling(window=WINDOW_SIZE).mean()
    RS = gain / loss
    df['RSI'] = 100 - (100 / (1 + RS))

    # 3. Rate of Change (ROC) - Momentum feature
    df['ROC'] = df['close'].pct_change(periods=WINDOW_SIZE) * 100

    # 4. Standard Deviation (Volatility Feature)
    df['Volatility'] = df['close'].rolling(window=WINDOW_SIZE).std()

    # 5. Volatility Ratio (Mean Reversion Feature)
    df['VolRatio'] = df['Volatility'] / df['ATR']

    # 6. Target Variable (Shift 1 bar forward to predict the next bar)
    # Target 1 (Buy Signal): Next bar's close is higher than current close
    df['Target'] = np.where(df['close'].shift(-1) > df['close'], 1, 0)
    # The last row's Target will be NaN, which is what we need for prediction

    df.dropna(inplace=True)
    return df

# --- ADAPTIVE STRATEGY & ML FUNCTIONS ---

def prepare_and_train_model(df: pd.DataFrame) -> Optional[float]:
    """Prepares features, trains the ML model, and returns current accuracy."""
    features = ['ATR_pct', 'RSI', 'ROC', 'Volatility', 'VolRatio']

    if len(df) < MIN_TRAINING_SAMPLES:
        print(f"WARNING: Insufficient data for training ({len(df)}/{MIN_TRAINING_SAMPLES}).")
        return None

    X = df[features].values
    y = df['Target'].values

    # Scale features
    X_scaled = scaler.fit_transform(X)

    # Train model (use all data for the latest model)
    model.fit(X_scaled, y)

    # Calculate model accuracy on the training set
    accuracy = model.score(X_scaled, y)
    return accuracy

def generate_signal(df: pd.DataFrame) -> Tuple[float, float, str]:
    """
    Generates a trade signal based on the latest trained model.
    Returns: (Prob_Buy, Prob_Sell, Signal)
    """
    features = ['ATR_pct', 'RSI', 'ROC', 'Volatility', 'VolRatio']

    # Prepare the latest bar for prediction
    latest_bar_features = df[features].iloc[[-1]].values
    X_pred = scaler.transform(latest_bar_features)

    # Get probability prediction
    probabilities = model.predict_proba(X_pred)[0]
    prob_sell = probabilities[0]
    prob_buy = probabilities[1]

    signal = 'HOLD'
    if prob_buy > BASE_PROBABILITY_THRESHOLD:
        signal = 'BUY'
    elif prob_sell > BASE_PROBABILITY_THRESHOLD:
        signal = 'SELL'

    return prob_buy, prob_sell, signal

def adaptive_position_sizing(wallet_balance: float, current_price: float, atr: float, prob_buy: float, prob_sell: float) -> float:
    """
    Calculates adaptive position quantity based on ATR, Wallet Balance, and ML Confidence.

    Position Sizing (Risk-based):
    Position_USD = (Wallet Balance * Effective_Risk_Percent) / (ATR * ATR_MULTIPLIER_SL)
    Quantity_ATOM = Position_USD / Current Price
    """
    # 1. Determine confidence multiplier
    if prob_buy >= prob_sell:
        confidence = max(0, prob_buy - 0.5) * 2 # Scale 0.5 to 1.0 to 0 to 1.0
    else:
        confidence = max(0, prob_sell - 0.5) * 2

    # 2. Calculate Effective Risk Percent
    # Confident trades take a larger risk size, up to 3x BASE_RISK_PERCENT
    # The effective risk is capped by the high probability, but floored at 1x BASE_RISK_PERCENT
    effective_risk_percent = BASE_RISK_PERCENT * (1.0 + confidence * 2.0)
    effective_risk_percent = min(0.03, effective_risk_percent) # Cap at 3% risk

    # 3. Calculate Risk Per Trade (in QUOTE_COIN)
    # The risk is the potential loss up to the Stop Loss level.
    risk_per_trade_usdt = wallet_balance * effective_risk_percent

    # 4. Calculate volatility-based risk in price terms (Stop Loss distance)
    # Stop Loss distance in price: ATR * SL_Multiplier
    sl_distance = atr * ATR_MULTIPLIER_SL

    # 5. Calculate Position Size (in BASE_COIN quantity)
    if sl_distance <= 0:
        return 0.0

    # Quantity = Risk (in USDT) / Stop Loss Distance (in Price)
    # Then multiply by LEVERAGE (futures trading assumption)
    position_quantity_atom = (risk_per_trade_usdt / sl_distance) * LEVERAGE

    # Final check: Must be greater than MIN_QTY
    return position_quantity_atom if position_quantity_atom >= MIN_QTY else 0.0

# --- DASHBOARD & MAIN LOOP ---

def update_dashboard(
    wallet_balance: float,
    current_position: float,
    prob_buy: float,
    prob_sell: float,
    ml_accuracy: float,
    unrealized_pnl: float,
    position_entry_time: Optional[datetime],
    target_price: float,
    stop_price: float
):
    """Generates the HTML dashboard file."""
    # Format data for display
    current_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    # Determine Position Status and Side
    if current_position > 0:
        status_text = f"LONG ({abs(current_position):.8f} {BASE_COIN})"
        status_color = 'bg-green-600'
    elif current_position < 0:
        status_text = f"SHORT ({abs(current_position):.8f} {BASE_COIN})"
        status_color = 'bg-red-600'
    else:
        status_text = "FLAT"
        status_color = 'bg-gray-600'

    pnl_color = 'text-green-400' if unrealized_pnl >= 0 else 'text-red-400'

    entry_time_display = position_entry_time.strftime("%H:%M:%S") if position_entry_time else 'N/A'

    # Get the contents of the dashboard HTML file
    dashboard_content = f"""
        <!-- Generated at {current_time} -->
        <div class="p-6 max-w-4xl mx-auto bg-gray-900 shadow-2xl rounded-xl">
            <h1 class="text-3xl font-extrabold text-blue-400 mb-6 border-b border-gray-700 pb-2">
                AI Adaptive Futures Bot Status
            </h1>
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                <!-- Wallet Balance -->
                <div class="p-4 bg-gray-800 rounded-lg">
                    <p class="text-sm font-medium text-gray-400">USDT Wallet Balance</p>
                    <p class="text-2xl font-bold text-white">${wallet_balance:,.2f}</p>
                </div>
                <!-- Current Position -->
                <div class="{status_color} p-4 rounded-lg text-white">
                    <p class="text-sm font-medium">Position Status</p>
                    <p class="text-2xl font-bold">{status_text}</p>
                </div>
                <!-- Unrealized PnL -->
                <div class="p-4 bg-gray-800 rounded-lg">
                    <p class="text-sm font-medium text-gray-400">Unrealized PnL</p>
                    <p class="text-2xl font-bold {pnl_color}">${unrealized_pnl:,.4f}</p>
                </div>
            </div>

            <!-- Trade Metrics -->
            <div class="grid grid-cols-2 gap-4 mb-6">
                <div class="p-4 bg-gray-800 rounded-lg">
                    <p class="text-sm font-medium text-gray-400">Target Price (TP)</p>
                    <p class="text-xl font-semibold text-cyan-400">{target_price:.8f} USDT</p>
                </div>
                <div class="p-4 bg-gray-800 rounded-lg">
                    <p class="text-sm font-medium text-gray-400">Stop Loss Price (SL)</p>
                    <p class="text-xl font-semibold text-pink-400">{stop_price:.8f} USDT</p>
                </div>
            </div>

            <h2 class="text-xl font-semibold text-gray-300 mt-6 mb-4 border-b border-gray-700 pb-2">
                AI Signal Confidence & Metrics
            </h2>
            <div class="grid grid-cols-3 gap-4">
                <div class="p-4 bg-gray-800 rounded-lg">
                    <p class="text-sm font-medium text-gray-400">ML Buy Confidence</p>
                    <p class="text-2xl font-bold text-green-400">{(prob_buy * 100):.2f}%</p>
                </div>
                <div class="p-4 bg-gray-800 rounded-lg">
                    <p class="text-sm font-medium text-gray-400">ML Sell Confidence</p>
                    <p class="text-2xl font-bold text-red-400">{(prob_sell * 100):.2f}%</p>
                </div>
                <div class="p-4 bg-gray-800 rounded-lg">
                    <p class="text-sm font-medium text-gray-400">Model Accuracy</p>
                    <p class="text-2xl font-bold text-yellow-400">{(ml_accuracy * 100):.2f}%</p>
                </div>
            </div>

            <h2 class="text-xl font-semibold text-gray-300 mt-6 mb-4 border-b border-gray-700 pb-2">
                Position Details
            </h2>
            <div class="grid grid-cols-2 gap-4">
                <div class="p-4 bg-gray-800 rounded-lg">
                    <p class="text-sm font-medium text-gray-400">Entry Time</p>
                    <p class="text-lg font-semibold text-white">{entry_time_display}</p>
                </div>
                <div class="p-4 bg-gray-800 rounded-lg">
                    <p class="text-sm font-medium text-gray-400">Leverage</p>
                    <p class="text-lg font-semibold text-white">{LEVERAGE}x</p>
                </div>
            </div>

            <p class="text-xs text-gray-500 mt-6 text-center">
                Last Update: {current_time} | Symbol: {SYMBOL}
            </p>
        </div>
    """

    try:
        # Check permissions and write to file
        with open(DASHBOARD_PATH, "w") as f:
            f.write(dashboard_content)
        # print(f"Dashboard successfully updated at {DASHBOARD_PATH}")
        # Note: Do not print success message repeatedly in the loop.
    except IOError as e:
        print(f"ERROR: Could not write to dashboard file {DASHBOARD_PATH}. Check permissions: {e}")

def main():
    """The main trading bot loop."""
    global bot_state
    
    # Placeholder for the latest calculated ATR and price
    latest_atr = 0.0
    latest_price = 0.0

    # Initial ML training flag
    is_model_trained = False
    ml_accuracy = 0.0

    print(f"--- AI Adaptive Bot Initializing for {SYMBOL} ---")

    while True:
        start_time = time.time()
        print(f"\n--- Cycle Start: {datetime.now().strftime('%H:%M:%S')} ---")

        # 1. Fetch Data
        data_frame, bid, ask = fetch_ticker_and_historical_data()
        current_price = (bid + ask) / 2 if bid and ask else data_frame['close'].iloc[-1]
        
        if bid is None or ask is None:
            print("WARNING: Could not fetch real-time bid/ask from ccxt. Skipping this cycle.")
            time.sleep(INTERVAL_SECONDS)
            continue

        latest_price = current_price

        # 2. Calculate Indicators
        df_indicators = calculate_indicators(data_frame.copy())
        if not df_indicators.empty:
            latest_atr = df_indicators['ATR'].iloc[-1]
            print(f"Latest Price: {current_price:.8f} | ATR: {latest_atr:.8f}")
        else:
            print("ERROR: Indicators could not be calculated. Skipping cycle.")
            time.sleep(INTERVAL_SECONDS)
            continue


        # 3. Train ML Model
        ml_accuracy = prepare_and_train_model(df_indicators) or ml_accuracy
        if ml_accuracy:
            is_model_trained = True
            print(f"Model Trained. Accuracy: {ml_accuracy * 100:.2f}%")
        else:
            is_model_trained = False

        # 4. Get Latest Wallet Balance (critical for sizing)
        wallet_balance = run_wallet_sh()
        if wallet_balance is not None:
            bot_state['wallet_balance'] = wallet_balance
        else:
            wallet_balance = bot_state['wallet_balance'] # Use simulated balance as fallback
            print(f"WARNING: Could not fetch real wallet balance. Using fallback: ${wallet_balance:.2f}")


        # --- Adaptive Signal Generation and Execution ---

        prob_buy, prob_sell, signal = 0.0, 0.0, 'HOLD'
        target_price, stop_price = 0.0, 0.0

        if is_model_trained:
            prob_buy, prob_sell, signal = generate_signal(df_indicators)
            print(f"AI Signal: {signal} | Conf: B={prob_buy:.4f} S={prob_sell:.4f}")

        # 5. Position Management (Exit/Take Profit/Stop Loss)

        # Get the true position info from the bash script (updates bot_state['current_position'])
        unrealized_pnl, position_info = get_unrealized_pnl(SYMBOL, latest_price)
        current_position = bot_state['current_position']
        entry_price = position_info.get('entry_price', bot_state['position_entry_price'])
        position_side = position_info.get('side', 'Flat')
        
        # Recalculate T/SL based on latest ATR and Entry Price if a position is open
        if current_position != 0.0 and entry_price > 0 and latest_atr > 0:
            
            # Recalculate dynamic T/SL prices based on current ATR and position side
            if position_side == 'Long':
                target_price = entry_price + (latest_atr * ATR_MULTIPLIER_TP)
                stop_price = entry_price - (latest_atr * ATR_MULTIPLIER_SL)
                
                # Check for TP/SL exit
                if latest_price >= target_price:
                    print(f"TAKE PROFIT (LONG): Price {latest_price:.8f} >= TP {target_price:.8f}")
                    run_place_order(current_position, 'sell')
                    bot_state['current_position'] = 0.0
                elif latest_price <= stop_price:
                    print(f"STOP LOSS (LONG): Price {latest_price:.8f} <= SL {stop_price:.8f}")
                    run_place_order(current_position, 'sell')
                    bot_state['current_position'] = 0.0
            
            elif position_side == 'Short':
                target_price = entry_price - (latest_atr * ATR_MULTIPLIER_TP)
                stop_price = entry_price + (latest_atr * ATR_MULTIPLIER_SL)
                
                # Check for TP/SL exit
                if latest_price <= target_price:
                    print(f"TAKE PROFIT (SHORT): Price {latest_price:.8f} <= TP {target_price:.8f}")
                    run_place_order(current_position, 'buy')
                    bot_state['current_position'] = 0.0
                elif latest_price >= stop_price:
                    print(f"STOP LOSS (SHORT): Price {latest_price:.8f} >= SL {stop_price:.8f}")
                    run_place_order(current_position, 'buy')
                    bot_state['current_position'] = 0.0

            # Check for Time-Based Stop Loss (T-SL)
            if bot_state['position_entry_time'] and datetime.now() > (bot_state['position_entry_time'] + timedelta(minutes=MAX_HOLDING_PERIOD_MINUTES)):
                print(f"TIME-BASED STOP LOSS: Position held for over {MAX_HOLDING_PERIOD_MINUTES} minutes. Closing...")
                if position_side == 'Long':
                    run_place_order(current_position, 'sell')
                elif position_side == 'Short':
                    run_place_order(current_position, 'buy')
                bot_state['current_position'] = 0.0
            
            # If position was closed by T/SL/TP logic above, reset entry time
            if bot_state['current_position'] == 0.0:
                bot_state['position_entry_time'] = None
                bot_state['position_entry_price'] = 0.0

        # 6. Signal Execution (Entry)
        if current_position == 0.0 and is_model_trained and latest_atr > 0:
            quantity_to_trade = adaptive_position_sizing(wallet_balance, current_price, latest_atr, prob_buy, prob_sell)

            if quantity_to_trade >= MIN_QTY:
                
                success = False
                if signal == 'BUY':
                    print(f"ENTRY LONG: Qty={quantity_to_trade:.8f}, Price={current_price:.8f}")
                    msg, success = run_place_order(quantity_to_trade, 'buy')
                    if success:
                        bot_state['current_position'] = quantity_to_trade
                        bot_state['position_entry_price'] = latest_price
                elif signal == 'SELL':
                    # Short position is a negative quantity internally
                    print(f"ENTRY SHORT: Qty={quantity_to_trade:.8f}, Price={current_price:.8f}")
                    msg, success = run_place_order(quantity_to_trade, 'sell')
                    if success:
                        bot_state['current_position'] = -quantity_to_trade
                        bot_state['position_entry_price'] = latest_price

                if success:
                    print(f"Order Success: {msg}")
                    # Set entry time for T-SL tracking
                    bot_state['position_entry_time'] = datetime.now()
                else:
                    print(f"Order Error: {msg}")

            else:
                print(f"HOLD: Calculated quantity {quantity_to_trade:.8f} is too small or signal confidence too low.")
        else:
            print(f"Current Position: {current_position:.8f} | Unrealized PnL: ${unrealized_pnl:.4f}")
            if current_position == 0.0 and not is_model_trained:
                 print("HOLD: Waiting for enough data to train ML model.")

        # 7. Update Dashboard
        update_dashboard(
            wallet_balance,
            bot_state['current_position'],
            prob_buy,
            prob_sell,
            ml_accuracy,
            unrealized_pnl,
            bot_state['position_entry_time'],
            target_price,
            stop_price
        )

        # 8. Wait for next cycle
        end_time = time.time()
        elapsed = end_time - start_time
        sleep_duration = max(0.0, INTERVAL_SECONDS - elapsed)
        print(f"Cycle finished in {elapsed:.2f}s. Sleeping for {sleep_duration:.2f}s.")
        time.sleep(sleep_duration)

def close_all_positions_on_start():
    """Runs the close positions script once at startup."""
    run_close_positions_sh()
    # Reset state after closing
    bot_state['current_position'] = 0.0
    bot_state['position_entry_price'] = 0.0
    bot_state['position_entry_time'] = None

if __name__ == '__main__':
    # Initial setup before the main loop starts
    close_all_positions_on_start()

    # Run the main bot logic
    try:
        main()
    except KeyboardInterrupt:
        print("\nBot stopped by user (KeyboardInterrupt).")
    except Exception as e:
        print(f"\nCRITICAL BOT FAILURE: {e}")
        time.sleep(5)
